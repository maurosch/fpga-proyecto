   1              		.file	"libusbwrap.c"
   2              		.text
   3              	.Ltext0:
   4              		.file 0 "/home/pong/FPGALink/makestuff/libs/libusbwrap" "libusbwrap.c"
   6              	queueSize:
   7              	.LFB10:
   8              		.file 1 "unbounded_queue.h"
   1:unbounded_queue.h **** #ifndef UNBOUNDED_QUEUE_H
   2:unbounded_queue.h **** #define UNBOUNDED_QUEUE_H
   3:unbounded_queue.h **** 
   4:unbounded_queue.h **** #include "libusbwrap.h"
   5:unbounded_queue.h **** 
   6:unbounded_queue.h **** #ifdef __cplusplus
   7:unbounded_queue.h **** extern "C" {
   8:unbounded_queue.h **** #endif
   9:unbounded_queue.h **** 
  10:unbounded_queue.h **** 	typedef const void* Item;
  11:unbounded_queue.h **** 	typedef Item (*CreateFunc)(void);
  12:unbounded_queue.h **** 	typedef void (*DestroyFunc)(Item);
  13:unbounded_queue.h **** 
  14:unbounded_queue.h **** 	struct UnboundedQueue {
  15:unbounded_queue.h **** 		Item *itemArray;
  16:unbounded_queue.h **** 		size_t capacity;
  17:unbounded_queue.h **** 		size_t putIndex;
  18:unbounded_queue.h **** 		size_t takeIndex;
  19:unbounded_queue.h **** 		size_t numItems;
  20:unbounded_queue.h **** 		CreateFunc createFunc;
  21:unbounded_queue.h **** 		DestroyFunc destroyFunc;
  22:unbounded_queue.h **** 	};
  23:unbounded_queue.h **** 
  24:unbounded_queue.h **** 	USBStatus queueInit(
  25:unbounded_queue.h **** 		struct UnboundedQueue *self, size_t capacity, CreateFunc createFunc, DestroyFunc destroyFunc
  26:unbounded_queue.h **** 	);
  27:unbounded_queue.h **** 	USBStatus queuePut(
  28:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // never blocks, can ENOMEM
  29:unbounded_queue.h **** 	);
  30:unbounded_queue.h **** 	void queueCommitPut(
  31:unbounded_queue.h **** 		struct UnboundedQueue *self
  32:unbounded_queue.h **** 	);
  33:unbounded_queue.h **** 	USBStatus queueTake(
  34:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // returns NULL on empty
  35:unbounded_queue.h **** 	);
  36:unbounded_queue.h **** 	void queueCommitTake(
  37:unbounded_queue.h **** 		struct UnboundedQueue *self
  38:unbounded_queue.h **** 	);
  39:unbounded_queue.h **** 	void queueDestroy(
  40:unbounded_queue.h **** 		struct UnboundedQueue *self
  41:unbounded_queue.h **** 	);
  42:unbounded_queue.h **** 	static inline size_t queueSize(const struct UnboundedQueue *self) {
   9              		.loc 1 42 68
  10              		.cfi_startproc
  11 0000 55       		pushq	%rbp
  12              		.cfi_def_cfa_offset 16
  13              		.cfi_offset 6, -16
  14 0001 4889E5   		movq	%rsp, %rbp
  15              		.cfi_def_cfa_register 6
  16 0004 48897DF8 		movq	%rdi, -8(%rbp)
  43:unbounded_queue.h **** 		return self->numItems;
  17              		.loc 1 43 14
  18 0008 488B45F8 		movq	-8(%rbp), %rax
  19 000c 488B4020 		movq	32(%rax), %rax
  44:unbounded_queue.h **** 	}
  20              		.loc 1 44 2
  21 0010 5D       		popq	%rbp
  22              		.cfi_def_cfa 7, 8
  23 0011 C3       		ret
  24              		.cfi_endproc
  25              	.LFE10:
  28              	libusb_fill_bulk_transfer:
  29              	.LFB16:
  30              		.file 2 "/usr/include/libusb-1.0/libusb.h"
   1:/usr/include/libusb-1.0/libusb.h **** /*
   2:/usr/include/libusb-1.0/libusb.h ****  * Public libusb header file
   3:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2001 Johannes Erdfelt <johannes@erdfelt.com>
   4:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2007-2008 Daniel Drake <dsd@gentoo.org>
   5:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Pete Batard <pete@akeo.ie>
   6:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012-2018 Nathan Hjelm <hjelmn@cs.unm.edu>
   7:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2014-2020 Chris Dickens <christopher.a.dickens@gmail.com>
   8:/usr/include/libusb-1.0/libusb.h ****  * For more information, please visit: http://libusb.info
   9:/usr/include/libusb-1.0/libusb.h ****  *
  10:/usr/include/libusb-1.0/libusb.h ****  * This library is free software; you can redistribute it and/or
  11:/usr/include/libusb-1.0/libusb.h ****  * modify it under the terms of the GNU Lesser General Public
  12:/usr/include/libusb-1.0/libusb.h ****  * License as published by the Free Software Foundation; either
  13:/usr/include/libusb-1.0/libusb.h ****  * version 2.1 of the License, or (at your option) any later version.
  14:/usr/include/libusb-1.0/libusb.h ****  *
  15:/usr/include/libusb-1.0/libusb.h ****  * This library is distributed in the hope that it will be useful,
  16:/usr/include/libusb-1.0/libusb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:/usr/include/libusb-1.0/libusb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18:/usr/include/libusb-1.0/libusb.h ****  * Lesser General Public License for more details.
  19:/usr/include/libusb-1.0/libusb.h ****  *
  20:/usr/include/libusb-1.0/libusb.h ****  * You should have received a copy of the GNU Lesser General Public
  21:/usr/include/libusb-1.0/libusb.h ****  * License along with this library; if not, write to the Free Software
  22:/usr/include/libusb-1.0/libusb.h ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  23:/usr/include/libusb-1.0/libusb.h ****  */
  24:/usr/include/libusb-1.0/libusb.h **** 
  25:/usr/include/libusb-1.0/libusb.h **** #ifndef LIBUSB_H
  26:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_H
  27:/usr/include/libusb-1.0/libusb.h **** 
  28:/usr/include/libusb-1.0/libusb.h **** #if defined(_MSC_VER)
  29:/usr/include/libusb-1.0/libusb.h **** /* on MS environments, the inline keyword is available in C++ only */
  30:/usr/include/libusb-1.0/libusb.h **** #if !defined(__cplusplus)
  31:/usr/include/libusb-1.0/libusb.h **** #define inline __inline
  32:/usr/include/libusb-1.0/libusb.h **** #endif
  33:/usr/include/libusb-1.0/libusb.h **** /* ssize_t is also not available */
  34:/usr/include/libusb-1.0/libusb.h **** #ifndef _SSIZE_T_DEFINED
  35:/usr/include/libusb-1.0/libusb.h **** #define _SSIZE_T_DEFINED
  36:/usr/include/libusb-1.0/libusb.h **** #include <basetsd.h>
  37:/usr/include/libusb-1.0/libusb.h **** typedef SSIZE_T ssize_t;
  38:/usr/include/libusb-1.0/libusb.h **** #endif /* _SSIZE_T_DEFINED */
  39:/usr/include/libusb-1.0/libusb.h **** #endif /* _MSC_VER */
  40:/usr/include/libusb-1.0/libusb.h **** 
  41:/usr/include/libusb-1.0/libusb.h **** #include <limits.h>
  42:/usr/include/libusb-1.0/libusb.h **** #include <stdint.h>
  43:/usr/include/libusb-1.0/libusb.h **** #include <sys/types.h>
  44:/usr/include/libusb-1.0/libusb.h **** #if !defined(_MSC_VER)
  45:/usr/include/libusb-1.0/libusb.h **** #include <sys/time.h>
  46:/usr/include/libusb-1.0/libusb.h **** #endif
  47:/usr/include/libusb-1.0/libusb.h **** #include <time.h>
  48:/usr/include/libusb-1.0/libusb.h **** 
  49:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
  50:/usr/include/libusb-1.0/libusb.h **** #define ZERO_SIZED_ARRAY		/* [] - valid C99 code */
  51:/usr/include/libusb-1.0/libusb.h **** #else
  52:/usr/include/libusb-1.0/libusb.h **** #define ZERO_SIZED_ARRAY	0	/* [0] - non-standard, but usually working code */
  53:/usr/include/libusb-1.0/libusb.h **** #endif /* __STDC_VERSION__ */
  54:/usr/include/libusb-1.0/libusb.h **** 
  55:/usr/include/libusb-1.0/libusb.h **** /* 'interface' might be defined as a macro on Windows, so we need to
  56:/usr/include/libusb-1.0/libusb.h ****  * undefine it so as not to break the current libusb API, because
  57:/usr/include/libusb-1.0/libusb.h ****  * libusb_config_descriptor has an 'interface' member
  58:/usr/include/libusb-1.0/libusb.h ****  * As this can be problematic if you include windows.h after libusb.h
  59:/usr/include/libusb-1.0/libusb.h ****  * in your sources, we force windows.h to be included first. */
  60:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__)
  61:/usr/include/libusb-1.0/libusb.h **** #include <windows.h>
  62:/usr/include/libusb-1.0/libusb.h **** #if defined(interface)
  63:/usr/include/libusb-1.0/libusb.h **** #undef interface
  64:/usr/include/libusb-1.0/libusb.h **** #endif
  65:/usr/include/libusb-1.0/libusb.h **** #if !defined(__CYGWIN__)
  66:/usr/include/libusb-1.0/libusb.h **** #include <winsock.h>
  67:/usr/include/libusb-1.0/libusb.h **** #endif
  68:/usr/include/libusb-1.0/libusb.h **** #endif /* _WIN32 || __CYGWIN__ */
  69:/usr/include/libusb-1.0/libusb.h **** 
  70:/usr/include/libusb-1.0/libusb.h **** #if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
  71:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f) __attribute__ ((deprecated ("Use " #f " instead")))
  72:/usr/include/libusb-1.0/libusb.h **** #elif defined(__GNUC__) && (__GNUC__ >= 3)
  73:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f) __attribute__ ((deprecated))
  74:/usr/include/libusb-1.0/libusb.h **** #else
  75:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f)
  76:/usr/include/libusb-1.0/libusb.h **** #endif /* __GNUC__ */
  77:/usr/include/libusb-1.0/libusb.h **** 
  78:/usr/include/libusb-1.0/libusb.h **** #if defined(__GNUC__)
  79:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_PACKED __attribute__ ((packed))
  80:/usr/include/libusb-1.0/libusb.h **** #else
  81:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_PACKED
  82:/usr/include/libusb-1.0/libusb.h **** #endif /* __GNUC__ */
  83:/usr/include/libusb-1.0/libusb.h **** 
  84:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_CALL
  85:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
  86:/usr/include/libusb-1.0/libusb.h ****  * libusb's Windows calling convention.
  87:/usr/include/libusb-1.0/libusb.h ****  *
  88:/usr/include/libusb-1.0/libusb.h ****  * Under Windows, the selection of available compilers and configurations
  89:/usr/include/libusb-1.0/libusb.h ****  * means that, unlike other platforms, there is not <em>one true calling
  90:/usr/include/libusb-1.0/libusb.h ****  * convention</em> (calling convention: the manner in which parameters are
  91:/usr/include/libusb-1.0/libusb.h ****  * passed to functions in the generated assembly code).
  92:/usr/include/libusb-1.0/libusb.h ****  *
  93:/usr/include/libusb-1.0/libusb.h ****  * Matching the Windows API itself, libusb uses the WINAPI convention (which
  94:/usr/include/libusb-1.0/libusb.h ****  * translates to the <tt>stdcall</tt> convention) and guarantees that the
  95:/usr/include/libusb-1.0/libusb.h ****  * library is compiled in this way. The public header file also includes
  96:/usr/include/libusb-1.0/libusb.h ****  * appropriate annotations so that your own software will use the right
  97:/usr/include/libusb-1.0/libusb.h ****  * convention, even if another convention is being used by default within
  98:/usr/include/libusb-1.0/libusb.h ****  * your codebase.
  99:/usr/include/libusb-1.0/libusb.h ****  *
 100:/usr/include/libusb-1.0/libusb.h ****  * The one consideration that you must apply in your software is to mark
 101:/usr/include/libusb-1.0/libusb.h ****  * all functions which you use as libusb callbacks with this LIBUSB_CALL
 102:/usr/include/libusb-1.0/libusb.h ****  * annotation, so that they too get compiled for the correct calling
 103:/usr/include/libusb-1.0/libusb.h ****  * convention.
 104:/usr/include/libusb-1.0/libusb.h ****  *
 105:/usr/include/libusb-1.0/libusb.h ****  * On non-Windows operating systems, this macro is defined as nothing. This
 106:/usr/include/libusb-1.0/libusb.h ****  * means that you can apply it to your code without worrying about
 107:/usr/include/libusb-1.0/libusb.h ****  * cross-platform compatibility.
 108:/usr/include/libusb-1.0/libusb.h ****  */
 109:/usr/include/libusb-1.0/libusb.h **** /* LIBUSB_CALL must be defined on both definition and declaration of libusb
 110:/usr/include/libusb-1.0/libusb.h ****  * functions. You'd think that declaration would be enough, but cygwin will
 111:/usr/include/libusb-1.0/libusb.h ****  * complain about conflicting types unless both are marked this way.
 112:/usr/include/libusb-1.0/libusb.h ****  * The placement of this macro is important too; it must appear after the
 113:/usr/include/libusb-1.0/libusb.h ****  * return type, before the function name. See internal documentation for
 114:/usr/include/libusb-1.0/libusb.h ****  * API_EXPORTED.
 115:/usr/include/libusb-1.0/libusb.h ****  */
 116:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__)
 117:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL WINAPI
 118:/usr/include/libusb-1.0/libusb.h **** #else
 119:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL
 120:/usr/include/libusb-1.0/libusb.h **** #endif /* _WIN32 || __CYGWIN__ */
 121:/usr/include/libusb-1.0/libusb.h **** 
 122:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_API_VERSION
 123:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
 124:/usr/include/libusb-1.0/libusb.h ****  * libusb's API version.
 125:/usr/include/libusb-1.0/libusb.h ****  *
 126:/usr/include/libusb-1.0/libusb.h ****  * Since version 1.0.13, to help with feature detection, libusb defines
 127:/usr/include/libusb-1.0/libusb.h ****  * a LIBUSB_API_VERSION macro that gets increased every time there is a
 128:/usr/include/libusb-1.0/libusb.h ****  * significant change to the API, such as the introduction of a new call,
 129:/usr/include/libusb-1.0/libusb.h ****  * the definition of a new macro/enum member, or any other element that
 130:/usr/include/libusb-1.0/libusb.h ****  * libusb applications may want to detect at compilation time.
 131:/usr/include/libusb-1.0/libusb.h ****  *
 132:/usr/include/libusb-1.0/libusb.h ****  * The macro is typically used in an application as follows:
 133:/usr/include/libusb-1.0/libusb.h ****  * \code
 134:/usr/include/libusb-1.0/libusb.h ****  * #if defined(LIBUSB_API_VERSION) && (LIBUSB_API_VERSION >= 0x01001234)
 135:/usr/include/libusb-1.0/libusb.h ****  * // Use one of the newer features from the libusb API
 136:/usr/include/libusb-1.0/libusb.h ****  * #endif
 137:/usr/include/libusb-1.0/libusb.h ****  * \endcode
 138:/usr/include/libusb-1.0/libusb.h ****  *
 139:/usr/include/libusb-1.0/libusb.h ****  * Internally, LIBUSB_API_VERSION is defined as follows:
 140:/usr/include/libusb-1.0/libusb.h ****  * (libusb major << 24) | (libusb minor << 16) | (16 bit incremental)
 141:/usr/include/libusb-1.0/libusb.h ****  */
 142:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_API_VERSION 0x01000109
 143:/usr/include/libusb-1.0/libusb.h **** 
 144:/usr/include/libusb-1.0/libusb.h **** /* The following is kept for compatibility, but will be deprecated in the future */
 145:/usr/include/libusb-1.0/libusb.h **** #define LIBUSBX_API_VERSION LIBUSB_API_VERSION
 146:/usr/include/libusb-1.0/libusb.h **** 
 147:/usr/include/libusb-1.0/libusb.h **** #if defined(__cplusplus)
 148:/usr/include/libusb-1.0/libusb.h **** extern "C" {
 149:/usr/include/libusb-1.0/libusb.h **** #endif
 150:/usr/include/libusb-1.0/libusb.h **** 
 151:/usr/include/libusb-1.0/libusb.h **** /**
 152:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
 153:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from host-endian to little-endian format. On
 154:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 155:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 156:/usr/include/libusb-1.0/libusb.h ****  * \param x the host-endian value to convert
 157:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in little-endian byte order
 158:/usr/include/libusb-1.0/libusb.h ****  */
 159:/usr/include/libusb-1.0/libusb.h **** static inline uint16_t libusb_cpu_to_le16(const uint16_t x)
 160:/usr/include/libusb-1.0/libusb.h **** {
 161:/usr/include/libusb-1.0/libusb.h **** 	union {
 162:/usr/include/libusb-1.0/libusb.h **** 		uint8_t  b8[2];
 163:/usr/include/libusb-1.0/libusb.h **** 		uint16_t b16;
 164:/usr/include/libusb-1.0/libusb.h **** 	} _tmp;
 165:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[1] = (uint8_t) (x >> 8);
 166:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[0] = (uint8_t) (x & 0xff);
 167:/usr/include/libusb-1.0/libusb.h **** 	return _tmp.b16;
 168:/usr/include/libusb-1.0/libusb.h **** }
 169:/usr/include/libusb-1.0/libusb.h **** 
 170:/usr/include/libusb-1.0/libusb.h **** /** \def libusb_le16_to_cpu
 171:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
 172:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from little-endian to host-endian format. On
 173:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 174:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 175:/usr/include/libusb-1.0/libusb.h ****  * \param x the little-endian value to convert
 176:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in host-endian byte order
 177:/usr/include/libusb-1.0/libusb.h ****  */
 178:/usr/include/libusb-1.0/libusb.h **** #define libusb_le16_to_cpu libusb_cpu_to_le16
 179:/usr/include/libusb-1.0/libusb.h **** 
 180:/usr/include/libusb-1.0/libusb.h **** /* standard USB stuff */
 181:/usr/include/libusb-1.0/libusb.h **** 
 182:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 183:/usr/include/libusb-1.0/libusb.h ****  * Device and/or Interface Class codes */
 184:/usr/include/libusb-1.0/libusb.h **** enum libusb_class_code {
 185:/usr/include/libusb-1.0/libusb.h **** 	/** In the context of a \ref libusb_device_descriptor "device descriptor",
 186:/usr/include/libusb-1.0/libusb.h **** 	 * this bDeviceClass value indicates that each interface specifies its
 187:/usr/include/libusb-1.0/libusb.h **** 	 * own class information and all interfaces operate independently.
 188:/usr/include/libusb-1.0/libusb.h **** 	 */
 189:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PER_INTERFACE = 0x00,
 190:/usr/include/libusb-1.0/libusb.h **** 
 191:/usr/include/libusb-1.0/libusb.h **** 	/** Audio class */
 192:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_AUDIO = 0x01,
 193:/usr/include/libusb-1.0/libusb.h **** 
 194:/usr/include/libusb-1.0/libusb.h **** 	/** Communications class */
 195:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_COMM = 0x02,
 196:/usr/include/libusb-1.0/libusb.h **** 
 197:/usr/include/libusb-1.0/libusb.h **** 	/** Human Interface Device class */
 198:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HID = 0x03,
 199:/usr/include/libusb-1.0/libusb.h **** 
 200:/usr/include/libusb-1.0/libusb.h **** 	/** Physical */
 201:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PHYSICAL = 0x05,
 202:/usr/include/libusb-1.0/libusb.h **** 
 203:/usr/include/libusb-1.0/libusb.h **** 	/** Image class */
 204:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_IMAGE = 0x06,
 205:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PTP = 0x06, /* legacy name from libusb-0.1 usb.h */
 206:/usr/include/libusb-1.0/libusb.h **** 
 207:/usr/include/libusb-1.0/libusb.h **** 	/** Printer class */
 208:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PRINTER = 0x07,
 209:/usr/include/libusb-1.0/libusb.h **** 
 210:/usr/include/libusb-1.0/libusb.h **** 	/** Mass storage class */
 211:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_MASS_STORAGE = 0x08,
 212:/usr/include/libusb-1.0/libusb.h **** 
 213:/usr/include/libusb-1.0/libusb.h **** 	/** Hub class */
 214:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HUB = 0x09,
 215:/usr/include/libusb-1.0/libusb.h **** 
 216:/usr/include/libusb-1.0/libusb.h **** 	/** Data class */
 217:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DATA = 0x0a,
 218:/usr/include/libusb-1.0/libusb.h **** 
 219:/usr/include/libusb-1.0/libusb.h **** 	/** Smart Card */
 220:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_SMART_CARD = 0x0b,
 221:/usr/include/libusb-1.0/libusb.h **** 
 222:/usr/include/libusb-1.0/libusb.h **** 	/** Content Security */
 223:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_CONTENT_SECURITY = 0x0d,
 224:/usr/include/libusb-1.0/libusb.h **** 
 225:/usr/include/libusb-1.0/libusb.h **** 	/** Video */
 226:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VIDEO = 0x0e,
 227:/usr/include/libusb-1.0/libusb.h **** 
 228:/usr/include/libusb-1.0/libusb.h **** 	/** Personal Healthcare */
 229:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0f,
 230:/usr/include/libusb-1.0/libusb.h **** 
 231:/usr/include/libusb-1.0/libusb.h **** 	/** Diagnostic Device */
 232:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0xdc,
 233:/usr/include/libusb-1.0/libusb.h **** 
 234:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless class */
 235:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_WIRELESS = 0xe0,
 236:/usr/include/libusb-1.0/libusb.h **** 
 237:/usr/include/libusb-1.0/libusb.h **** 	/** Miscellaneous class */
 238:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_MISCELLANEOUS = 0xef,
 239:/usr/include/libusb-1.0/libusb.h **** 
 240:/usr/include/libusb-1.0/libusb.h **** 	/** Application class */
 241:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_APPLICATION = 0xfe,
 242:/usr/include/libusb-1.0/libusb.h **** 
 243:/usr/include/libusb-1.0/libusb.h **** 	/** Class is vendor-specific */
 244:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VENDOR_SPEC = 0xff
 245:/usr/include/libusb-1.0/libusb.h **** };
 246:/usr/include/libusb-1.0/libusb.h **** 
 247:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 248:/usr/include/libusb-1.0/libusb.h ****  * Descriptor types as defined by the USB specification. */
 249:/usr/include/libusb-1.0/libusb.h **** enum libusb_descriptor_type {
 250:/usr/include/libusb-1.0/libusb.h **** 	/** Device descriptor. See libusb_device_descriptor. */
 251:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE = 0x01,
 252:/usr/include/libusb-1.0/libusb.h **** 
 253:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration descriptor. See libusb_config_descriptor. */
 254:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_CONFIG = 0x02,
 255:/usr/include/libusb-1.0/libusb.h **** 
 256:/usr/include/libusb-1.0/libusb.h **** 	/** String descriptor */
 257:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_STRING = 0x03,
 258:/usr/include/libusb-1.0/libusb.h **** 
 259:/usr/include/libusb-1.0/libusb.h **** 	/** Interface descriptor. See libusb_interface_descriptor. */
 260:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_INTERFACE = 0x04,
 261:/usr/include/libusb-1.0/libusb.h **** 
 262:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint descriptor. See libusb_endpoint_descriptor. */
 263:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_ENDPOINT = 0x05,
 264:/usr/include/libusb-1.0/libusb.h **** 
 265:/usr/include/libusb-1.0/libusb.h **** 	/** BOS descriptor */
 266:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_BOS = 0x0f,
 267:/usr/include/libusb-1.0/libusb.h **** 
 268:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability descriptor */
 269:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE_CAPABILITY = 0x10,
 270:/usr/include/libusb-1.0/libusb.h **** 
 271:/usr/include/libusb-1.0/libusb.h **** 	/** HID descriptor */
 272:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HID = 0x21,
 273:/usr/include/libusb-1.0/libusb.h **** 
 274:/usr/include/libusb-1.0/libusb.h **** 	/** HID report descriptor */
 275:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_REPORT = 0x22,
 276:/usr/include/libusb-1.0/libusb.h **** 
 277:/usr/include/libusb-1.0/libusb.h **** 	/** Physical descriptor */
 278:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_PHYSICAL = 0x23,
 279:/usr/include/libusb-1.0/libusb.h **** 
 280:/usr/include/libusb-1.0/libusb.h **** 	/** Hub descriptor */
 281:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HUB = 0x29,
 282:/usr/include/libusb-1.0/libusb.h **** 
 283:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Hub descriptor */
 284:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SUPERSPEED_HUB = 0x2a,
 285:/usr/include/libusb-1.0/libusb.h **** 
 286:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Endpoint Companion descriptor */
 287:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x30
 288:/usr/include/libusb-1.0/libusb.h **** };
 289:/usr/include/libusb-1.0/libusb.h **** 
 290:/usr/include/libusb-1.0/libusb.h **** /* Descriptor sizes per descriptor type */
 291:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_SIZE			18
 292:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_CONFIG_SIZE			9
 293:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_INTERFACE_SIZE		9
 294:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_SIZE			7
 295:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_AUDIO_SIZE		9	/* Audio extension */
 296:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_HUB_NONVAR_SIZE		7
 297:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE	6
 298:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_SIZE			5
 299:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_CAPABILITY_SIZE	3
 300:/usr/include/libusb-1.0/libusb.h **** 
 301:/usr/include/libusb-1.0/libusb.h **** /* BOS descriptor sizes */
 302:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_USB_2_0_EXTENSION_SIZE	7
 303:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE	10
 304:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_CONTAINER_ID_SIZE		20
 305:/usr/include/libusb-1.0/libusb.h **** 
 306:/usr/include/libusb-1.0/libusb.h **** /* We unwrap the BOS => define its max size */
 307:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_MAX_SIZE				\
 308:/usr/include/libusb-1.0/libusb.h **** 	(LIBUSB_DT_BOS_SIZE +				\
 309:/usr/include/libusb-1.0/libusb.h **** 	 LIBUSB_BT_USB_2_0_EXTENSION_SIZE +		\
 310:/usr/include/libusb-1.0/libusb.h **** 	 LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE +	\
 311:/usr/include/libusb-1.0/libusb.h **** 	 LIBUSB_BT_CONTAINER_ID_SIZE)
 312:/usr/include/libusb-1.0/libusb.h **** 
 313:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_ADDRESS_MASK		0x0f	/* in bEndpointAddress */
 314:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_DIR_MASK		0x80
 315:/usr/include/libusb-1.0/libusb.h **** 
 316:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 317:/usr/include/libusb-1.0/libusb.h ****  * Endpoint direction. Values for bit 7 of the
 318:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bEndpointAddress "endpoint address" scheme.
 319:/usr/include/libusb-1.0/libusb.h ****  */
 320:/usr/include/libusb-1.0/libusb.h **** enum libusb_endpoint_direction {
 321:/usr/include/libusb-1.0/libusb.h **** 	/** Out: host-to-device */
 322:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_OUT = 0x00,
 323:/usr/include/libusb-1.0/libusb.h **** 
 324:/usr/include/libusb-1.0/libusb.h **** 	/** In: device-to-host */
 325:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_IN = 0x80
 326:/usr/include/libusb-1.0/libusb.h **** };
 327:/usr/include/libusb-1.0/libusb.h **** 
 328:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_TRANSFER_TYPE_MASK		0x03	/* in bmAttributes */
 329:/usr/include/libusb-1.0/libusb.h **** 
 330:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 331:/usr/include/libusb-1.0/libusb.h ****  * Endpoint transfer type. Values for bits 0:1 of the
 332:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "endpoint attributes" field.
 333:/usr/include/libusb-1.0/libusb.h ****  */
 334:/usr/include/libusb-1.0/libusb.h **** enum libusb_endpoint_transfer_type {
 335:/usr/include/libusb-1.0/libusb.h **** 	/** Control endpoint */
 336:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_TRANSFER_TYPE_CONTROL = 0x0,
 337:/usr/include/libusb-1.0/libusb.h **** 
 338:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous endpoint */
 339:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_TRANSFER_TYPE_ISOCHRONOUS = 0x1,
 340:/usr/include/libusb-1.0/libusb.h **** 
 341:/usr/include/libusb-1.0/libusb.h **** 	/** Bulk endpoint */
 342:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_TRANSFER_TYPE_BULK = 0x2,
 343:/usr/include/libusb-1.0/libusb.h **** 
 344:/usr/include/libusb-1.0/libusb.h **** 	/** Interrupt endpoint */
 345:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_TRANSFER_TYPE_INTERRUPT = 0x3
 346:/usr/include/libusb-1.0/libusb.h **** };
 347:/usr/include/libusb-1.0/libusb.h **** 
 348:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
 349:/usr/include/libusb-1.0/libusb.h ****  * Standard requests, as defined in table 9-5 of the USB 3.0 specifications */
 350:/usr/include/libusb-1.0/libusb.h **** enum libusb_standard_request {
 351:/usr/include/libusb-1.0/libusb.h **** 	/** Request status of the specific recipient */
 352:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_STATUS = 0x00,
 353:/usr/include/libusb-1.0/libusb.h **** 
 354:/usr/include/libusb-1.0/libusb.h **** 	/** Clear or disable a specific feature */
 355:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_CLEAR_FEATURE = 0x01,
 356:/usr/include/libusb-1.0/libusb.h **** 
 357:/usr/include/libusb-1.0/libusb.h **** 	/* 0x02 is reserved */
 358:/usr/include/libusb-1.0/libusb.h **** 
 359:/usr/include/libusb-1.0/libusb.h **** 	/** Set or enable a specific feature */
 360:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_FEATURE = 0x03,
 361:/usr/include/libusb-1.0/libusb.h **** 
 362:/usr/include/libusb-1.0/libusb.h **** 	/* 0x04 is reserved */
 363:/usr/include/libusb-1.0/libusb.h **** 
 364:/usr/include/libusb-1.0/libusb.h **** 	/** Set device address for all future accesses */
 365:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_ADDRESS = 0x05,
 366:/usr/include/libusb-1.0/libusb.h **** 
 367:/usr/include/libusb-1.0/libusb.h **** 	/** Get the specified descriptor */
 368:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_DESCRIPTOR = 0x06,
 369:/usr/include/libusb-1.0/libusb.h **** 
 370:/usr/include/libusb-1.0/libusb.h **** 	/** Used to update existing descriptors or add new descriptors */
 371:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_DESCRIPTOR = 0x07,
 372:/usr/include/libusb-1.0/libusb.h **** 
 373:/usr/include/libusb-1.0/libusb.h **** 	/** Get the current device configuration value */
 374:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_CONFIGURATION = 0x08,
 375:/usr/include/libusb-1.0/libusb.h **** 
 376:/usr/include/libusb-1.0/libusb.h **** 	/** Set device configuration */
 377:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_CONFIGURATION = 0x09,
 378:/usr/include/libusb-1.0/libusb.h **** 
 379:/usr/include/libusb-1.0/libusb.h **** 	/** Return the selected alternate setting for the specified interface */
 380:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_INTERFACE = 0x0a,
 381:/usr/include/libusb-1.0/libusb.h **** 
 382:/usr/include/libusb-1.0/libusb.h **** 	/** Select an alternate interface for the specified interface */
 383:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_INTERFACE = 0x0b,
 384:/usr/include/libusb-1.0/libusb.h **** 
 385:/usr/include/libusb-1.0/libusb.h **** 	/** Set then report an endpoint's synchronization frame */
 386:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SYNCH_FRAME = 0x0c,
 387:/usr/include/libusb-1.0/libusb.h **** 
 388:/usr/include/libusb-1.0/libusb.h **** 	/** Sets both the U1 and U2 Exit Latency */
 389:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_SEL = 0x30,
 390:/usr/include/libusb-1.0/libusb.h **** 
 391:/usr/include/libusb-1.0/libusb.h **** 	/** Delay from the time a host transmits a packet to the time it is
 392:/usr/include/libusb-1.0/libusb.h **** 	  * received by the device. */
 393:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SET_ISOCH_DELAY = 0x31
 394:/usr/include/libusb-1.0/libusb.h **** };
 395:/usr/include/libusb-1.0/libusb.h **** 
 396:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
 397:/usr/include/libusb-1.0/libusb.h ****  * Request type bits of the
 398:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 399:/usr/include/libusb-1.0/libusb.h ****  * transfers. */
 400:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_type {
 401:/usr/include/libusb-1.0/libusb.h **** 	/** Standard */
 402:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_STANDARD = (0x00 << 5),
 403:/usr/include/libusb-1.0/libusb.h **** 
 404:/usr/include/libusb-1.0/libusb.h **** 	/** Class */
 405:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5),
 406:/usr/include/libusb-1.0/libusb.h **** 
 407:/usr/include/libusb-1.0/libusb.h **** 	/** Vendor */
 408:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_VENDOR = (0x02 << 5),
 409:/usr/include/libusb-1.0/libusb.h **** 
 410:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved */
 411:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_RESERVED = (0x03 << 5)
 412:/usr/include/libusb-1.0/libusb.h **** };
 413:/usr/include/libusb-1.0/libusb.h **** 
 414:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
 415:/usr/include/libusb-1.0/libusb.h ****  * Recipient bits of the
 416:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 417:/usr/include/libusb-1.0/libusb.h ****  * transfers. Values 4 through 31 are reserved. */
 418:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_recipient {
 419:/usr/include/libusb-1.0/libusb.h **** 	/** Device */
 420:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_DEVICE = 0x00,
 421:/usr/include/libusb-1.0/libusb.h **** 
 422:/usr/include/libusb-1.0/libusb.h **** 	/** Interface */
 423:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_INTERFACE = 0x01,
 424:/usr/include/libusb-1.0/libusb.h **** 
 425:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint */
 426:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_ENDPOINT = 0x02,
 427:/usr/include/libusb-1.0/libusb.h **** 
 428:/usr/include/libusb-1.0/libusb.h **** 	/** Other */
 429:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_OTHER = 0x03
 430:/usr/include/libusb-1.0/libusb.h **** };
 431:/usr/include/libusb-1.0/libusb.h **** 
 432:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_SYNC_TYPE_MASK	0x0c
 433:/usr/include/libusb-1.0/libusb.h **** 
 434:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 435:/usr/include/libusb-1.0/libusb.h ****  * Synchronization type for isochronous endpoints. Values for bits 2:3 of the
 436:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 437:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 438:/usr/include/libusb-1.0/libusb.h ****  */
 439:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_sync_type {
 440:/usr/include/libusb-1.0/libusb.h **** 	/** No synchronization */
 441:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_NONE = 0x0,
 442:/usr/include/libusb-1.0/libusb.h **** 
 443:/usr/include/libusb-1.0/libusb.h **** 	/** Asynchronous */
 444:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ASYNC = 0x1,
 445:/usr/include/libusb-1.0/libusb.h **** 
 446:/usr/include/libusb-1.0/libusb.h **** 	/** Adaptive */
 447:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 0x2,
 448:/usr/include/libusb-1.0/libusb.h **** 
 449:/usr/include/libusb-1.0/libusb.h **** 	/** Synchronous */
 450:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_SYNC = 0x3
 451:/usr/include/libusb-1.0/libusb.h **** };
 452:/usr/include/libusb-1.0/libusb.h **** 
 453:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_USAGE_TYPE_MASK	0x30
 454:/usr/include/libusb-1.0/libusb.h **** 
 455:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 456:/usr/include/libusb-1.0/libusb.h ****  * Usage type for isochronous endpoints. Values for bits 4:5 of the
 457:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 458:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 459:/usr/include/libusb-1.0/libusb.h ****  */
 460:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_usage_type {
 461:/usr/include/libusb-1.0/libusb.h **** 	/** Data endpoint */
 462:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_DATA = 0x0,
 463:/usr/include/libusb-1.0/libusb.h **** 
 464:/usr/include/libusb-1.0/libusb.h **** 	/** Feedback endpoint */
 465:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 0x1,
 466:/usr/include/libusb-1.0/libusb.h **** 
 467:/usr/include/libusb-1.0/libusb.h **** 	/** Implicit feedback Data endpoint */
 468:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 0x2
 469:/usr/include/libusb-1.0/libusb.h **** };
 470:/usr/include/libusb-1.0/libusb.h **** 
 471:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 472:/usr/include/libusb-1.0/libusb.h ****  * Supported speeds (wSpeedSupported) bitfield. Indicates what
 473:/usr/include/libusb-1.0/libusb.h ****  * speeds the device supports.
 474:/usr/include/libusb-1.0/libusb.h ****  */
 475:/usr/include/libusb-1.0/libusb.h **** enum libusb_supported_speed {
 476:/usr/include/libusb-1.0/libusb.h **** 	/** Low speed operation supported (1.5MBit/s). */
 477:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOW_SPEED_OPERATION = (1 << 0),
 478:/usr/include/libusb-1.0/libusb.h **** 
 479:/usr/include/libusb-1.0/libusb.h **** 	/** Full speed operation supported (12MBit/s). */
 480:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_FULL_SPEED_OPERATION = (1 << 1),
 481:/usr/include/libusb-1.0/libusb.h **** 
 482:/usr/include/libusb-1.0/libusb.h **** 	/** High speed operation supported (480MBit/s). */
 483:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_HIGH_SPEED_OPERATION = (1 << 2),
 484:/usr/include/libusb-1.0/libusb.h **** 
 485:/usr/include/libusb-1.0/libusb.h **** 	/** Superspeed operation supported (5000MBit/s). */
 486:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUPER_SPEED_OPERATION = (1 << 3)
 487:/usr/include/libusb-1.0/libusb.h **** };
 488:/usr/include/libusb-1.0/libusb.h **** 
 489:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 490:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
 491:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_usb_2_0_extension_descriptor::bmAttributes "bmAttributes" field
 492:/usr/include/libusb-1.0/libusb.h ****  * of the USB 2.0 Extension descriptor.
 493:/usr/include/libusb-1.0/libusb.h ****  */
 494:/usr/include/libusb-1.0/libusb.h **** enum libusb_usb_2_0_extension_attributes {
 495:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Link Power Management (LPM) */
 496:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LPM_SUPPORT = (1 << 1)
 497:/usr/include/libusb-1.0/libusb.h **** };
 498:/usr/include/libusb-1.0/libusb.h **** 
 499:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 500:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
 501:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_ss_usb_device_capability_descriptor::bmAttributes "bmAttributes" field
 502:/usr/include/libusb-1.0/libusb.h ****  * field of the SuperSpeed USB Device Capability descriptor.
 503:/usr/include/libusb-1.0/libusb.h ****  */
 504:/usr/include/libusb-1.0/libusb.h **** enum libusb_ss_usb_device_capability_attributes {
 505:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Latency Tolerance Messages (LTM) */
 506:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LTM_SUPPORT = (1 << 1)
 507:/usr/include/libusb-1.0/libusb.h **** };
 508:/usr/include/libusb-1.0/libusb.h **** 
 509:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 510:/usr/include/libusb-1.0/libusb.h ****  * USB capability types
 511:/usr/include/libusb-1.0/libusb.h ****  */
 512:/usr/include/libusb-1.0/libusb.h **** enum libusb_bos_type {
 513:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless USB device capability */
 514:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY = 0x01,
 515:/usr/include/libusb-1.0/libusb.h **** 
 516:/usr/include/libusb-1.0/libusb.h **** 	/** USB 2.0 extensions */
 517:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_USB_2_0_EXTENSION = 0x02,
 518:/usr/include/libusb-1.0/libusb.h **** 
 519:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed USB device capability */
 520:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_SS_USB_DEVICE_CAPABILITY = 0x03,
 521:/usr/include/libusb-1.0/libusb.h **** 
 522:/usr/include/libusb-1.0/libusb.h **** 	/** Container ID type */
 523:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_CONTAINER_ID = 0x04
 524:/usr/include/libusb-1.0/libusb.h **** };
 525:/usr/include/libusb-1.0/libusb.h **** 
 526:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 527:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB device descriptor. This
 528:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.1 of the USB 3.0 specification.
 529:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 530:/usr/include/libusb-1.0/libusb.h ****  */
 531:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_descriptor {
 532:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 533:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 534:/usr/include/libusb-1.0/libusb.h **** 
 535:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 536:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this
 537:/usr/include/libusb-1.0/libusb.h **** 	 * context. */
 538:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 539:/usr/include/libusb-1.0/libusb.h **** 
 540:/usr/include/libusb-1.0/libusb.h **** 	/** USB specification release number in binary-coded decimal. A value of
 541:/usr/include/libusb-1.0/libusb.h **** 	 * 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc. */
 542:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdUSB;
 543:/usr/include/libusb-1.0/libusb.h **** 
 544:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for the device. See \ref libusb_class_code. */
 545:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceClass;
 546:/usr/include/libusb-1.0/libusb.h **** 
 547:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for the device, qualified by the bDeviceClass
 548:/usr/include/libusb-1.0/libusb.h **** 	 * value */
 549:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceSubClass;
 550:/usr/include/libusb-1.0/libusb.h **** 
 551:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for the device, qualified by the bDeviceClass and
 552:/usr/include/libusb-1.0/libusb.h **** 	 * bDeviceSubClass values */
 553:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceProtocol;
 554:/usr/include/libusb-1.0/libusb.h **** 
 555:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size for endpoint 0 */
 556:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxPacketSize0;
 557:/usr/include/libusb-1.0/libusb.h **** 
 558:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF vendor ID */
 559:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idVendor;
 560:/usr/include/libusb-1.0/libusb.h **** 
 561:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF product ID */
 562:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idProduct;
 563:/usr/include/libusb-1.0/libusb.h **** 
 564:/usr/include/libusb-1.0/libusb.h **** 	/** Device release number in binary-coded decimal */
 565:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdDevice;
 566:/usr/include/libusb-1.0/libusb.h **** 
 567:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing manufacturer */
 568:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iManufacturer;
 569:/usr/include/libusb-1.0/libusb.h **** 
 570:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing product */
 571:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iProduct;
 572:/usr/include/libusb-1.0/libusb.h **** 
 573:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor containing device serial number */
 574:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iSerialNumber;
 575:/usr/include/libusb-1.0/libusb.h **** 
 576:/usr/include/libusb-1.0/libusb.h **** 	/** Number of possible configurations */
 577:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumConfigurations;
 578:/usr/include/libusb-1.0/libusb.h **** };
 579:/usr/include/libusb-1.0/libusb.h **** 
 580:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 581:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB endpoint descriptor. This
 582:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.6 of the USB 3.0 specification.
 583:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 584:/usr/include/libusb-1.0/libusb.h ****  */
 585:/usr/include/libusb-1.0/libusb.h **** struct libusb_endpoint_descriptor {
 586:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 587:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 588:/usr/include/libusb-1.0/libusb.h **** 
 589:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 590:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in
 591:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 592:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 593:/usr/include/libusb-1.0/libusb.h **** 
 594:/usr/include/libusb-1.0/libusb.h **** 	/** The address of the endpoint described by this descriptor. Bits 0:3 are
 595:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,
 596:/usr/include/libusb-1.0/libusb.h **** 	 * see \ref libusb_endpoint_direction. */
 597:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bEndpointAddress;
 598:/usr/include/libusb-1.0/libusb.h **** 
 599:/usr/include/libusb-1.0/libusb.h **** 	/** Attributes which apply to the endpoint when it is configured using
 600:/usr/include/libusb-1.0/libusb.h **** 	 * the bConfigurationValue. Bits 0:1 determine the transfer type and
 601:/usr/include/libusb-1.0/libusb.h **** 	 * correspond to \ref libusb_endpoint_transfer_type. Bits 2:3 are only used
 602:/usr/include/libusb-1.0/libusb.h **** 	 * for isochronous endpoints and correspond to \ref libusb_iso_sync_type.
 603:/usr/include/libusb-1.0/libusb.h **** 	 * Bits 4:5 are also only used for isochronous endpoints and correspond to
 604:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_usage_type. Bits 6:7 are reserved. */
 605:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 606:/usr/include/libusb-1.0/libusb.h **** 
 607:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size this endpoint is capable of sending/receiving. */
 608:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wMaxPacketSize;
 609:/usr/include/libusb-1.0/libusb.h **** 
 610:/usr/include/libusb-1.0/libusb.h **** 	/** Interval for polling endpoint for data transfers. */
 611:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterval;
 612:/usr/include/libusb-1.0/libusb.h **** 
 613:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the rate at which synchronization feedback
 614:/usr/include/libusb-1.0/libusb.h **** 	 * is provided. */
 615:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRefresh;
 616:/usr/include/libusb-1.0/libusb.h **** 
 617:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the address if the synch endpoint */
 618:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bSynchAddress;
 619:/usr/include/libusb-1.0/libusb.h **** 
 620:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown endpoint descriptors,
 621:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 622:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 623:/usr/include/libusb-1.0/libusb.h **** 
 624:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. Must be non-negative. */
 625:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 626:/usr/include/libusb-1.0/libusb.h **** };
 627:/usr/include/libusb-1.0/libusb.h **** 
 628:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 629:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB interface descriptor. This
 630:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.5 of the USB 3.0 specification.
 631:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 632:/usr/include/libusb-1.0/libusb.h ****  */
 633:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface_descriptor {
 634:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 635:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 636:/usr/include/libusb-1.0/libusb.h **** 
 637:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 638:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE
 639:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 640:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 641:/usr/include/libusb-1.0/libusb.h **** 
 642:/usr/include/libusb-1.0/libusb.h **** 	/** Number of this interface */
 643:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceNumber;
 644:/usr/include/libusb-1.0/libusb.h **** 
 645:/usr/include/libusb-1.0/libusb.h **** 	/** Value used to select this alternate setting for this interface */
 646:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bAlternateSetting;
 647:/usr/include/libusb-1.0/libusb.h **** 
 648:/usr/include/libusb-1.0/libusb.h **** 	/** Number of endpoints used by this interface (excluding the control
 649:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint). */
 650:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumEndpoints;
 651:/usr/include/libusb-1.0/libusb.h **** 
 652:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for this interface. See \ref libusb_class_code. */
 653:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceClass;
 654:/usr/include/libusb-1.0/libusb.h **** 
 655:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for this interface, qualified by the
 656:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass value */
 657:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceSubClass;
 658:/usr/include/libusb-1.0/libusb.h **** 
 659:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for this interface, qualified by the
 660:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass and bInterfaceSubClass values */
 661:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceProtocol;
 662:/usr/include/libusb-1.0/libusb.h **** 
 663:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this interface */
 664:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iInterface;
 665:/usr/include/libusb-1.0/libusb.h **** 
 666:/usr/include/libusb-1.0/libusb.h **** 	/** Array of endpoint descriptors. This length of this array is determined
 667:/usr/include/libusb-1.0/libusb.h **** 	 * by the bNumEndpoints field. */
 668:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint;
 669:/usr/include/libusb-1.0/libusb.h **** 
 670:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown interface descriptors,
 671:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 672:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 673:/usr/include/libusb-1.0/libusb.h **** 
 674:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. Must be non-negative. */
 675:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 676:/usr/include/libusb-1.0/libusb.h **** };
 677:/usr/include/libusb-1.0/libusb.h **** 
 678:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 679:/usr/include/libusb-1.0/libusb.h ****  * A collection of alternate settings for a particular USB interface.
 680:/usr/include/libusb-1.0/libusb.h ****  */
 681:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface {
 682:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interface descriptors. The length of this array is determined
 683:/usr/include/libusb-1.0/libusb.h **** 	 * by the num_altsetting field. */
 684:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface_descriptor *altsetting;
 685:/usr/include/libusb-1.0/libusb.h **** 
 686:/usr/include/libusb-1.0/libusb.h **** 	/** The number of alternate settings that belong to this interface.
 687:/usr/include/libusb-1.0/libusb.h **** 	 * Must be non-negative. */
 688:/usr/include/libusb-1.0/libusb.h **** 	int num_altsetting;
 689:/usr/include/libusb-1.0/libusb.h **** };
 690:/usr/include/libusb-1.0/libusb.h **** 
 691:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 692:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB configuration descriptor. This
 693:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.3 of the USB 3.0 specification.
 694:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 695:/usr/include/libusb-1.0/libusb.h ****  */
 696:/usr/include/libusb-1.0/libusb.h **** struct libusb_config_descriptor {
 697:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 698:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 699:/usr/include/libusb-1.0/libusb.h **** 
 700:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 701:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG
 702:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 703:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 704:/usr/include/libusb-1.0/libusb.h **** 
 705:/usr/include/libusb-1.0/libusb.h **** 	/** Total length of data returned for this configuration */
 706:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 707:/usr/include/libusb-1.0/libusb.h **** 
 708:/usr/include/libusb-1.0/libusb.h **** 	/** Number of interfaces supported by this configuration */
 709:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumInterfaces;
 710:/usr/include/libusb-1.0/libusb.h **** 
 711:/usr/include/libusb-1.0/libusb.h **** 	/** Identifier value for this configuration */
 712:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bConfigurationValue;
 713:/usr/include/libusb-1.0/libusb.h **** 
 714:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this configuration */
 715:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iConfiguration;
 716:/usr/include/libusb-1.0/libusb.h **** 
 717:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration characteristics */
 718:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 719:/usr/include/libusb-1.0/libusb.h **** 
 720:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum power consumption of the USB device from this bus in this
 721:/usr/include/libusb-1.0/libusb.h **** 	 * configuration when the device is fully operation. Expressed in units
 722:/usr/include/libusb-1.0/libusb.h **** 	 * of 2 mA when the device is operating in high-speed mode and in units
 723:/usr/include/libusb-1.0/libusb.h **** 	 * of 8 mA when the device is operating in super-speed mode. */
 724:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  MaxPower;
 725:/usr/include/libusb-1.0/libusb.h **** 
 726:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interfaces supported by this configuration. The length of
 727:/usr/include/libusb-1.0/libusb.h **** 	 * this array is determined by the bNumInterfaces field. */
 728:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface *interface;
 729:/usr/include/libusb-1.0/libusb.h **** 
 730:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown configuration
 731:/usr/include/libusb-1.0/libusb.h **** 	 * descriptors, it will store them here, should you wish to parse them. */
 732:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 733:/usr/include/libusb-1.0/libusb.h **** 
 734:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. Must be non-negative. */
 735:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 736:/usr/include/libusb-1.0/libusb.h **** };
 737:/usr/include/libusb-1.0/libusb.h **** 
 738:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 739:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the superspeed endpoint companion
 740:/usr/include/libusb-1.0/libusb.h ****  * descriptor. This descriptor is documented in section 9.6.7 of
 741:/usr/include/libusb-1.0/libusb.h ****  * the USB 3.0 specification. All multiple-byte fields are represented in
 742:/usr/include/libusb-1.0/libusb.h ****  * host-endian format.
 743:/usr/include/libusb-1.0/libusb.h ****  */
 744:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_endpoint_companion_descriptor {
 745:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 746:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 747:/usr/include/libusb-1.0/libusb.h **** 
 748:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 749:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in
 750:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 751:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 752:/usr/include/libusb-1.0/libusb.h **** 
 753:/usr/include/libusb-1.0/libusb.h **** 	/** The maximum number of packets the endpoint can send or
 754:/usr/include/libusb-1.0/libusb.h **** 	 *  receive as part of a burst. */
 755:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxBurst;
 756:/usr/include/libusb-1.0/libusb.h **** 
 757:/usr/include/libusb-1.0/libusb.h **** 	/** In bulk EP: bits 4:0 represents the maximum number of
 758:/usr/include/libusb-1.0/libusb.h **** 	 *  streams the EP supports. In isochronous EP: bits 1:0
 759:/usr/include/libusb-1.0/libusb.h **** 	 *  represents the Mult - a zero based value that determines
 760:/usr/include/libusb-1.0/libusb.h **** 	 *  the maximum number of packets within a service interval  */
 761:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 762:/usr/include/libusb-1.0/libusb.h **** 
 763:/usr/include/libusb-1.0/libusb.h **** 	/** The total number of bytes this EP will transfer every
 764:/usr/include/libusb-1.0/libusb.h **** 	 *  service interval. Valid only for periodic EPs. */
 765:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wBytesPerInterval;
 766:/usr/include/libusb-1.0/libusb.h **** };
 767:/usr/include/libusb-1.0/libusb.h **** 
 768:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 769:/usr/include/libusb-1.0/libusb.h ****  * A generic representation of a BOS Device Capability descriptor. It is
 770:/usr/include/libusb-1.0/libusb.h ****  * advised to check bDevCapabilityType and call the matching
 771:/usr/include/libusb-1.0/libusb.h ****  * libusb_get_*_descriptor function to get a structure fully matching the type.
 772:/usr/include/libusb-1.0/libusb.h ****  */
 773:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_dev_capability_descriptor {
 774:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 775:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 776:/usr/include/libusb-1.0/libusb.h **** 
 777:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 778:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 779:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 780:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 781:/usr/include/libusb-1.0/libusb.h **** 
 782:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability type */
 783:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 784:/usr/include/libusb-1.0/libusb.h **** 
 785:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability data (bLength - 3 bytes) */
 786:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  dev_capability_data[ZERO_SIZED_ARRAY];
 787:/usr/include/libusb-1.0/libusb.h **** };
 788:/usr/include/libusb-1.0/libusb.h **** 
 789:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 790:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Binary Device Object Store (BOS) descriptor.
 791:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2 of the USB 3.0 specification.
 792:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 793:/usr/include/libusb-1.0/libusb.h ****  */
 794:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_descriptor {
 795:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 796:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 797:/usr/include/libusb-1.0/libusb.h **** 
 798:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 799:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS
 800:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 801:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 802:/usr/include/libusb-1.0/libusb.h **** 
 803:/usr/include/libusb-1.0/libusb.h **** 	/** Length of this descriptor and all of its sub descriptors */
 804:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 805:/usr/include/libusb-1.0/libusb.h **** 
 806:/usr/include/libusb-1.0/libusb.h **** 	/** The number of separate device capability descriptors in
 807:/usr/include/libusb-1.0/libusb.h **** 	 * the BOS */
 808:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumDeviceCaps;
 809:/usr/include/libusb-1.0/libusb.h **** 
 810:/usr/include/libusb-1.0/libusb.h **** 	/** bNumDeviceCap Device Capability Descriptors */
 811:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_capability[ZERO_SIZED_ARRAY];
 812:/usr/include/libusb-1.0/libusb.h **** };
 813:/usr/include/libusb-1.0/libusb.h **** 
 814:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 815:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the USB 2.0 Extension descriptor
 816:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification.
 817:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 818:/usr/include/libusb-1.0/libusb.h ****  */
 819:/usr/include/libusb-1.0/libusb.h **** struct libusb_usb_2_0_extension_descriptor {
 820:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 821:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 822:/usr/include/libusb-1.0/libusb.h **** 
 823:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 824:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 825:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 826:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 827:/usr/include/libusb-1.0/libusb.h **** 
 828:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 829:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION
 830:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_USB_2_0_EXTENSION in this context. */
 831:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 832:/usr/include/libusb-1.0/libusb.h **** 
 833:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 834:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 835:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 836:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_usb_2_0_extension_attributes. */
 837:/usr/include/libusb-1.0/libusb.h **** 	uint32_t bmAttributes;
 838:/usr/include/libusb-1.0/libusb.h **** };
 839:/usr/include/libusb-1.0/libusb.h **** 
 840:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 841:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the SuperSpeed USB Device Capability descriptor
 842:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification.
 843:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 844:/usr/include/libusb-1.0/libusb.h ****  */
 845:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_usb_device_capability_descriptor {
 846:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 847:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 848:/usr/include/libusb-1.0/libusb.h **** 
 849:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 850:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 851:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 852:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 853:/usr/include/libusb-1.0/libusb.h **** 
 854:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 855:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
 856:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context. */
 857:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 858:/usr/include/libusb-1.0/libusb.h **** 
 859:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 860:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 861:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 862:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_ss_usb_device_capability_attributes. */
 863:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 864:/usr/include/libusb-1.0/libusb.h **** 
 865:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of the speed supported by this device when
 866:/usr/include/libusb-1.0/libusb.h **** 	 * operating in SuperSpeed mode. See \ref libusb_supported_speed. */
 867:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wSpeedSupported;
 868:/usr/include/libusb-1.0/libusb.h **** 
 869:/usr/include/libusb-1.0/libusb.h **** 	/** The lowest speed at which all the functionality supported
 870:/usr/include/libusb-1.0/libusb.h **** 	 * by the device is available to the user. For example if the
 871:/usr/include/libusb-1.0/libusb.h **** 	 * device supports all its functionality when connected at
 872:/usr/include/libusb-1.0/libusb.h **** 	 * full speed and above then it sets this value to 1. */
 873:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bFunctionalitySupport;
 874:/usr/include/libusb-1.0/libusb.h **** 
 875:/usr/include/libusb-1.0/libusb.h **** 	/** U1 Device Exit Latency. */
 876:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bU1DevExitLat;
 877:/usr/include/libusb-1.0/libusb.h **** 
 878:/usr/include/libusb-1.0/libusb.h **** 	/** U2 Device Exit Latency. */
 879:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bU2DevExitLat;
 880:/usr/include/libusb-1.0/libusb.h **** };
 881:/usr/include/libusb-1.0/libusb.h **** 
 882:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 883:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Container ID descriptor.
 884:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification.
 885:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields, except UUIDs, are represented in host-endian format.
 886:/usr/include/libusb-1.0/libusb.h ****  */
 887:/usr/include/libusb-1.0/libusb.h **** struct libusb_container_id_descriptor {
 888:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 889:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 890:/usr/include/libusb-1.0/libusb.h **** 
 891:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 892:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 893:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 894:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 895:/usr/include/libusb-1.0/libusb.h **** 
 896:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 897:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID
 898:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_CONTAINER_ID in this context. */
 899:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 900:/usr/include/libusb-1.0/libusb.h **** 
 901:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved field */
 902:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bReserved;
 903:/usr/include/libusb-1.0/libusb.h **** 
 904:/usr/include/libusb-1.0/libusb.h **** 	/** 128 bit UUID */
 905:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  ContainerID[16];
 906:/usr/include/libusb-1.0/libusb.h **** };
 907:/usr/include/libusb-1.0/libusb.h **** 
 908:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
 909:/usr/include/libusb-1.0/libusb.h ****  * Setup packet for control transfers. */
 910:/usr/include/libusb-1.0/libusb.h **** #if defined(_MSC_VER) || defined(__WATCOMC__)
 911:/usr/include/libusb-1.0/libusb.h **** #pragma pack(push, 1)
 912:/usr/include/libusb-1.0/libusb.h **** #endif
 913:/usr/include/libusb-1.0/libusb.h **** struct libusb_control_setup {
 914:/usr/include/libusb-1.0/libusb.h **** 	/** Request type. Bits 0:4 determine recipient, see
 915:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_recipient. Bits 5:6 determine type, see
 916:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type. Bit 7 determines data transfer direction, see
 917:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_endpoint_direction.
 918:/usr/include/libusb-1.0/libusb.h **** 	 */
 919:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmRequestType;
 920:/usr/include/libusb-1.0/libusb.h **** 
 921:/usr/include/libusb-1.0/libusb.h **** 	/** Request. If the type bits of bmRequestType are equal to
 922:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
 923:/usr/include/libusb-1.0/libusb.h **** 	 * "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
 924:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_standard_request. For other cases, use of this field is
 925:/usr/include/libusb-1.0/libusb.h **** 	 * application-specific. */
 926:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRequest;
 927:/usr/include/libusb-1.0/libusb.h **** 
 928:/usr/include/libusb-1.0/libusb.h **** 	/** Value. Varies according to request */
 929:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wValue;
 930:/usr/include/libusb-1.0/libusb.h **** 
 931:/usr/include/libusb-1.0/libusb.h **** 	/** Index. Varies according to request, typically used to pass an index
 932:/usr/include/libusb-1.0/libusb.h **** 	 * or offset */
 933:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wIndex;
 934:/usr/include/libusb-1.0/libusb.h **** 
 935:/usr/include/libusb-1.0/libusb.h **** 	/** Number of bytes to transfer */
 936:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength;
 937:/usr/include/libusb-1.0/libusb.h **** } LIBUSB_PACKED;
 938:/usr/include/libusb-1.0/libusb.h **** #if defined(_MSC_VER) || defined(__WATCOMC__)
 939:/usr/include/libusb-1.0/libusb.h **** #pragma pack(pop)
 940:/usr/include/libusb-1.0/libusb.h **** #endif
 941:/usr/include/libusb-1.0/libusb.h **** 
 942:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CONTROL_SETUP_SIZE (sizeof(struct libusb_control_setup))
 943:/usr/include/libusb-1.0/libusb.h **** 
 944:/usr/include/libusb-1.0/libusb.h **** /* libusb */
 945:/usr/include/libusb-1.0/libusb.h **** 
 946:/usr/include/libusb-1.0/libusb.h **** struct libusb_context;
 947:/usr/include/libusb-1.0/libusb.h **** struct libusb_device;
 948:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_handle;
 949:/usr/include/libusb-1.0/libusb.h **** 
 950:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
 951:/usr/include/libusb-1.0/libusb.h ****  * Structure providing the version of the libusb runtime
 952:/usr/include/libusb-1.0/libusb.h ****  */
 953:/usr/include/libusb-1.0/libusb.h **** struct libusb_version {
 954:/usr/include/libusb-1.0/libusb.h **** 	/** Library major version. */
 955:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t major;
 956:/usr/include/libusb-1.0/libusb.h **** 
 957:/usr/include/libusb-1.0/libusb.h **** 	/** Library minor version. */
 958:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t minor;
 959:/usr/include/libusb-1.0/libusb.h **** 
 960:/usr/include/libusb-1.0/libusb.h **** 	/** Library micro version. */
 961:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t micro;
 962:/usr/include/libusb-1.0/libusb.h **** 
 963:/usr/include/libusb-1.0/libusb.h **** 	/** Library nano version. */
 964:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t nano;
 965:/usr/include/libusb-1.0/libusb.h **** 
 966:/usr/include/libusb-1.0/libusb.h **** 	/** Library release candidate suffix string, e.g. "-rc4". */
 967:/usr/include/libusb-1.0/libusb.h **** 	const char *rc;
 968:/usr/include/libusb-1.0/libusb.h **** 
 969:/usr/include/libusb-1.0/libusb.h **** 	/** For ABI compatibility only. */
 970:/usr/include/libusb-1.0/libusb.h **** 	const char *describe;
 971:/usr/include/libusb-1.0/libusb.h **** };
 972:/usr/include/libusb-1.0/libusb.h **** 
 973:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
 974:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a libusb session. The concept of individual libusb
 975:/usr/include/libusb-1.0/libusb.h ****  * sessions allows for your program to use two libraries (or dynamically
 976:/usr/include/libusb-1.0/libusb.h ****  * load two modules) which both independently use libusb. This will prevent
 977:/usr/include/libusb-1.0/libusb.h ****  * interference between the individual libusb users - for example
 978:/usr/include/libusb-1.0/libusb.h ****  * libusb_set_option() will not affect the other user of the library, and
 979:/usr/include/libusb-1.0/libusb.h ****  * libusb_exit() will not destroy resources that the other user is still
 980:/usr/include/libusb-1.0/libusb.h ****  * using.
 981:/usr/include/libusb-1.0/libusb.h ****  *
 982:/usr/include/libusb-1.0/libusb.h ****  * Sessions are created by libusb_init() and destroyed through libusb_exit().
 983:/usr/include/libusb-1.0/libusb.h ****  * If your application is guaranteed to only ever include a single libusb
 984:/usr/include/libusb-1.0/libusb.h ****  * user (i.e. you), you do not have to worry about contexts: pass NULL in
 985:/usr/include/libusb-1.0/libusb.h ****  * every function call where a context is required, and the default context
 986:/usr/include/libusb-1.0/libusb.h ****  * will be used. Note that libusb_set_option(NULL, ...) is special, and adds
 987:/usr/include/libusb-1.0/libusb.h ****  * an option to a list of default options for new contexts.
 988:/usr/include/libusb-1.0/libusb.h ****  *
 989:/usr/include/libusb-1.0/libusb.h ****  * For more information, see \ref libusb_contexts.
 990:/usr/include/libusb-1.0/libusb.h ****  */
 991:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_context libusb_context;
 992:/usr/include/libusb-1.0/libusb.h **** 
 993:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
 994:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a USB device detected on the system. This is an
 995:/usr/include/libusb-1.0/libusb.h ****  * opaque type for which you are only ever provided with a pointer, usually
 996:/usr/include/libusb-1.0/libusb.h ****  * originating from libusb_get_device_list() or libusb_hotplug_register_callback().
 997:/usr/include/libusb-1.0/libusb.h ****  *
 998:/usr/include/libusb-1.0/libusb.h ****  * Certain operations can be performed on a device, but in order to do any
 999:/usr/include/libusb-1.0/libusb.h ****  * I/O you will have to first obtain a device handle using libusb_open().
1000:/usr/include/libusb-1.0/libusb.h ****  *
1001:/usr/include/libusb-1.0/libusb.h ****  * Devices are reference counted with libusb_ref_device() and
1002:/usr/include/libusb-1.0/libusb.h ****  * libusb_unref_device(), and are freed when the reference count reaches 0.
1003:/usr/include/libusb-1.0/libusb.h ****  * New devices presented by libusb_get_device_list() have a reference count of
1004:/usr/include/libusb-1.0/libusb.h ****  * 1, and libusb_free_device_list() can optionally decrease the reference count
1005:/usr/include/libusb-1.0/libusb.h ****  * on all devices in the list. libusb_open() adds another reference which is
1006:/usr/include/libusb-1.0/libusb.h ****  * later destroyed by libusb_close().
1007:/usr/include/libusb-1.0/libusb.h ****  */
1008:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device libusb_device;
1009:/usr/include/libusb-1.0/libusb.h **** 
1010:/usr/include/libusb-1.0/libusb.h **** 
1011:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
1012:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a handle on a USB device. This is an opaque type for
1013:/usr/include/libusb-1.0/libusb.h ****  * which you are only ever provided with a pointer, usually originating from
1014:/usr/include/libusb-1.0/libusb.h ****  * libusb_open().
1015:/usr/include/libusb-1.0/libusb.h ****  *
1016:/usr/include/libusb-1.0/libusb.h ****  * A device handle is used to perform I/O and other operations. When finished
1017:/usr/include/libusb-1.0/libusb.h ****  * with a device handle, you should call libusb_close().
1018:/usr/include/libusb-1.0/libusb.h ****  */
1019:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device_handle libusb_device_handle;
1020:/usr/include/libusb-1.0/libusb.h **** 
1021:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
1022:/usr/include/libusb-1.0/libusb.h ****  * Speed codes. Indicates the speed at which the device is operating.
1023:/usr/include/libusb-1.0/libusb.h ****  */
1024:/usr/include/libusb-1.0/libusb.h **** enum libusb_speed {
1025:/usr/include/libusb-1.0/libusb.h **** 	/** The OS doesn't report or know the device speed. */
1026:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_UNKNOWN = 0,
1027:/usr/include/libusb-1.0/libusb.h **** 
1028:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at low speed (1.5MBit/s). */
1029:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_LOW = 1,
1030:/usr/include/libusb-1.0/libusb.h **** 
1031:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at full speed (12MBit/s). */
1032:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_FULL = 2,
1033:/usr/include/libusb-1.0/libusb.h **** 
1034:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at high speed (480MBit/s). */
1035:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_HIGH = 3,
1036:/usr/include/libusb-1.0/libusb.h **** 
1037:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at super speed (5000MBit/s). */
1038:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_SUPER = 4,
1039:/usr/include/libusb-1.0/libusb.h **** 
1040:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at super speed plus (10000MBit/s). */
1041:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_SUPER_PLUS = 5
1042:/usr/include/libusb-1.0/libusb.h **** };
1043:/usr/include/libusb-1.0/libusb.h **** 
1044:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
1045:/usr/include/libusb-1.0/libusb.h ****  * Error codes. Most libusb functions return 0 on success or one of these
1046:/usr/include/libusb-1.0/libusb.h ****  * codes on failure.
1047:/usr/include/libusb-1.0/libusb.h ****  * You can call libusb_error_name() to retrieve a string representation of an
1048:/usr/include/libusb-1.0/libusb.h ****  * error code or libusb_strerror() to get an end-user suitable description of
1049:/usr/include/libusb-1.0/libusb.h ****  * an error code.
1050:/usr/include/libusb-1.0/libusb.h ****  */
1051:/usr/include/libusb-1.0/libusb.h **** enum libusb_error {
1052:/usr/include/libusb-1.0/libusb.h **** 	/** Success (no error) */
1053:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUCCESS = 0,
1054:/usr/include/libusb-1.0/libusb.h **** 
1055:/usr/include/libusb-1.0/libusb.h **** 	/** Input/output error */
1056:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_IO = -1,
1057:/usr/include/libusb-1.0/libusb.h **** 
1058:/usr/include/libusb-1.0/libusb.h **** 	/** Invalid parameter */
1059:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INVALID_PARAM = -2,
1060:/usr/include/libusb-1.0/libusb.h **** 
1061:/usr/include/libusb-1.0/libusb.h **** 	/** Access denied (insufficient permissions) */
1062:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_ACCESS = -3,
1063:/usr/include/libusb-1.0/libusb.h **** 
1064:/usr/include/libusb-1.0/libusb.h **** 	/** No such device (it may have been disconnected) */
1065:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_DEVICE = -4,
1066:/usr/include/libusb-1.0/libusb.h **** 
1067:/usr/include/libusb-1.0/libusb.h **** 	/** Entity not found */
1068:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_FOUND = -5,
1069:/usr/include/libusb-1.0/libusb.h **** 
1070:/usr/include/libusb-1.0/libusb.h **** 	/** Resource busy */
1071:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_BUSY = -6,
1072:/usr/include/libusb-1.0/libusb.h **** 
1073:/usr/include/libusb-1.0/libusb.h **** 	/** Operation timed out */
1074:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_TIMEOUT = -7,
1075:/usr/include/libusb-1.0/libusb.h **** 
1076:/usr/include/libusb-1.0/libusb.h **** 	/** Overflow */
1077:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OVERFLOW = -8,
1078:/usr/include/libusb-1.0/libusb.h **** 
1079:/usr/include/libusb-1.0/libusb.h **** 	/** Pipe error */
1080:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_PIPE = -9,
1081:/usr/include/libusb-1.0/libusb.h **** 
1082:/usr/include/libusb-1.0/libusb.h **** 	/** System call interrupted (perhaps due to signal) */
1083:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INTERRUPTED = -10,
1084:/usr/include/libusb-1.0/libusb.h **** 
1085:/usr/include/libusb-1.0/libusb.h **** 	/** Insufficient memory */
1086:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_MEM = -11,
1087:/usr/include/libusb-1.0/libusb.h **** 
1088:/usr/include/libusb-1.0/libusb.h **** 	/** Operation not supported or unimplemented on this platform */
1089:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_SUPPORTED = -12,
1090:/usr/include/libusb-1.0/libusb.h **** 
1091:/usr/include/libusb-1.0/libusb.h **** 	/* NB: Remember to update LIBUSB_ERROR_COUNT below as well as the
1092:/usr/include/libusb-1.0/libusb.h **** 	   message strings in strerror.c when adding new error codes here. */
1093:/usr/include/libusb-1.0/libusb.h **** 
1094:/usr/include/libusb-1.0/libusb.h **** 	/** Other error */
1095:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OTHER = -99
1096:/usr/include/libusb-1.0/libusb.h **** };
1097:/usr/include/libusb-1.0/libusb.h **** 
1098:/usr/include/libusb-1.0/libusb.h **** /* Total number of error codes in enum libusb_error */
1099:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ERROR_COUNT 14
1100:/usr/include/libusb-1.0/libusb.h **** 
1101:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1102:/usr/include/libusb-1.0/libusb.h ****  * Transfer type */
1103:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_type {
1104:/usr/include/libusb-1.0/libusb.h **** 	/** Control transfer */
1105:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_CONTROL = 0U,
1106:/usr/include/libusb-1.0/libusb.h **** 
1107:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous transfer */
1108:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1U,
1109:/usr/include/libusb-1.0/libusb.h **** 
1110:/usr/include/libusb-1.0/libusb.h **** 	/** Bulk transfer */
1111:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK = 2U,
1112:/usr/include/libusb-1.0/libusb.h **** 
1113:/usr/include/libusb-1.0/libusb.h **** 	/** Interrupt transfer */
1114:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_INTERRUPT = 3U,
1115:/usr/include/libusb-1.0/libusb.h **** 
1116:/usr/include/libusb-1.0/libusb.h **** 	/** Bulk stream transfer */
1117:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK_STREAM = 4U
1118:/usr/include/libusb-1.0/libusb.h **** };
1119:/usr/include/libusb-1.0/libusb.h **** 
1120:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1121:/usr/include/libusb-1.0/libusb.h ****  * Transfer status codes */
1122:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_status {
1123:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer completed without error. Note that this does not indicate
1124:/usr/include/libusb-1.0/libusb.h **** 	 * that the entire amount of requested data was transferred. */
1125:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_COMPLETED,
1126:/usr/include/libusb-1.0/libusb.h **** 
1127:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer failed */
1128:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ERROR,
1129:/usr/include/libusb-1.0/libusb.h **** 
1130:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer timed out */
1131:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TIMED_OUT,
1132:/usr/include/libusb-1.0/libusb.h **** 
1133:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer was cancelled */
1134:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_CANCELLED,
1135:/usr/include/libusb-1.0/libusb.h **** 
1136:/usr/include/libusb-1.0/libusb.h **** 	/** For bulk/interrupt endpoints: halt condition detected (endpoint
1137:/usr/include/libusb-1.0/libusb.h **** 	 * stalled). For control endpoints: control request not supported. */
1138:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_STALL,
1139:/usr/include/libusb-1.0/libusb.h **** 
1140:/usr/include/libusb-1.0/libusb.h **** 	/** Device was disconnected */
1141:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_NO_DEVICE,
1142:/usr/include/libusb-1.0/libusb.h **** 
1143:/usr/include/libusb-1.0/libusb.h **** 	/** Device sent more data than requested */
1144:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_OVERFLOW
1145:/usr/include/libusb-1.0/libusb.h **** 
1146:/usr/include/libusb-1.0/libusb.h **** 	/* NB! Remember to update libusb_error_name()
1147:/usr/include/libusb-1.0/libusb.h **** 	   when adding new status codes here. */
1148:/usr/include/libusb-1.0/libusb.h **** };
1149:/usr/include/libusb-1.0/libusb.h **** 
1150:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1151:/usr/include/libusb-1.0/libusb.h ****  * libusb_transfer.flags values */
1152:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_flags {
1153:/usr/include/libusb-1.0/libusb.h **** 	/** Report short frames as errors */
1154:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_SHORT_NOT_OK = (1U << 0),
1155:/usr/include/libusb-1.0/libusb.h **** 
1156:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically free() transfer buffer during libusb_free_transfer().
1157:/usr/include/libusb-1.0/libusb.h **** 	 * Note that buffers allocated with libusb_dev_mem_alloc() should not
1158:/usr/include/libusb-1.0/libusb.h **** 	 * be attempted freed in this way, since free() is not an appropriate
1159:/usr/include/libusb-1.0/libusb.h **** 	 * way to release such memory. */
1160:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_BUFFER = (1U << 1),
1161:/usr/include/libusb-1.0/libusb.h **** 
1162:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically call libusb_free_transfer() after callback returns.
1163:/usr/include/libusb-1.0/libusb.h **** 	 * If this flag is set, it is illegal to call libusb_free_transfer()
1164:/usr/include/libusb-1.0/libusb.h **** 	 * from your transfer callback, as this will result in a double-free
1165:/usr/include/libusb-1.0/libusb.h **** 	 * when this flag is acted upon. */
1166:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_TRANSFER = (1U << 2),
1167:/usr/include/libusb-1.0/libusb.h **** 
1168:/usr/include/libusb-1.0/libusb.h **** 	/** Terminate transfers that are a multiple of the endpoint's
1169:/usr/include/libusb-1.0/libusb.h **** 	 * wMaxPacketSize with an extra zero length packet. This is useful
1170:/usr/include/libusb-1.0/libusb.h **** 	 * when a device protocol mandates that each logical request is
1171:/usr/include/libusb-1.0/libusb.h **** 	 * terminated by an incomplete packet (i.e. the logical requests are
1172:/usr/include/libusb-1.0/libusb.h **** 	 * not separated by other means).
1173:/usr/include/libusb-1.0/libusb.h **** 	 *
1174:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects host-to-device transfers to bulk and interrupt
1175:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. In other situations, it is ignored.
1176:/usr/include/libusb-1.0/libusb.h **** 	 *
1177:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects transfers with a length that is a multiple of
1178:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint's wMaxPacketSize. On transfers of other lengths, this
1179:/usr/include/libusb-1.0/libusb.h **** 	 * flag has no effect. Therefore, if you are working with a device that
1180:/usr/include/libusb-1.0/libusb.h **** 	 * needs a ZLP whenever the end of the logical request falls on a packet
1181:/usr/include/libusb-1.0/libusb.h **** 	 * boundary, then it is sensible to set this flag on <em>every</em>
1182:/usr/include/libusb-1.0/libusb.h **** 	 * transfer (you do not have to worry about only setting it on transfers
1183:/usr/include/libusb-1.0/libusb.h **** 	 * that end on the boundary).
1184:/usr/include/libusb-1.0/libusb.h **** 	 *
1185:/usr/include/libusb-1.0/libusb.h **** 	 * This flag is currently only supported on Linux.
1186:/usr/include/libusb-1.0/libusb.h **** 	 * On other systems, libusb_submit_transfer() will return
1187:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.
1188:/usr/include/libusb-1.0/libusb.h **** 	 *
1189:/usr/include/libusb-1.0/libusb.h **** 	 * Available since libusb-1.0.9.
1190:/usr/include/libusb-1.0/libusb.h **** 	 */
1191:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ADD_ZERO_PACKET = (1U << 3)
1192:/usr/include/libusb-1.0/libusb.h **** };
1193:/usr/include/libusb-1.0/libusb.h **** 
1194:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1195:/usr/include/libusb-1.0/libusb.h ****  * Isochronous packet descriptor. */
1196:/usr/include/libusb-1.0/libusb.h **** struct libusb_iso_packet_descriptor {
1197:/usr/include/libusb-1.0/libusb.h **** 	/** Length of data to request in this packet */
1198:/usr/include/libusb-1.0/libusb.h **** 	unsigned int length;
1199:/usr/include/libusb-1.0/libusb.h **** 
1200:/usr/include/libusb-1.0/libusb.h **** 	/** Amount of data that was actually transferred */
1201:/usr/include/libusb-1.0/libusb.h **** 	unsigned int actual_length;
1202:/usr/include/libusb-1.0/libusb.h **** 
1203:/usr/include/libusb-1.0/libusb.h **** 	/** Status code for this packet */
1204:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1205:/usr/include/libusb-1.0/libusb.h **** };
1206:/usr/include/libusb-1.0/libusb.h **** 
1207:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer;
1208:/usr/include/libusb-1.0/libusb.h **** 
1209:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1210:/usr/include/libusb-1.0/libusb.h ****  * Asynchronous transfer callback function type. When submitting asynchronous
1211:/usr/include/libusb-1.0/libusb.h ****  * transfers, you pass a pointer to a callback function of this type via the
1212:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_transfer::callback "callback" member of the libusb_transfer
1213:/usr/include/libusb-1.0/libusb.h ****  * structure. libusb will call this function later, when the transfer has
1214:/usr/include/libusb-1.0/libusb.h ****  * completed or failed. See \ref libusb_asyncio for more information.
1215:/usr/include/libusb-1.0/libusb.h ****  * \param transfer The libusb_transfer struct the callback function is being
1216:/usr/include/libusb-1.0/libusb.h ****  * notified about.
1217:/usr/include/libusb-1.0/libusb.h ****  */
1218:/usr/include/libusb-1.0/libusb.h **** typedef void (LIBUSB_CALL *libusb_transfer_cb_fn)(struct libusb_transfer *transfer);
1219:/usr/include/libusb-1.0/libusb.h **** 
1220:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1221:/usr/include/libusb-1.0/libusb.h ****  * The generic USB transfer structure. The user populates this structure and
1222:/usr/include/libusb-1.0/libusb.h ****  * then submits it in order to request a transfer. After the transfer has
1223:/usr/include/libusb-1.0/libusb.h ****  * completed, the library populates the transfer with the results and passes
1224:/usr/include/libusb-1.0/libusb.h ****  * it back to the user.
1225:/usr/include/libusb-1.0/libusb.h ****  */
1226:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer {
1227:/usr/include/libusb-1.0/libusb.h **** 	/** Handle of the device that this transfer will be submitted to */
1228:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle;
1229:/usr/include/libusb-1.0/libusb.h **** 
1230:/usr/include/libusb-1.0/libusb.h **** 	/** A bitwise OR combination of \ref libusb_transfer_flags. */
1231:/usr/include/libusb-1.0/libusb.h **** 	uint8_t flags;
1232:/usr/include/libusb-1.0/libusb.h **** 
1233:/usr/include/libusb-1.0/libusb.h **** 	/** Address of the endpoint where this transfer will be sent. */
1234:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint;
1235:/usr/include/libusb-1.0/libusb.h **** 
1236:/usr/include/libusb-1.0/libusb.h **** 	/** Type of the transfer from \ref libusb_transfer_type */
1237:/usr/include/libusb-1.0/libusb.h **** 	unsigned char type;
1238:/usr/include/libusb-1.0/libusb.h **** 
1239:/usr/include/libusb-1.0/libusb.h **** 	/** Timeout for this transfer in milliseconds. A value of 0 indicates no
1240:/usr/include/libusb-1.0/libusb.h **** 	 * timeout. */
1241:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout;
1242:/usr/include/libusb-1.0/libusb.h **** 
1243:/usr/include/libusb-1.0/libusb.h **** 	/** The status of the transfer. Read-only, and only for use within
1244:/usr/include/libusb-1.0/libusb.h **** 	 * transfer callback function.
1245:/usr/include/libusb-1.0/libusb.h **** 	 *
1246:/usr/include/libusb-1.0/libusb.h **** 	 * If this is an isochronous transfer, this field may read COMPLETED even
1247:/usr/include/libusb-1.0/libusb.h **** 	 * if there were errors in the frames. Use the
1248:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet
1249:/usr/include/libusb-1.0/libusb.h **** 	 * to determine if errors occurred. */
1250:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1251:/usr/include/libusb-1.0/libusb.h **** 
1252:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the data buffer. Must be non-negative. */
1253:/usr/include/libusb-1.0/libusb.h **** 	int length;
1254:/usr/include/libusb-1.0/libusb.h **** 
1255:/usr/include/libusb-1.0/libusb.h **** 	/** Actual length of data that was transferred. Read-only, and only for
1256:/usr/include/libusb-1.0/libusb.h **** 	 * use within transfer callback function. Not valid for isochronous
1257:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint transfers. */
1258:/usr/include/libusb-1.0/libusb.h **** 	int actual_length;
1259:/usr/include/libusb-1.0/libusb.h **** 
1260:/usr/include/libusb-1.0/libusb.h **** 	/** Callback function. This will be invoked when the transfer completes,
1261:/usr/include/libusb-1.0/libusb.h **** 	 * fails, or is cancelled. */
1262:/usr/include/libusb-1.0/libusb.h **** 	libusb_transfer_cb_fn callback;
1263:/usr/include/libusb-1.0/libusb.h **** 
1264:/usr/include/libusb-1.0/libusb.h **** 	/** User context data. Useful for associating specific data to a transfer
1265:/usr/include/libusb-1.0/libusb.h **** 	 * that can be accessed from within the callback function.
1266:/usr/include/libusb-1.0/libusb.h **** 	 *
1267:/usr/include/libusb-1.0/libusb.h **** 	 * This field may be set manually or is taken as the `user_data` parameter
1268:/usr/include/libusb-1.0/libusb.h **** 	 * of the following functions:
1269:/usr/include/libusb-1.0/libusb.h **** 	 * - libusb_fill_bulk_transfer()
1270:/usr/include/libusb-1.0/libusb.h **** 	 * - libusb_fill_bulk_stream_transfer()
1271:/usr/include/libusb-1.0/libusb.h **** 	 * - libusb_fill_control_transfer()
1272:/usr/include/libusb-1.0/libusb.h **** 	 * - libusb_fill_interrupt_transfer()
1273:/usr/include/libusb-1.0/libusb.h **** 	 * - libusb_fill_iso_transfer() */
1274:/usr/include/libusb-1.0/libusb.h **** 	void *user_data;
1275:/usr/include/libusb-1.0/libusb.h **** 
1276:/usr/include/libusb-1.0/libusb.h **** 	/** Data buffer */
1277:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer;
1278:/usr/include/libusb-1.0/libusb.h **** 
1279:/usr/include/libusb-1.0/libusb.h **** 	/** Number of isochronous packets. Only used for I/O with isochronous
1280:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. Must be non-negative. */
1281:/usr/include/libusb-1.0/libusb.h **** 	int num_iso_packets;
1282:/usr/include/libusb-1.0/libusb.h **** 
1283:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous packet descriptors, for isochronous transfers only. */
1284:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_iso_packet_descriptor iso_packet_desc[ZERO_SIZED_ARRAY];
1285:/usr/include/libusb-1.0/libusb.h **** };
1286:/usr/include/libusb-1.0/libusb.h **** 
1287:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
1288:/usr/include/libusb-1.0/libusb.h ****  * Capabilities supported by an instance of libusb on the current running
1289:/usr/include/libusb-1.0/libusb.h ****  * platform. Test if the loaded library supports a given capability by calling
1290:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_has_capability().
1291:/usr/include/libusb-1.0/libusb.h ****  */
1292:/usr/include/libusb-1.0/libusb.h **** enum libusb_capability {
1293:/usr/include/libusb-1.0/libusb.h **** 	/** The libusb_has_capability() API is available. */
1294:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_CAPABILITY = 0x0000U,
1295:/usr/include/libusb-1.0/libusb.h **** 
1296:/usr/include/libusb-1.0/libusb.h **** 	/** Hotplug support is available on this platform. */
1297:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HOTPLUG = 0x0001U,
1298:/usr/include/libusb-1.0/libusb.h **** 
1299:/usr/include/libusb-1.0/libusb.h **** 	/** The library can access HID devices without requiring user intervention.
1300:/usr/include/libusb-1.0/libusb.h **** 	 * Note that before being able to actually access an HID device, you may
1301:/usr/include/libusb-1.0/libusb.h **** 	 * still have to call additional libusb functions such as
1302:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(). */
1303:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HID_ACCESS = 0x0100U,
1304:/usr/include/libusb-1.0/libusb.h **** 
1305:/usr/include/libusb-1.0/libusb.h **** 	/** The library supports detaching of the default USB driver, using
1306:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(), if one is set by the OS kernel */
1307:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x0101U
1308:/usr/include/libusb-1.0/libusb.h **** };
1309:/usr/include/libusb-1.0/libusb.h **** 
1310:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
1311:/usr/include/libusb-1.0/libusb.h ****  *  Log message levels.
1312:/usr/include/libusb-1.0/libusb.h ****  */
1313:/usr/include/libusb-1.0/libusb.h **** enum libusb_log_level {
1314:/usr/include/libusb-1.0/libusb.h **** 	/** (0) : No messages ever emitted by the library (default) */
1315:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_NONE = 0,
1316:/usr/include/libusb-1.0/libusb.h **** 
1317:/usr/include/libusb-1.0/libusb.h **** 	/** (1) : Error messages are emitted */
1318:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_ERROR = 1,
1319:/usr/include/libusb-1.0/libusb.h **** 
1320:/usr/include/libusb-1.0/libusb.h **** 	/** (2) : Warning and error messages are emitted */
1321:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_WARNING = 2,
1322:/usr/include/libusb-1.0/libusb.h **** 
1323:/usr/include/libusb-1.0/libusb.h **** 	/** (3) : Informational, warning and error messages are emitted */
1324:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_INFO = 3,
1325:/usr/include/libusb-1.0/libusb.h **** 
1326:/usr/include/libusb-1.0/libusb.h **** 	/** (4) : All messages are emitted */
1327:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_DEBUG = 4
1328:/usr/include/libusb-1.0/libusb.h **** };
1329:/usr/include/libusb-1.0/libusb.h **** 
1330:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
1331:/usr/include/libusb-1.0/libusb.h ****  *  Log callback mode.
1332:/usr/include/libusb-1.0/libusb.h ****  *
1333:/usr/include/libusb-1.0/libusb.h ****  *  Since version 1.0.23, \ref LIBUSB_API_VERSION >= 0x01000107
1334:/usr/include/libusb-1.0/libusb.h ****  *
1335:/usr/include/libusb-1.0/libusb.h ****  * \see libusb_set_log_cb()
1336:/usr/include/libusb-1.0/libusb.h ****  */
1337:/usr/include/libusb-1.0/libusb.h **** enum libusb_log_cb_mode {
1338:/usr/include/libusb-1.0/libusb.h **** 	/** Callback function handling all log messages. */
1339:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_CB_GLOBAL = (1 << 0),
1340:/usr/include/libusb-1.0/libusb.h **** 
1341:/usr/include/libusb-1.0/libusb.h **** 	/** Callback function handling context related log messages. */
1342:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_CB_CONTEXT = (1 << 1)
1343:/usr/include/libusb-1.0/libusb.h **** };
1344:/usr/include/libusb-1.0/libusb.h **** 
1345:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
1346:/usr/include/libusb-1.0/libusb.h ****  * Callback function for handling log messages.
1347:/usr/include/libusb-1.0/libusb.h ****  * \param ctx the context which is related to the log message, or NULL if it
1348:/usr/include/libusb-1.0/libusb.h ****  * is a global log message
1349:/usr/include/libusb-1.0/libusb.h ****  * \param level the log level, see \ref libusb_log_level for a description
1350:/usr/include/libusb-1.0/libusb.h ****  * \param str the log message
1351:/usr/include/libusb-1.0/libusb.h ****  *
1352:/usr/include/libusb-1.0/libusb.h ****  * Since version 1.0.23, \ref LIBUSB_API_VERSION >= 0x01000107
1353:/usr/include/libusb-1.0/libusb.h ****  *
1354:/usr/include/libusb-1.0/libusb.h ****  * \see libusb_set_log_cb()
1355:/usr/include/libusb-1.0/libusb.h ****  */
1356:/usr/include/libusb-1.0/libusb.h **** typedef void (LIBUSB_CALL *libusb_log_cb)(libusb_context *ctx,
1357:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_log_level level, const char *str);
1358:/usr/include/libusb-1.0/libusb.h **** 
1359:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_init(libusb_context **ctx);
1360:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_exit(libusb_context *ctx);
1361:/usr/include/libusb-1.0/libusb.h **** LIBUSB_DEPRECATED_FOR(libusb_set_option)
1362:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_set_debug(libusb_context *ctx, int level);
1363:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_set_log_cb(libusb_context *ctx, libusb_log_cb cb, int mode);
1364:/usr/include/libusb-1.0/libusb.h **** const struct libusb_version * LIBUSB_CALL libusb_get_version(void);
1365:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_has_capability(uint32_t capability);
1366:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_error_name(int errcode);
1367:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_setlocale(const char *locale);
1368:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_strerror(int errcode);
1369:/usr/include/libusb-1.0/libusb.h **** 
1370:/usr/include/libusb-1.0/libusb.h **** ssize_t LIBUSB_CALL libusb_get_device_list(libusb_context *ctx,
1371:/usr/include/libusb-1.0/libusb.h **** 	libusb_device ***list);
1372:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_device_list(libusb_device **list,
1373:/usr/include/libusb-1.0/libusb.h **** 	int unref_devices);
1374:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_ref_device(libusb_device *dev);
1375:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_unref_device(libusb_device *dev);
1376:/usr/include/libusb-1.0/libusb.h **** 
1377:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_configuration(libusb_device_handle *dev,
1378:/usr/include/libusb-1.0/libusb.h **** 	int *config);
1379:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_descriptor(libusb_device *dev,
1380:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_device_descriptor *desc);
1381:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_active_config_descriptor(libusb_device *dev,
1382:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor **config);
1383:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor(libusb_device *dev,
1384:/usr/include/libusb-1.0/libusb.h **** 	uint8_t config_index, struct libusb_config_descriptor **config);
1385:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor_by_value(libusb_device *dev,
1386:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bConfigurationValue, struct libusb_config_descriptor **config);
1387:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_config_descriptor(
1388:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor *config);
1389:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_endpoint_companion_descriptor(
1390:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx,
1391:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint,
1392:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor **ep_comp);
1393:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_endpoint_companion_descriptor(
1394:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor *ep_comp);
1395:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_bos_descriptor(libusb_device_handle *dev_handle,
1396:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_descriptor **bos);
1397:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_bos_descriptor(struct libusb_bos_descriptor *bos);
1398:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_usb_2_0_extension_descriptor(
1399:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx,
1400:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1401:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension);
1402:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_usb_2_0_extension_descriptor(
1403:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension);
1404:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_usb_device_capability_descriptor(
1405:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx,
1406:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1407:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap);
1408:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_usb_device_capability_descriptor(
1409:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap);
1410:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_container_id_descriptor(libusb_context *ctx,
1411:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1412:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor **container_id);
1413:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_container_id_descriptor(
1414:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor *container_id);
1415:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_bus_number(libusb_device *dev);
1416:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_port_number(libusb_device *dev);
1417:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_numbers(libusb_device *dev, uint8_t *port_numbers, int port_numbers
1418:/usr/include/libusb-1.0/libusb.h **** LIBUSB_DEPRECATED_FOR(libusb_get_port_numbers)
1419:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_path(libusb_context *ctx, libusb_device *dev, uint8_t *path, uint8_
1420:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_parent(libusb_device *dev);
1421:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_device_address(libusb_device *dev);
1422:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_speed(libusb_device *dev);
1423:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_packet_size(libusb_device *dev,
1424:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1425:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,
1426:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1427:/usr/include/libusb-1.0/libusb.h **** 
1428:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_wrap_sys_device(libusb_context *ctx, intptr_t sys_dev, libusb_device_handle 
1429:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);
1430:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);
1431:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);
1432:/usr/include/libusb-1.0/libusb.h **** 
1433:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_configuration(libusb_device_handle *dev_handle,
1434:/usr/include/libusb-1.0/libusb.h **** 	int configuration);
1435:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_claim_interface(libusb_device_handle *dev_handle,
1436:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1437:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_release_interface(libusb_device_handle *dev_handle,
1438:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1439:/usr/include/libusb-1.0/libusb.h **** 
1440:/usr/include/libusb-1.0/libusb.h **** libusb_device_handle * LIBUSB_CALL libusb_open_device_with_vid_pid(
1441:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx, uint16_t vendor_id, uint16_t product_id);
1442:/usr/include/libusb-1.0/libusb.h **** 
1443:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_interface_alt_setting(libusb_device_handle *dev_handle,
1444:/usr/include/libusb-1.0/libusb.h **** 	int interface_number, int alternate_setting);
1445:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_clear_halt(libusb_device_handle *dev_handle,
1446:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1447:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_reset_device(libusb_device_handle *dev_handle);
1448:/usr/include/libusb-1.0/libusb.h **** 
1449:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_alloc_streams(libusb_device_handle *dev_handle,
1450:/usr/include/libusb-1.0/libusb.h **** 	uint32_t num_streams, unsigned char *endpoints, int num_endpoints);
1451:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_free_streams(libusb_device_handle *dev_handle,
1452:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *endpoints, int num_endpoints);
1453:/usr/include/libusb-1.0/libusb.h **** 
1454:/usr/include/libusb-1.0/libusb.h **** unsigned char * LIBUSB_CALL libusb_dev_mem_alloc(libusb_device_handle *dev_handle,
1455:/usr/include/libusb-1.0/libusb.h **** 	size_t length);
1456:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_dev_mem_free(libusb_device_handle *dev_handle,
1457:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, size_t length);
1458:/usr/include/libusb-1.0/libusb.h **** 
1459:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_kernel_driver_active(libusb_device_handle *dev_handle,
1460:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1461:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_detach_kernel_driver(libusb_device_handle *dev_handle,
1462:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1463:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_attach_kernel_driver(libusb_device_handle *dev_handle,
1464:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1465:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_auto_detach_kernel_driver(
1466:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle, int enable);
1467:/usr/include/libusb-1.0/libusb.h **** 
1468:/usr/include/libusb-1.0/libusb.h **** /* async I/O */
1469:/usr/include/libusb-1.0/libusb.h **** 
1470:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1471:/usr/include/libusb-1.0/libusb.h ****  * Get the data section of a control transfer. This convenience function is here
1472:/usr/include/libusb-1.0/libusb.h ****  * to remind you that the data does not start until 8 bytes into the actual
1473:/usr/include/libusb-1.0/libusb.h ****  * buffer, as the setup packet comes first.
1474:/usr/include/libusb-1.0/libusb.h ****  *
1475:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1476:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1477:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1478:/usr/include/libusb-1.0/libusb.h ****  *
1479:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1480:/usr/include/libusb-1.0/libusb.h ****  * \returns pointer to the first byte of the data section
1481:/usr/include/libusb-1.0/libusb.h ****  */
1482:/usr/include/libusb-1.0/libusb.h **** static inline unsigned char *libusb_control_transfer_get_data(
1483:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1484:/usr/include/libusb-1.0/libusb.h **** {
1485:/usr/include/libusb-1.0/libusb.h **** 	return transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE;
1486:/usr/include/libusb-1.0/libusb.h **** }
1487:/usr/include/libusb-1.0/libusb.h **** 
1488:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1489:/usr/include/libusb-1.0/libusb.h ****  * Get the control setup packet of a control transfer. This convenience
1490:/usr/include/libusb-1.0/libusb.h ****  * function is here to remind you that the control setup occupies the first
1491:/usr/include/libusb-1.0/libusb.h ****  * 8 bytes of the transfer data buffer.
1492:/usr/include/libusb-1.0/libusb.h ****  *
1493:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1494:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1495:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1496:/usr/include/libusb-1.0/libusb.h ****  *
1497:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1498:/usr/include/libusb-1.0/libusb.h ****  * \returns a casted pointer to the start of the transfer data buffer
1499:/usr/include/libusb-1.0/libusb.h ****  */
1500:/usr/include/libusb-1.0/libusb.h **** static inline struct libusb_control_setup *libusb_control_transfer_get_setup(
1501:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1502:/usr/include/libusb-1.0/libusb.h **** {
1503:/usr/include/libusb-1.0/libusb.h **** 	return (struct libusb_control_setup *)(void *)transfer->buffer;
1504:/usr/include/libusb-1.0/libusb.h **** }
1505:/usr/include/libusb-1.0/libusb.h **** 
1506:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1507:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the setup packet (first 8 bytes of the data
1508:/usr/include/libusb-1.0/libusb.h ****  * buffer) for a control transfer. The wIndex, wValue and wLength values should
1509:/usr/include/libusb-1.0/libusb.h ****  * be given in host-endian byte order.
1510:/usr/include/libusb-1.0/libusb.h ****  *
1511:/usr/include/libusb-1.0/libusb.h ****  * \param buffer buffer to output the setup packet into
1512:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1513:/usr/include/libusb-1.0/libusb.h ****  * \param bmRequestType see the
1514:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field of
1515:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1516:/usr/include/libusb-1.0/libusb.h ****  * \param bRequest see the
1517:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bRequest "bRequest" field of
1518:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1519:/usr/include/libusb-1.0/libusb.h ****  * \param wValue see the
1520:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wValue "wValue" field of
1521:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1522:/usr/include/libusb-1.0/libusb.h ****  * \param wIndex see the
1523:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wIndex "wIndex" field of
1524:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1525:/usr/include/libusb-1.0/libusb.h ****  * \param wLength see the
1526:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wLength "wLength" field of
1527:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1528:/usr/include/libusb-1.0/libusb.h ****  */
1529:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_setup(unsigned char *buffer,
1530:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
1531:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength)
1532:/usr/include/libusb-1.0/libusb.h **** {
1533:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *)buffer;
1534:/usr/include/libusb-1.0/libusb.h **** 	setup->bmRequestType = bmRequestType;
1535:/usr/include/libusb-1.0/libusb.h **** 	setup->bRequest = bRequest;
1536:/usr/include/libusb-1.0/libusb.h **** 	setup->wValue = libusb_cpu_to_le16(wValue);
1537:/usr/include/libusb-1.0/libusb.h **** 	setup->wIndex = libusb_cpu_to_le16(wIndex);
1538:/usr/include/libusb-1.0/libusb.h **** 	setup->wLength = libusb_cpu_to_le16(wLength);
1539:/usr/include/libusb-1.0/libusb.h **** }
1540:/usr/include/libusb-1.0/libusb.h **** 
1541:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer * LIBUSB_CALL libusb_alloc_transfer(int iso_packets);
1542:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_submit_transfer(struct libusb_transfer *transfer);
1543:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_cancel_transfer(struct libusb_transfer *transfer);
1544:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_transfer(struct libusb_transfer *transfer);
1545:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_transfer_set_stream_id(
1546:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, uint32_t stream_id);
1547:/usr/include/libusb-1.0/libusb.h **** uint32_t LIBUSB_CALL libusb_transfer_get_stream_id(
1548:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer);
1549:/usr/include/libusb-1.0/libusb.h **** 
1550:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1551:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1552:/usr/include/libusb-1.0/libusb.h ****  * for a control transfer.
1553:/usr/include/libusb-1.0/libusb.h ****  *
1554:/usr/include/libusb-1.0/libusb.h ****  * If you pass a transfer buffer to this function, the first 8 bytes will
1555:/usr/include/libusb-1.0/libusb.h ****  * be interpreted as a control setup packet, and the wLength field will be
1556:/usr/include/libusb-1.0/libusb.h ****  * used to automatically populate the \ref libusb_transfer::length "length"
1557:/usr/include/libusb-1.0/libusb.h ****  * field of the transfer. Therefore the recommended approach is:
1558:/usr/include/libusb-1.0/libusb.h ****  * -# Allocate a suitably sized data buffer (including space for control setup)
1559:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_fill_control_setup()
1560:/usr/include/libusb-1.0/libusb.h ****  * -# If this is a host-to-device transfer with a data stage, put the data
1561:/usr/include/libusb-1.0/libusb.h ****  *    in place after the setup packet
1562:/usr/include/libusb-1.0/libusb.h ****  * -# Call this function
1563:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_submit_transfer()
1564:/usr/include/libusb-1.0/libusb.h ****  *
1565:/usr/include/libusb-1.0/libusb.h ****  * It is also legal to pass a NULL buffer to this function, in which case this
1566:/usr/include/libusb-1.0/libusb.h ****  * function will not attempt to populate the length field. Remember that you
1567:/usr/include/libusb-1.0/libusb.h ****  * must then populate the buffer and length fields later.
1568:/usr/include/libusb-1.0/libusb.h ****  *
1569:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1570:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1571:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer. If provided, this function will interpret the
1572:/usr/include/libusb-1.0/libusb.h ****  * first 8 bytes as a setup packet and infer the transfer length from that.
1573:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1574:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1575:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1576:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1577:/usr/include/libusb-1.0/libusb.h ****  */
1578:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_transfer(
1579:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
1580:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data,
1581:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout)
1582:/usr/include/libusb-1.0/libusb.h **** {
1583:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *)buffer;
1584:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
1585:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = 0;
1586:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_CONTROL;
1587:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
1588:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
1589:/usr/include/libusb-1.0/libusb.h **** 	if (setup)
1590:/usr/include/libusb-1.0/libusb.h **** 		transfer->length = (int) (LIBUSB_CONTROL_SETUP_SIZE
1591:/usr/include/libusb-1.0/libusb.h **** 			+ libusb_le16_to_cpu(setup->wLength));
1592:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
1593:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
1594:/usr/include/libusb-1.0/libusb.h **** }
1595:/usr/include/libusb-1.0/libusb.h **** 
1596:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1597:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1598:/usr/include/libusb-1.0/libusb.h ****  * for a bulk transfer.
1599:/usr/include/libusb-1.0/libusb.h ****  *
1600:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1601:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1602:/usr/include/libusb-1.0/libusb.h ****  * \param endpoint address of the endpoint where this transfer will be sent
1603:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer
1604:/usr/include/libusb-1.0/libusb.h ****  * \param length length of data buffer
1605:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1606:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1607:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1608:/usr/include/libusb-1.0/libusb.h ****  */
1609:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer,
1610:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle, unsigned char endpoint,
1611:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, int length, libusb_transfer_cb_fn callback,
1612:/usr/include/libusb-1.0/libusb.h **** 	void *user_data, unsigned int timeout)
1613:/usr/include/libusb-1.0/libusb.h **** {
  31              		.loc 2 1613 1
  32              		.cfi_startproc
  33 0012 55       		pushq	%rbp
  34              		.cfi_def_cfa_offset 16
  35              		.cfi_offset 6, -16
  36 0013 4889E5   		movq	%rsp, %rbp
  37              		.cfi_def_cfa_register 6
  38 0016 48897DF8 		movq	%rdi, -8(%rbp)
  39 001a 488975F0 		movq	%rsi, -16(%rbp)
  40 001e 89D0     		movl	%edx, %eax
  41 0020 48894DE0 		movq	%rcx, -32(%rbp)
  42 0024 448945E8 		movl	%r8d, -24(%rbp)
  43 0028 4C894DD8 		movq	%r9, -40(%rbp)
  44 002c 8845EC   		movb	%al, -20(%rbp)
1614:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
  45              		.loc 2 1614 23
  46 002f 488B45F8 		movq	-8(%rbp), %rax
  47 0033 488B55F0 		movq	-16(%rbp), %rdx
  48 0037 488910   		movq	%rdx, (%rax)
1615:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = endpoint;
  49              		.loc 2 1615 21
  50 003a 488B45F8 		movq	-8(%rbp), %rax
  51 003e 0FB655EC 		movzbl	-20(%rbp), %edx
  52 0042 885009   		movb	%dl, 9(%rax)
1616:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
  53              		.loc 2 1616 17
  54 0045 488B45F8 		movq	-8(%rbp), %rax
  55 0049 C6400A02 		movb	$2, 10(%rax)
1617:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
  56              		.loc 2 1617 20
  57 004d 488B45F8 		movq	-8(%rbp), %rax
  58 0051 8B5518   		movl	24(%rbp), %edx
  59 0054 89500C   		movl	%edx, 12(%rax)
1618:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
  60              		.loc 2 1618 19
  61 0057 488B45F8 		movq	-8(%rbp), %rax
  62 005b 488B55E0 		movq	-32(%rbp), %rdx
  63 005f 48895030 		movq	%rdx, 48(%rax)
1619:/usr/include/libusb-1.0/libusb.h **** 	transfer->length = length;
  64              		.loc 2 1619 19
  65 0063 488B45F8 		movq	-8(%rbp), %rax
  66 0067 8B55E8   		movl	-24(%rbp), %edx
  67 006a 895014   		movl	%edx, 20(%rax)
1620:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
  68              		.loc 2 1620 22
  69 006d 488B45F8 		movq	-8(%rbp), %rax
  70 0071 488B5510 		movq	16(%rbp), %rdx
  71 0075 48895028 		movq	%rdx, 40(%rax)
1621:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
  72              		.loc 2 1621 21
  73 0079 488B45F8 		movq	-8(%rbp), %rax
  74 007d 488B55D8 		movq	-40(%rbp), %rdx
  75 0081 48895020 		movq	%rdx, 32(%rax)
1622:/usr/include/libusb-1.0/libusb.h **** }
  76              		.loc 2 1622 1
  77 0085 90       		nop
  78 0086 5D       		popq	%rbp
  79              		.cfi_def_cfa 7, 8
  80 0087 C3       		ret
  81              		.cfi_endproc
  82              	.LFE16:
  84              		.local	m_ctx
  85              		.comm	m_ctx,8,8
  86              		.section	.rodata
  87              	.LC0:
  88 0000 64657669 		.string	"device not found"
  88      6365206E 
  88      6F742066 
  88      6F756E64 
  88      00
  89              		.text
  91              	libusbOpenWithVidPid:
  92              	.LFB25:
  93              		.file 3 "libusbwrap.c"
   1:libusbwrap.c  **** /*
   2:libusbwrap.c  ****  * Copyright (C) 2009-2012 Chris McClelland
   3:libusbwrap.c  ****  *
   4:libusbwrap.c  ****  * This program is free software: you can redistribute it and/or modify
   5:libusbwrap.c  ****  * it under the terms of the GNU Lesser General Public License as published by
   6:libusbwrap.c  ****  * the Free Software Foundation, either version 3 of the License, or
   7:libusbwrap.c  ****  * (at your option) any later version.
   8:libusbwrap.c  ****  *
   9:libusbwrap.c  ****  * This program is distributed in the hope that it will be useful,
  10:libusbwrap.c  ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:libusbwrap.c  ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:libusbwrap.c  ****  * GNU Lesser General Public License for more details.
  13:libusbwrap.c  ****  *
  14:libusbwrap.c  ****  * You should have received a copy of the GNU Lesser General Public License
  15:libusbwrap.c  ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:libusbwrap.c  ****  */
  17:libusbwrap.c  **** #ifdef WIN32
  18:libusbwrap.c  **** #include <Windows.h>
  19:libusbwrap.c  **** #else
  20:libusbwrap.c  **** #define _BSD_SOURCE
  21:libusbwrap.c  **** #include <unistd.h>
  22:libusbwrap.c  **** #endif
  23:libusbwrap.c  **** #include <stdio.h>
  24:libusbwrap.c  **** #include <stdlib.h>
  25:libusbwrap.c  **** #include <string.h>
  26:libusbwrap.c  **** #include <makestuff.h>
  27:libusbwrap.c  **** #include <liberror.h>
  28:libusbwrap.c  **** #include "private.h"
  29:libusbwrap.c  **** 
  30:libusbwrap.c  **** static struct libusb_context *m_ctx = NULL;
  31:libusbwrap.c  **** 
  32:libusbwrap.c  **** // Modified from libusb_open_device_with_vid_pid in core.c of libusbx
  33:libusbwrap.c  **** //
  34:libusbwrap.c  **** static libusb_device_handle *libusbOpenWithVidPid(
  35:libusbwrap.c  **** 	libusb_context *ctx, uint16 vid, uint16 pid, uint16 did, const char **error)
  36:libusbwrap.c  **** {
  94              		.loc 3 36 1
  95              		.cfi_startproc
  96 0088 F30F1EFA 		endbr64
  97 008c 55       		pushq	%rbp
  98              		.cfi_def_cfa_offset 16
  99              		.cfi_offset 6, -16
 100 008d 4889E5   		movq	%rsp, %rbp
 101              		.cfi_def_cfa_register 6
 102 0090 4883EC70 		subq	$112, %rsp
 103 0094 48897DA8 		movq	%rdi, -88(%rbp)
 104 0098 89C8     		movl	%ecx, %eax
 105 009a 4C894590 		movq	%r8, -112(%rbp)
 106 009e 89F1     		movl	%esi, %ecx
 107 00a0 66894DA4 		movw	%cx, -92(%rbp)
 108 00a4 668955A0 		movw	%dx, -96(%rbp)
 109 00a8 6689459C 		movw	%ax, -100(%rbp)
 110              		.loc 3 36 1
 111 00ac 64488B04 		movq	%fs:40, %rax
 111      25280000 
 111      00
 112 00b5 488945F8 		movq	%rax, -8(%rbp)
 113 00b9 31C0     		xorl	%eax, %eax
  37:libusbwrap.c  **** 	libusb_device_handle *retVal = NULL;
 114              		.loc 3 37 24
 115 00bb 48C745B8 		movq	$0, -72(%rbp)
 115      00000000 
  38:libusbwrap.c  **** 	struct libusb_device **devs;
  39:libusbwrap.c  **** 	struct libusb_device *found = NULL;
 116              		.loc 3 39 24
 117 00c3 48C745C8 		movq	$0, -56(%rbp)
 117      00000000 
  40:libusbwrap.c  **** 	struct libusb_device *dev;
  41:libusbwrap.c  **** 	size_t i = 0;
 118              		.loc 3 41 9
 119 00cb 48C745D8 		movq	$0, -40(%rbp)
 119      00000000 
  42:libusbwrap.c  **** 	int status = (int)libusb_get_device_list(ctx, &devs);
 120              		.loc 3 42 20
 121 00d3 488D55C0 		leaq	-64(%rbp), %rdx
 122 00d7 488B45A8 		movq	-88(%rbp), %rax
 123 00db 4889D6   		movq	%rdx, %rsi
 124 00de 4889C7   		movq	%rax, %rdi
 125 00e1 E8000000 		call	libusb_get_device_list@PLT
 125      00
 126              		.loc 3 42 6
 127 00e6 8945B4   		movl	%eax, -76(%rbp)
  43:libusbwrap.c  **** 	CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 128              		.loc 3 43 2
 129 00e9 837DB400 		cmpl	$0, -76(%rbp)
 130 00ed 7929     		jns	.L5
 131              		.loc 3 43 2 is_stmt 0 discriminator 1
 132 00ef 8B45B4   		movl	-76(%rbp), %eax
 133 00f2 89C7     		movl	%eax, %edi
 134 00f4 E8000000 		call	libusb_error_name@PLT
 134      00
 135 00f9 4889C2   		movq	%rax, %rdx
 136 00fc 488B4590 		movq	-112(%rbp), %rax
 137 0100 4889D6   		movq	%rdx, %rsi
 138 0103 4889C7   		movq	%rax, %rdi
 139 0106 E8000000 		call	errPrefix@PLT
 139      00
 140 010b 48C745B8 		movq	$0, -72(%rbp)
 140      00000000 
 141 0113 E9240100 		jmp	.L6
 141      00
 142              	.L5:
  44:libusbwrap.c  **** 	dev = devs[i++];
 143              		.loc 3 44 12 is_stmt 1
 144 0118 488B4DC0 		movq	-64(%rbp), %rcx
 145              		.loc 3 44 14
 146 011c 488B45D8 		movq	-40(%rbp), %rax
 147 0120 488D5001 		leaq	1(%rax), %rdx
 148 0124 488955D8 		movq	%rdx, -40(%rbp)
 149              		.loc 3 44 12
 150 0128 48C1E003 		salq	$3, %rax
 151 012c 4801C8   		addq	%rcx, %rax
 152              		.loc 3 44 6
 153 012f 488B00   		movq	(%rax), %rax
 154 0132 488945D0 		movq	%rax, -48(%rbp)
  45:libusbwrap.c  **** 	while ( dev ) {
 155              		.loc 3 45 8
 156 0136 E9920000 		jmp	.L7
 156      00
 157              	.L12:
 158              	.LBB2:
  46:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
  47:libusbwrap.c  **** 		status = libusb_get_device_descriptor(dev, &desc);
 159              		.loc 3 47 12
 160 013b 488D55E0 		leaq	-32(%rbp), %rdx
 161 013f 488B45D0 		movq	-48(%rbp), %rax
 162 0143 4889D6   		movq	%rdx, %rsi
 163 0146 4889C7   		movq	%rax, %rdi
 164 0149 E8000000 		call	libusb_get_device_descriptor@PLT
 164      00
 165 014e 8945B4   		movl	%eax, -76(%rbp)
  48:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 166              		.loc 3 48 3
 167 0151 837DB400 		cmpl	$0, -76(%rbp)
 168 0155 7929     		jns	.L8
 169              		.loc 3 48 3 is_stmt 0 discriminator 1
 170 0157 8B45B4   		movl	-76(%rbp), %eax
 171 015a 89C7     		movl	%eax, %edi
 172 015c E8000000 		call	libusb_error_name@PLT
 172      00
 173 0161 4889C2   		movq	%rax, %rdx
 174 0164 488B4590 		movq	-112(%rbp), %rax
 175 0168 4889D6   		movq	%rdx, %rsi
 176 016b 4889C7   		movq	%rax, %rdi
 177 016e E8000000 		call	errPrefix@PLT
 177      00
 178 0173 48C745B8 		movq	$0, -72(%rbp)
 178      00000000 
 179 017b E9BC0000 		jmp	.L6
 179      00
 180              	.L8:
  49:libusbwrap.c  **** 		if (
  50:libusbwrap.c  **** 			desc.idVendor == vid &&
 181              		.loc 3 50 8 is_stmt 1
 182 0180 0FB745E8 		movzwl	-24(%rbp), %eax
  49:libusbwrap.c  **** 		if (
 183              		.loc 3 49 6
 184 0184 663945A4 		cmpw	%ax, -92(%rbp)
 185 0188 7525     		jne	.L9
  51:libusbwrap.c  **** 			desc.idProduct == pid &&
 186              		.loc 3 51 8
 187 018a 0FB745EA 		movzwl	-22(%rbp), %eax
  50:libusbwrap.c  **** 			desc.idProduct == pid &&
 188              		.loc 3 50 25
 189 018e 663945A0 		cmpw	%ax, -96(%rbp)
 190 0192 751B     		jne	.L9
 191              		.loc 3 51 26
 192 0194 66837D9C 		cmpw	$0, -100(%rbp)
 192      00
 193 0199 740A     		je	.L10
  52:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 194              		.loc 3 52 26
 195 019b 0FB745EC 		movzwl	-20(%rbp), %eax
 196              		.loc 3 52 19
 197 019f 6639459C 		cmpw	%ax, -100(%rbp)
 198 01a3 750A     		jne	.L9
 199              	.L10:
  53:libusbwrap.c  **** 		) {
  54:libusbwrap.c  **** 			found = dev;
 200              		.loc 3 54 10
 201 01a5 488B45D0 		movq	-48(%rbp), %rax
 202 01a9 488945C8 		movq	%rax, -56(%rbp)
 203 01ad EB29     		jmp	.L11
 204              	.L9:
  55:libusbwrap.c  **** 			break;
  56:libusbwrap.c  **** 		}
  57:libusbwrap.c  **** 		dev = devs[i++];
 205              		.loc 3 57 13
 206 01af 488B4DC0 		movq	-64(%rbp), %rcx
 207              		.loc 3 57 15
 208 01b3 488B45D8 		movq	-40(%rbp), %rax
 209 01b7 488D5001 		leaq	1(%rax), %rdx
 210 01bb 488955D8 		movq	%rdx, -40(%rbp)
 211              		.loc 3 57 13
 212 01bf 48C1E003 		salq	$3, %rax
 213 01c3 4801C8   		addq	%rcx, %rax
 214              		.loc 3 57 7
 215 01c6 488B00   		movq	(%rax), %rax
 216 01c9 488945D0 		movq	%rax, -48(%rbp)
 217              	.L7:
 218              	.LBE2:
  45:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
 219              		.loc 3 45 10
 220 01cd 48837DD0 		cmpq	$0, -48(%rbp)
 220      00
 221 01d2 0F8563FF 		jne	.L12
 221      FFFF
 222              	.L11:
  58:libusbwrap.c  **** 	}
  59:libusbwrap.c  **** 
  60:libusbwrap.c  **** 	if ( found ) {
 223              		.loc 3 60 5
 224 01d8 48837DC8 		cmpq	$0, -56(%rbp)
 224      00
 225 01dd 7442     		je	.L13
  61:libusbwrap.c  **** 		status = libusb_open(found, &retVal);
 226              		.loc 3 61 12
 227 01df 488D55B8 		leaq	-72(%rbp), %rdx
 228 01e3 488B45C8 		movq	-56(%rbp), %rax
 229 01e7 4889D6   		movq	%rdx, %rsi
 230 01ea 4889C7   		movq	%rax, %rdi
 231 01ed E8000000 		call	libusb_open@PLT
 231      00
 232 01f2 8945B4   		movl	%eax, -76(%rbp)
  62:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 233              		.loc 3 62 3
 234 01f5 837DB400 		cmpl	$0, -76(%rbp)
 235 01f9 7941     		jns	.L6
 236              		.loc 3 62 3 is_stmt 0 discriminator 1
 237 01fb 8B45B4   		movl	-76(%rbp), %eax
 238 01fe 89C7     		movl	%eax, %edi
 239 0200 E8000000 		call	libusb_error_name@PLT
 239      00
 240 0205 4889C2   		movq	%rax, %rdx
 241 0208 488B4590 		movq	-112(%rbp), %rax
 242 020c 4889D6   		movq	%rdx, %rsi
 243 020f 4889C7   		movq	%rax, %rdi
 244 0212 E8000000 		call	errPrefix@PLT
 244      00
 245 0217 48C745B8 		movq	$0, -72(%rbp)
 245      00000000 
 246 021f EB1B     		jmp	.L6
 247              	.L13:
  63:libusbwrap.c  **** 	} else {
  64:libusbwrap.c  **** 		errRender(error, "device not found");
 248              		.loc 3 64 3 is_stmt 1
 249 0221 488B4590 		movq	-112(%rbp), %rax
 250 0225 488D1500 		leaq	.LC0(%rip), %rdx
 250      000000
 251 022c 4889D6   		movq	%rdx, %rsi
 252 022f 4889C7   		movq	%rax, %rdi
 253 0232 B8000000 		movl	$0, %eax
 253      00
 254 0237 E8000000 		call	errRender@PLT
 254      00
 255              	.L6:
  65:libusbwrap.c  **** 	}
  66:libusbwrap.c  **** 
  67:libusbwrap.c  **** cleanup:
  68:libusbwrap.c  **** 	libusb_free_device_list(devs, 1);
 256              		.loc 3 68 2
 257 023c 488B45C0 		movq	-64(%rbp), %rax
 258 0240 BE010000 		movl	$1, %esi
 258      00
 259 0245 4889C7   		movq	%rax, %rdi
 260 0248 E8000000 		call	libusb_free_device_list@PLT
 260      00
  69:libusbwrap.c  **** 	return retVal;
 261              		.loc 3 69 9
 262 024d 488B45B8 		movq	-72(%rbp), %rax
  70:libusbwrap.c  **** }
 263              		.loc 3 70 1
 264 0251 488B55F8 		movq	-8(%rbp), %rdx
 265 0255 64482B14 		subq	%fs:40, %rdx
 265      25280000 
 265      00
 266 025e 7405     		je	.L15
 267 0260 E8000000 		call	__stack_chk_fail@PLT
 267      00
 268              	.L15:
 269 0265 C9       		leave
 270              		.cfi_def_cfa 7, 8
 271 0266 C3       		ret
 272              		.cfi_endproc
 273              	.LFE25:
 275              		.globl	usbValidateVidPid
 277              	usbValidateVidPid:
 278              	.LFB26:
  71:libusbwrap.c  **** 
  72:libusbwrap.c  **** // Return true if vp is VVVV:PPPP where V and P are hex digits:
  73:libusbwrap.c  **** //
  74:libusbwrap.c  **** DLLEXPORT(bool) usbValidateVidPid(const char *vp) {
 279              		.loc 3 74 51
 280              		.cfi_startproc
 281 0267 F30F1EFA 		endbr64
 282 026b 55       		pushq	%rbp
 283              		.cfi_def_cfa_offset 16
 284              		.cfi_offset 6, -16
 285 026c 4889E5   		movq	%rsp, %rbp
 286              		.cfi_def_cfa_register 6
 287 026f 4883EC20 		subq	$32, %rsp
 288 0273 48897DE8 		movq	%rdi, -24(%rbp)
  75:libusbwrap.c  **** 	int i;
  76:libusbwrap.c  **** 	char ch;
  77:libusbwrap.c  **** 	const size_t len = strlen(vp);
 289              		.loc 3 77 21
 290 0277 488B45E8 		movq	-24(%rbp), %rax
 291 027b 4889C7   		movq	%rax, %rdi
 292 027e E8000000 		call	strlen@PLT
 292      00
 293 0283 488945F8 		movq	%rax, -8(%rbp)
  78:libusbwrap.c  **** 	bool hasDID;
  79:libusbwrap.c  **** 	if ( !vp ) {
 294              		.loc 3 79 5
 295 0287 48837DE8 		cmpq	$0, -24(%rbp)
 295      00
 296 028c 750A     		jne	.L17
  80:libusbwrap.c  **** 		return false;
 297              		.loc 3 80 10
 298 028e B8000000 		movl	$0, %eax
 298      00
 299 0293 E9530100 		jmp	.L18
 299      00
 300              	.L17:
  81:libusbwrap.c  **** 	}
  82:libusbwrap.c  **** 	if ( len == 9 ) {
 301              		.loc 3 82 5
 302 0298 48837DF8 		cmpq	$9, -8(%rbp)
 302      09
 303 029d 7506     		jne	.L19
  83:libusbwrap.c  **** 		hasDID = false;
 304              		.loc 3 83 10
 305 029f C645F200 		movb	$0, -14(%rbp)
 306 02a3 EB17     		jmp	.L20
 307              	.L19:
  84:libusbwrap.c  **** 	} else if ( len == 14 ) {
 308              		.loc 3 84 12
 309 02a5 48837DF8 		cmpq	$14, -8(%rbp)
 309      0E
 310 02aa 7506     		jne	.L21
  85:libusbwrap.c  **** 		hasDID = true;
 311              		.loc 3 85 10
 312 02ac C645F201 		movb	$1, -14(%rbp)
 313 02b0 EB0A     		jmp	.L20
 314              	.L21:
  86:libusbwrap.c  **** 	} else {
  87:libusbwrap.c  **** 		return false;
 315              		.loc 3 87 10
 316 02b2 B8000000 		movl	$0, %eax
 316      00
 317 02b7 E92F0100 		jmp	.L18
 317      00
 318              	.L20:
  88:libusbwrap.c  **** 	}
  89:libusbwrap.c  **** 	if ( vp[4] != ':' || (hasDID && vp[9] != ':') ) {
 319              		.loc 3 89 9
 320 02bc 488B45E8 		movq	-24(%rbp), %rax
 321 02c0 4883C004 		addq	$4, %rax
 322 02c4 0FB600   		movzbl	(%rax), %eax
 323              		.loc 3 89 5
 324 02c7 3C3A     		cmpb	$58, %al
 325 02c9 7515     		jne	.L22
 326              		.loc 3 89 20 discriminator 1
 327 02cb 807DF200 		cmpb	$0, -14(%rbp)
 328 02cf 7419     		je	.L23
 329              		.loc 3 89 36 discriminator 2
 330 02d1 488B45E8 		movq	-24(%rbp), %rax
 331 02d5 4883C009 		addq	$9, %rax
 332 02d9 0FB600   		movzbl	(%rax), %eax
 333              		.loc 3 89 31 discriminator 2
 334 02dc 3C3A     		cmpb	$58, %al
 335 02de 740A     		je	.L23
 336              	.L22:
  90:libusbwrap.c  **** 		return false;
 337              		.loc 3 90 10
 338 02e0 B8000000 		movl	$0, %eax
 338      00
 339 02e5 E9010100 		jmp	.L18
 339      00
 340              	.L23:
  91:libusbwrap.c  **** 	}
  92:libusbwrap.c  **** 	for ( i = 0; i < 4; i++ ) {
 341              		.loc 3 92 10
 342 02ea C745F400 		movl	$0, -12(%rbp)
 342      000000
 343              		.loc 3 92 2
 344 02f1 EB45     		jmp	.L24
 345              	.L29:
  93:libusbwrap.c  **** 		ch = vp[i];
 346              		.loc 3 93 10
 347 02f3 8B45F4   		movl	-12(%rbp), %eax
 348 02f6 4863D0   		movslq	%eax, %rdx
 349 02f9 488B45E8 		movq	-24(%rbp), %rax
 350 02fd 4801D0   		addq	%rdx, %rax
 351              		.loc 3 93 6
 352 0300 0FB600   		movzbl	(%rax), %eax
 353 0303 8845F3   		movb	%al, -13(%rbp)
  94:libusbwrap.c  **** 		if (
 354              		.loc 3 94 6
 355 0306 807DF32F 		cmpb	$47, -13(%rbp)
 356 030a 7E1E     		jle	.L25
  95:libusbwrap.c  **** 			ch < '0' ||
 357              		.loc 3 95 13
 358 030c 807DF339 		cmpb	$57, -13(%rbp)
 359 0310 7E06     		jle	.L26
  96:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 360              		.loc 3 96 14
 361 0312 807DF340 		cmpb	$64, -13(%rbp)
 362 0316 7E12     		jle	.L25
 363              	.L26:
 364              		.loc 3 96 27 discriminator 1
 365 0318 807DF346 		cmpb	$70, -13(%rbp)
 366 031c 7E06     		jle	.L27
  97:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 367              		.loc 3 97 14
 368 031e 807DF360 		cmpb	$96, -13(%rbp)
 369 0322 7E06     		jle	.L25
 370              	.L27:
 371              		.loc 3 97 27 discriminator 1
 372 0324 807DF366 		cmpb	$102, -13(%rbp)
 373 0328 7E0A     		jle	.L28
 374              	.L25:
  98:libusbwrap.c  **** 			ch > 'f')
  99:libusbwrap.c  **** 		{
 100:libusbwrap.c  **** 			return false;
 375              		.loc 3 100 11
 376 032a B8000000 		movl	$0, %eax
 376      00
 377 032f E9B70000 		jmp	.L18
 377      00
 378              	.L28:
  92:libusbwrap.c  **** 		ch = vp[i];
 379              		.loc 3 92 23 discriminator 2
 380 0334 8345F401 		addl	$1, -12(%rbp)
 381              	.L24:
  92:libusbwrap.c  **** 		ch = vp[i];
 382              		.loc 3 92 17 discriminator 1
 383 0338 837DF403 		cmpl	$3, -12(%rbp)
 384 033c 7EB5     		jle	.L29
 101:libusbwrap.c  **** 		}
 102:libusbwrap.c  **** 	}
 103:libusbwrap.c  **** 	for ( i = 5; i < 9; i++ ) {
 385              		.loc 3 103 10
 386 033e C745F405 		movl	$5, -12(%rbp)
 386      000000
 387              		.loc 3 103 2
 388 0345 EB42     		jmp	.L30
 389              	.L35:
 104:libusbwrap.c  **** 		ch = vp[i];
 390              		.loc 3 104 10
 391 0347 8B45F4   		movl	-12(%rbp), %eax
 392 034a 4863D0   		movslq	%eax, %rdx
 393 034d 488B45E8 		movq	-24(%rbp), %rax
 394 0351 4801D0   		addq	%rdx, %rax
 395              		.loc 3 104 6
 396 0354 0FB600   		movzbl	(%rax), %eax
 397 0357 8845F3   		movb	%al, -13(%rbp)
 105:libusbwrap.c  **** 		if (
 398              		.loc 3 105 6
 399 035a 807DF32F 		cmpb	$47, -13(%rbp)
 400 035e 7E1E     		jle	.L31
 106:libusbwrap.c  **** 			ch < '0' ||
 401              		.loc 3 106 13
 402 0360 807DF339 		cmpb	$57, -13(%rbp)
 403 0364 7E06     		jle	.L32
 107:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 404              		.loc 3 107 14
 405 0366 807DF340 		cmpb	$64, -13(%rbp)
 406 036a 7E12     		jle	.L31
 407              	.L32:
 408              		.loc 3 107 27 discriminator 1
 409 036c 807DF346 		cmpb	$70, -13(%rbp)
 410 0370 7E06     		jle	.L33
 108:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 411              		.loc 3 108 14
 412 0372 807DF360 		cmpb	$96, -13(%rbp)
 413 0376 7E06     		jle	.L31
 414              	.L33:
 415              		.loc 3 108 27 discriminator 1
 416 0378 807DF366 		cmpb	$102, -13(%rbp)
 417 037c 7E07     		jle	.L34
 418              	.L31:
 109:libusbwrap.c  **** 			ch > 'f')
 110:libusbwrap.c  **** 		{
 111:libusbwrap.c  **** 			return false;
 419              		.loc 3 111 11
 420 037e B8000000 		movl	$0, %eax
 420      00
 421 0383 EB66     		jmp	.L18
 422              	.L34:
 103:libusbwrap.c  **** 		ch = vp[i];
 423              		.loc 3 103 23 discriminator 2
 424 0385 8345F401 		addl	$1, -12(%rbp)
 425              	.L30:
 103:libusbwrap.c  **** 		ch = vp[i];
 426              		.loc 3 103 17 discriminator 1
 427 0389 837DF408 		cmpl	$8, -12(%rbp)
 428 038d 7EB8     		jle	.L35
 112:libusbwrap.c  **** 		}
 113:libusbwrap.c  **** 	}
 114:libusbwrap.c  **** 	if ( hasDID ) {
 429              		.loc 3 114 5
 430 038f 807DF200 		cmpb	$0, -14(%rbp)
 431 0393 7451     		je	.L36
 115:libusbwrap.c  **** 		for ( i = 10; i < 14; i++ ) {
 432              		.loc 3 115 11
 433 0395 C745F40A 		movl	$10, -12(%rbp)
 433      000000
 434              		.loc 3 115 3
 435 039c EB42     		jmp	.L37
 436              	.L42:
 116:libusbwrap.c  **** 			ch = vp[i];
 437              		.loc 3 116 11
 438 039e 8B45F4   		movl	-12(%rbp), %eax
 439 03a1 4863D0   		movslq	%eax, %rdx
 440 03a4 488B45E8 		movq	-24(%rbp), %rax
 441 03a8 4801D0   		addq	%rdx, %rax
 442              		.loc 3 116 7
 443 03ab 0FB600   		movzbl	(%rax), %eax
 444 03ae 8845F3   		movb	%al, -13(%rbp)
 117:libusbwrap.c  **** 			if (
 445              		.loc 3 117 7
 446 03b1 807DF32F 		cmpb	$47, -13(%rbp)
 447 03b5 7E1E     		jle	.L38
 118:libusbwrap.c  **** 				ch < '0' ||
 448              		.loc 3 118 14
 449 03b7 807DF339 		cmpb	$57, -13(%rbp)
 450 03bb 7E06     		jle	.L39
 119:libusbwrap.c  **** 				(ch > '9' && ch < 'A') ||
 451              		.loc 3 119 15
 452 03bd 807DF340 		cmpb	$64, -13(%rbp)
 453 03c1 7E12     		jle	.L38
 454              	.L39:
 455              		.loc 3 119 28 discriminator 1
 456 03c3 807DF346 		cmpb	$70, -13(%rbp)
 457 03c7 7E06     		jle	.L40
 120:libusbwrap.c  **** 				(ch > 'F' && ch < 'a') ||
 458              		.loc 3 120 15
 459 03c9 807DF360 		cmpb	$96, -13(%rbp)
 460 03cd 7E06     		jle	.L38
 461              	.L40:
 462              		.loc 3 120 28 discriminator 1
 463 03cf 807DF366 		cmpb	$102, -13(%rbp)
 464 03d3 7E07     		jle	.L41
 465              	.L38:
 121:libusbwrap.c  **** 				ch > 'f')
 122:libusbwrap.c  **** 			{
 123:libusbwrap.c  **** 				return false;
 466              		.loc 3 123 12
 467 03d5 B8000000 		movl	$0, %eax
 467      00
 468 03da EB0F     		jmp	.L18
 469              	.L41:
 115:libusbwrap.c  **** 			ch = vp[i];
 470              		.loc 3 115 26 discriminator 2
 471 03dc 8345F401 		addl	$1, -12(%rbp)
 472              	.L37:
 115:libusbwrap.c  **** 			ch = vp[i];
 473              		.loc 3 115 19 discriminator 1
 474 03e0 837DF40D 		cmpl	$13, -12(%rbp)
 475 03e4 7EB8     		jle	.L42
 476              	.L36:
 124:libusbwrap.c  **** 			}
 125:libusbwrap.c  **** 		}
 126:libusbwrap.c  **** 	}
 127:libusbwrap.c  **** 	return true;
 477              		.loc 3 127 9
 478 03e6 B8010000 		movl	$1, %eax
 478      00
 479              	.L18:
 128:libusbwrap.c  **** }
 480              		.loc 3 128 1
 481 03eb C9       		leave
 482              		.cfi_def_cfa 7, 8
 483 03ec C3       		ret
 484              		.cfi_endproc
 485              	.LFE26:
 487              		.section	.rodata
 488              	.LC1:
 489 0011 75736249 		.string	"usbInitialise(): %s"
 489      6E697469 
 489      616C6973 
 489      6528293A 
 489      20257300 
 490              		.text
 491              		.globl	usbInitialise
 493              	usbInitialise:
 494              	.LFB27:
 129:libusbwrap.c  **** 
 130:libusbwrap.c  **** // Initialise LibUSB with the given log level.
 131:libusbwrap.c  **** //
 132:libusbwrap.c  **** DLLEXPORT(USBStatus) usbInitialise(int debugLevel, const char **error) {
 495              		.loc 3 132 72
 496              		.cfi_startproc
 497 03ed F30F1EFA 		endbr64
 498 03f1 55       		pushq	%rbp
 499              		.cfi_def_cfa_offset 16
 500              		.cfi_offset 6, -16
 501 03f2 4889E5   		movq	%rsp, %rbp
 502              		.cfi_def_cfa_register 6
 503 03f5 4883EC20 		subq	$32, %rsp
 504 03f9 897DEC   		movl	%edi, -20(%rbp)
 505 03fc 488975E0 		movq	%rsi, -32(%rbp)
 133:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 506              		.loc 3 133 12
 507 0400 C745F800 		movl	$0, -8(%rbp)
 507      000000
 134:libusbwrap.c  **** 	int status = libusb_init(&m_ctx);
 508              		.loc 3 134 15
 509 0407 488D0500 		leaq	m_ctx(%rip), %rax
 509      000000
 510 040e 4889C7   		movq	%rax, %rdi
 511 0411 E8000000 		call	libusb_init@PLT
 511      00
 512 0416 8945FC   		movl	%eax, -4(%rbp)
 135:libusbwrap.c  **** 	CHECK_STATUS(status, USB_INIT, cleanup, "usbInitialise(): %s", libusb_error_name(status));
 513              		.loc 3 135 2
 514 0419 837DFC00 		cmpl	$0, -4(%rbp)
 515 041d 7431     		je	.L44
 516              		.loc 3 135 2 is_stmt 0 discriminator 1
 517 041f 8B45FC   		movl	-4(%rbp), %eax
 518 0422 89C7     		movl	%eax, %edi
 519 0424 E8000000 		call	libusb_error_name@PLT
 519      00
 520 0429 4889C2   		movq	%rax, %rdx
 521 042c 488B45E0 		movq	-32(%rbp), %rax
 522 0430 488D0D00 		leaq	.LC1(%rip), %rcx
 522      000000
 523 0437 4889CE   		movq	%rcx, %rsi
 524 043a 4889C7   		movq	%rax, %rdi
 525 043d B8000000 		movl	$0, %eax
 525      00
 526 0442 E8000000 		call	errRender@PLT
 526      00
 527 0447 C745F802 		movl	$2, -8(%rbp)
 527      000000
 528 044e EB14     		jmp	.L45
 529              	.L44:
 136:libusbwrap.c  **** 	libusb_set_debug(m_ctx, debugLevel);
 530              		.loc 3 136 2 is_stmt 1
 531 0450 488B0500 		movq	m_ctx(%rip), %rax
 531      000000
 532 0457 8B55EC   		movl	-20(%rbp), %edx
 533 045a 89D6     		movl	%edx, %esi
 534 045c 4889C7   		movq	%rax, %rdi
 535 045f E8000000 		call	libusb_set_debug@PLT
 535      00
 536              	.L45:
 137:libusbwrap.c  **** cleanup:
 138:libusbwrap.c  **** 	return retVal;
 537              		.loc 3 138 9
 538 0464 8B45F8   		movl	-8(%rbp), %eax
 139:libusbwrap.c  **** }
 539              		.loc 3 139 1
 540 0467 C9       		leave
 541              		.cfi_def_cfa 7, 8
 542 0468 C3       		ret
 543              		.cfi_endproc
 544              	.LFE27:
 546              		.section	.rodata
 547 0025 000000   		.align 8
 548              	.LC2:
 549 0028 75736249 		.string	"usbIsDeviceAvailable(): you forgot to call usbInitialise()!"
 549      73446576 
 549      69636541 
 549      7661696C 
 549      61626C65 
 550              	.LC3:
 551 0064 75736249 		.string	"usbIsDeviceAvailable(): %s"
 551      73446576 
 551      69636541 
 551      7661696C 
 551      61626C65 
 552 007f 00       		.align 8
 553              	.LC4:
 554 0080 75736249 		.string	"usbIsDeviceAvailable(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1
 554      73446576 
 554      69636541 
 554      7661696C 
 554      61626C65 
 555              		.text
 556              		.globl	usbIsDeviceAvailable
 558              	usbIsDeviceAvailable:
 559              	.LFB28:
 140:libusbwrap.c  **** 
 141:libusbwrap.c  **** #define isMatching (thisDevice->descriptor.idVendor == vid && thisDevice->descriptor.idProduct == p
 142:libusbwrap.c  **** 
 143:libusbwrap.c  **** #define FORMAT_ERR "The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602B or 1D
 144:libusbwrap.c  **** 
 145:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 146:libusbwrap.c  **** //
 147:libusbwrap.c  **** DLLEXPORT(USBStatus) usbIsDeviceAvailable(const char *vp, bool *isAvailable, const char **error) {
 560              		.loc 3 147 98
 561              		.cfi_startproc
 562 0469 F30F1EFA 		endbr64
 563 046d 55       		pushq	%rbp
 564              		.cfi_def_cfa_offset 16
 565              		.cfi_offset 6, -16
 566 046e 4889E5   		movq	%rsp, %rbp
 567              		.cfi_def_cfa_register 6
 568 0471 4883EC70 		subq	$112, %rsp
 569 0475 48897DA8 		movq	%rdi, -88(%rbp)
 570 0479 488975A0 		movq	%rsi, -96(%rbp)
 571 047d 48895598 		movq	%rdx, -104(%rbp)
 572              		.loc 3 147 98
 573 0481 64488B04 		movq	%fs:40, %rax
 573      25280000 
 573      00
 574 048a 488945F8 		movq	%rax, -8(%rbp)
 575 048e 31C0     		xorl	%eax, %eax
 148:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 576              		.loc 3 148 12
 577 0490 C745C400 		movl	$0, -60(%rbp)
 577      000000
 149:libusbwrap.c  **** 	struct libusb_device **devList = NULL;
 578              		.loc 3 149 25
 579 0497 48C745D0 		movq	$0, -48(%rbp)
 579      00000000 
 150:libusbwrap.c  **** 	struct libusb_device *thisDev;
 151:libusbwrap.c  **** 	struct libusb_device_descriptor desc;
 152:libusbwrap.c  **** 	uint16 vid, pid, did;
 153:libusbwrap.c  **** 	int status, count;
 154:libusbwrap.c  **** 	CHECK_STATUS(
 580              		.loc 3 154 2
 581 049f 488B0500 		movq	m_ctx(%rip), %rax
 581      000000
 582 04a6 4885C0   		testq	%rax, %rax
 583 04a9 7522     		jne	.L48
 584              		.loc 3 154 2 is_stmt 0 discriminator 1
 585 04ab 488B4598 		movq	-104(%rbp), %rax
 586 04af 488D1500 		leaq	.LC2(%rip), %rdx
 586      000000
 587 04b6 4889D6   		movq	%rdx, %rsi
 588 04b9 4889C7   		movq	%rax, %rdi
 589 04bc E8000000 		call	errPrefix@PLT
 589      00
 590 04c1 C745C402 		movl	$2, -60(%rbp)
 590      000000
 591 04c8 E9B00100 		jmp	.L49
 591      00
 592              	.L48:
 155:libusbwrap.c  **** 		!m_ctx, USB_INIT, cleanup,
 156:libusbwrap.c  **** 		"usbIsDeviceAvailable(): you forgot to call usbInitialise()!");
 157:libusbwrap.c  **** 	count = (int)libusb_get_device_list(m_ctx, &devList);
 593              		.loc 3 157 15 is_stmt 1
 594 04cd 488B0500 		movq	m_ctx(%rip), %rax
 594      000000
 595 04d4 488D55D0 		leaq	-48(%rbp), %rdx
 596 04d8 4889D6   		movq	%rdx, %rsi
 597 04db 4889C7   		movq	%rax, %rdi
 598 04de E8000000 		call	libusb_get_device_list@PLT
 598      00
 599              		.loc 3 157 8
 600 04e3 8945C8   		movl	%eax, -56(%rbp)
 158:libusbwrap.c  **** 	CHECK_STATUS(
 601              		.loc 3 158 2
 602 04e6 837DC800 		cmpl	$0, -56(%rbp)
 603 04ea 7934     		jns	.L50
 604              		.loc 3 158 2 is_stmt 0 discriminator 1
 605 04ec 8B45C8   		movl	-56(%rbp), %eax
 606 04ef 89C7     		movl	%eax, %edi
 607 04f1 E8000000 		call	libusb_error_name@PLT
 607      00
 608 04f6 4889C2   		movq	%rax, %rdx
 609 04f9 488B4598 		movq	-104(%rbp), %rax
 610 04fd 488D0D00 		leaq	.LC3(%rip), %rcx
 610      000000
 611 0504 4889CE   		movq	%rcx, %rsi
 612 0507 4889C7   		movq	%rax, %rdi
 613 050a B8000000 		movl	$0, %eax
 613      00
 614 050f E8000000 		call	errRender@PLT
 614      00
 615 0514 C745C405 		movl	$5, -60(%rbp)
 615      000000
 616 051b E95D0100 		jmp	.L49
 616      00
 617              	.L50:
 159:libusbwrap.c  **** 		count < 0, USB_CANNOT_OPEN_DEVICE, cleanup,
 160:libusbwrap.c  **** 		"usbIsDeviceAvailable(): %s", libusb_error_name(count));
 161:libusbwrap.c  **** 	CHECK_STATUS(
 618              		.loc 3 161 2 is_stmt 1
 619 0520 488B45A8 		movq	-88(%rbp), %rax
 620 0524 4889C7   		movq	%rax, %rdi
 621 0527 E8000000 		call	usbValidateVidPid@PLT
 621      00
 622 052c 83F001   		xorl	$1, %eax
 623 052f 84C0     		testb	%al, %al
 624 0531 742B     		je	.L51
 625              		.loc 3 161 2 is_stmt 0 discriminator 1
 626 0533 488B55A8 		movq	-88(%rbp), %rdx
 627 0537 488B4598 		movq	-104(%rbp), %rax
 628 053b 488D0D00 		leaq	.LC4(%rip), %rcx
 628      000000
 629 0542 4889CE   		movq	%rcx, %rsi
 630 0545 4889C7   		movq	%rax, %rdi
 631 0548 B8000000 		movl	$0, %eax
 631      00
 632 054d E8000000 		call	errRender@PLT
 632      00
 633 0552 C745C401 		movl	$1, -60(%rbp)
 633      000000
 634 0559 E91F0100 		jmp	.L49
 634      00
 635              	.L51:
 162:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, cleanup,
 163:libusbwrap.c  **** 		"usbIsDeviceAvailable(): "FORMAT_ERR, vp);
 164:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 636              		.loc 3 164 16 is_stmt 1
 637 055e 488B45A8 		movq	-88(%rbp), %rax
 638 0562 BA100000 		movl	$16, %edx
 638      00
 639 0567 BE000000 		movl	$0, %esi
 639      00
 640 056c 4889C7   		movq	%rax, %rdi
 641 056f E8000000 		call	strtoul@PLT
 641      00
 642              		.loc 3 164 6
 643 0574 668945BE 		movw	%ax, -66(%rbp)
 165:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 644              		.loc 3 165 16
 645 0578 488B45A8 		movq	-88(%rbp), %rax
 646 057c 4883C005 		addq	$5, %rax
 647 0580 BA100000 		movl	$16, %edx
 647      00
 648 0585 BE000000 		movl	$0, %esi
 648      00
 649 058a 4889C7   		movq	%rax, %rdi
 650 058d E8000000 		call	strtoul@PLT
 650      00
 651              		.loc 3 165 6
 652 0592 668945C0 		movw	%ax, -64(%rbp)
 166:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 653              		.loc 3 166 18
 654 0596 488B45A8 		movq	-88(%rbp), %rax
 655 059a 4889C7   		movq	%rax, %rdi
 656 059d E8000000 		call	strlen@PLT
 656      00
 657              		.loc 3 166 8
 658 05a2 4883F80E 		cmpq	$14, %rax
 659 05a6 751C     		jne	.L52
 660              		.loc 3 166 38 discriminator 1
 661 05a8 488B45A8 		movq	-88(%rbp), %rax
 662 05ac 4883C00A 		addq	$10, %rax
 663 05b0 BA100000 		movl	$16, %edx
 663      00
 664 05b5 BE000000 		movl	$0, %esi
 664      00
 665 05ba 4889C7   		movq	%rax, %rdi
 666 05bd E8000000 		call	strtoul@PLT
 666      00
 667 05c2 EB05     		jmp	.L53
 668              	.L52:
 669              		.loc 3 166 8 discriminator 2
 670 05c4 B8000000 		movl	$0, %eax
 670      00
 671              	.L53:
 672              		.loc 3 166 6 discriminator 4
 673 05c9 668945C2 		movw	%ax, -62(%rbp)
 167:libusbwrap.c  **** 	*isAvailable = false;
 674              		.loc 3 167 15 discriminator 4
 675 05cd 488B45A0 		movq	-96(%rbp), %rax
 676 05d1 C60000   		movb	$0, (%rax)
 168:libusbwrap.c  **** 	while ( count-- ) {
 677              		.loc 3 168 8 discriminator 4
 678 05d4 E9920000 		jmp	.L54
 678      00
 679              	.L57:
 169:libusbwrap.c  **** 		thisDev = devList[count];
 680              		.loc 3 169 20
 681 05d9 488B55D0 		movq	-48(%rbp), %rdx
 682 05dd 8B45C8   		movl	-56(%rbp), %eax
 683 05e0 4898     		cltq
 684 05e2 48C1E003 		salq	$3, %rax
 685 05e6 4801D0   		addq	%rdx, %rax
 686              		.loc 3 169 11
 687 05e9 488B00   		movq	(%rax), %rax
 688 05ec 488945D8 		movq	%rax, -40(%rbp)
 170:libusbwrap.c  **** 		status = libusb_get_device_descriptor(thisDev, &desc);
 689              		.loc 3 170 12
 690 05f0 488D55E0 		leaq	-32(%rbp), %rdx
 691 05f4 488B45D8 		movq	-40(%rbp), %rax
 692 05f8 4889D6   		movq	%rdx, %rsi
 693 05fb 4889C7   		movq	%rax, %rdi
 694 05fe E8000000 		call	libusb_get_device_descriptor@PLT
 694      00
 695 0603 8945CC   		movl	%eax, -52(%rbp)
 171:libusbwrap.c  **** 		CHECK_STATUS(
 696              		.loc 3 171 3
 697 0606 837DCC00 		cmpl	$0, -52(%rbp)
 698 060a 7431     		je	.L55
 699              		.loc 3 171 3 is_stmt 0 discriminator 1
 700 060c 8B45CC   		movl	-52(%rbp), %eax
 701 060f 89C7     		movl	%eax, %edi
 702 0611 E8000000 		call	libusb_error_name@PLT
 702      00
 703 0616 4889C2   		movq	%rax, %rdx
 704 0619 488B4598 		movq	-104(%rbp), %rax
 705 061d 488D0D00 		leaq	.LC3(%rip), %rcx
 705      000000
 706 0624 4889CE   		movq	%rcx, %rsi
 707 0627 4889C7   		movq	%rax, %rdi
 708 062a B8000000 		movl	$0, %eax
 708      00
 709 062f E8000000 		call	errRender@PLT
 709      00
 710 0634 C745C409 		movl	$9, -60(%rbp)
 710      000000
 711 063b EB40     		jmp	.L49
 712              	.L55:
 172:libusbwrap.c  **** 			status, USB_CANNOT_GET_DESCRIPTOR, cleanup,
 173:libusbwrap.c  **** 			"usbIsDeviceAvailable(): %s", libusb_error_name(status));
 174:libusbwrap.c  **** 		if (
 175:libusbwrap.c  **** 			desc.idVendor == vid &&
 713              		.loc 3 175 8 is_stmt 1
 714 063d 0FB745E8 		movzwl	-24(%rbp), %eax
 174:libusbwrap.c  **** 			desc.idVendor == vid &&
 715              		.loc 3 174 6
 716 0641 663945BE 		cmpw	%ax, -66(%rbp)
 717 0645 7524     		jne	.L54
 176:libusbwrap.c  **** 			desc.idProduct == pid &&
 718              		.loc 3 176 8
 719 0647 0FB745EA 		movzwl	-22(%rbp), %eax
 175:libusbwrap.c  **** 			desc.idProduct == pid &&
 720              		.loc 3 175 25
 721 064b 663945C0 		cmpw	%ax, -64(%rbp)
 722 064f 751A     		jne	.L54
 723              		.loc 3 176 26
 724 0651 66837DC2 		cmpw	$0, -62(%rbp)
 724      00
 725 0656 740A     		je	.L56
 177:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 726              		.loc 3 177 26
 727 0658 0FB745EC 		movzwl	-20(%rbp), %eax
 728              		.loc 3 177 19
 729 065c 663945C2 		cmpw	%ax, -62(%rbp)
 730 0660 7509     		jne	.L54
 731              	.L56:
 178:libusbwrap.c  **** 		) {
 179:libusbwrap.c  **** 			*isAvailable = true;
 732              		.loc 3 179 17
 733 0662 488B45A0 		movq	-96(%rbp), %rax
 734 0666 C60001   		movb	$1, (%rax)
 180:libusbwrap.c  **** 			break;
 735              		.loc 3 180 4
 736 0669 EB12     		jmp	.L49
 737              	.L54:
 168:libusbwrap.c  **** 		thisDev = devList[count];
 738              		.loc 3 168 15
 739 066b 8B45C8   		movl	-56(%rbp), %eax
 740 066e 8D50FF   		leal	-1(%rax), %edx
 741 0671 8955C8   		movl	%edx, -56(%rbp)
 168:libusbwrap.c  **** 		thisDev = devList[count];
 742              		.loc 3 168 10
 743 0674 85C0     		testl	%eax, %eax
 744 0676 0F855DFF 		jne	.L57
 744      FFFF
 181:libusbwrap.c  **** 		}
 182:libusbwrap.c  **** 	}
 183:libusbwrap.c  **** cleanup:
 745              		.loc 3 183 1
 746 067c 90       		nop
 747              	.L49:
 184:libusbwrap.c  **** 	libusb_free_device_list(devList, 1);
 748              		.loc 3 184 2
 749 067d 488B45D0 		movq	-48(%rbp), %rax
 750 0681 BE010000 		movl	$1, %esi
 750      00
 751 0686 4889C7   		movq	%rax, %rdi
 752 0689 E8000000 		call	libusb_free_device_list@PLT
 752      00
 185:libusbwrap.c  **** 	return retVal;
 753              		.loc 3 185 9
 754 068e 8B45C4   		movl	-60(%rbp), %eax
 186:libusbwrap.c  **** }
 755              		.loc 3 186 1
 756 0691 488B55F8 		movq	-8(%rbp), %rdx
 757 0695 64482B14 		subq	%fs:40, %rdx
 757      25280000 
 757      00
 758 069e 7405     		je	.L59
 759 06a0 E8000000 		call	__stack_chk_fail@PLT
 759      00
 760              	.L59:
 761 06a5 C9       		leave
 762              		.cfi_def_cfa 7, 8
 763 06a6 C3       		ret
 764              		.cfi_endproc
 765              	.LFE28:
 767              		.globl	createTransfer
 769              	createTransfer:
 770              	.LFB29:
 187:libusbwrap.c  **** 
 188:libusbwrap.c  **** struct TransferWrapper {
 189:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 190:libusbwrap.c  **** 	int completed;
 191:libusbwrap.c  **** 	struct AsyncTransferFlags flags;
 192:libusbwrap.c  **** 	uint8 buffer[0x10000];  // can use this...
 193:libusbwrap.c  **** 	uint8 *bufPtr;          // ...or this.
 194:libusbwrap.c  **** };
 195:libusbwrap.c  **** struct TransferWrapper *createTransfer(void) {
 771              		.loc 3 195 46
 772              		.cfi_startproc
 773 06a7 F30F1EFA 		endbr64
 774 06ab 55       		pushq	%rbp
 775              		.cfi_def_cfa_offset 16
 776              		.cfi_offset 6, -16
 777 06ac 4889E5   		movq	%rsp, %rbp
 778              		.cfi_def_cfa_register 6
 779 06af 4883EC10 		subq	$16, %rsp
 196:libusbwrap.c  **** 	struct TransferWrapper *retVal = (struct TransferWrapper *)calloc(1, sizeof(struct TransferWrapper
 780              		.loc 3 196 61
 781 06b3 BE180001 		movl	$65560, %esi
 781      00
 782 06b8 BF010000 		movl	$1, %edi
 782      00
 783 06bd E8000000 		call	calloc@PLT
 783      00
 784 06c2 488945F8 		movq	%rax, -8(%rbp)
 197:libusbwrap.c  **** 	CHECK_STATUS(retVal == NULL, NULL, exit);
 785              		.loc 3 197 2
 786 06c6 48837DF8 		cmpq	$0, -8(%rbp)
 786      00
 787 06cb 750A     		jne	.L61
 788              		.loc 3 197 2 is_stmt 0 discriminator 1
 789 06cd 48C745F8 		movq	$0, -8(%rbp)
 789      00000000 
 790 06d5 EB39     		jmp	.L62
 791              	.L61:
 198:libusbwrap.c  **** 	retVal->transfer = libusb_alloc_transfer(0);
 792              		.loc 3 198 21 is_stmt 1
 793 06d7 BF000000 		movl	$0, %edi
 793      00
 794 06dc E8000000 		call	libusb_alloc_transfer@PLT
 794      00
 795              		.loc 3 198 19
 796 06e1 488B55F8 		movq	-8(%rbp), %rdx
 797 06e5 488902   		movq	%rax, (%rdx)
 199:libusbwrap.c  **** 	CHECK_STATUS(retVal->transfer == NULL, NULL, freeWrap);
 798              		.loc 3 199 2
 799 06e8 488B45F8 		movq	-8(%rbp), %rax
 800 06ec 488B00   		movq	(%rax), %rax
 801 06ef 4885C0   		testq	%rax, %rax
 802 06f2 7516     		jne	.L63
 803              		.loc 3 199 2 is_stmt 0 discriminator 1
 804 06f4 48C745F8 		movq	$0, -8(%rbp)
 804      00000000 
 805              	.L64:
 200:libusbwrap.c  **** 	return retVal;
 201:libusbwrap.c  **** freeWrap:
 202:libusbwrap.c  **** 	free((void*)retVal);
 806              		.loc 3 202 2 is_stmt 1 discriminator 1
 807 06fc 488B45F8 		movq	-8(%rbp), %rax
 808 0700 4889C7   		movq	%rax, %rdi
 809 0703 E8000000 		call	free@PLT
 809      00
 810 0708 EB06     		jmp	.L62
 811              	.L63:
 200:libusbwrap.c  **** 	return retVal;
 812              		.loc 3 200 9
 813 070a 488B45F8 		movq	-8(%rbp), %rax
 814 070e EB05     		jmp	.L65
 815              	.L62:
 203:libusbwrap.c  **** exit:
 204:libusbwrap.c  **** 	return NULL;
 816              		.loc 3 204 9
 817 0710 B8000000 		movl	$0, %eax
 817      00
 818              	.L65:
 205:libusbwrap.c  **** }
 819              		.loc 3 205 1
 820 0715 C9       		leave
 821              		.cfi_def_cfa 7, 8
 822 0716 C3       		ret
 823              		.cfi_endproc
 824              	.LFE29:
 827              	destroyTransfer:
 828              	.LFB30:
 206:libusbwrap.c  **** 
 207:libusbwrap.c  **** static void destroyTransfer(struct TransferWrapper *tx) {
 829              		.loc 3 207 57
 830              		.cfi_startproc
 831 0717 F30F1EFA 		endbr64
 832 071b 55       		pushq	%rbp
 833              		.cfi_def_cfa_offset 16
 834              		.cfi_offset 6, -16
 835 071c 4889E5   		movq	%rsp, %rbp
 836              		.cfi_def_cfa_register 6
 837 071f 4883EC10 		subq	$16, %rsp
 838 0723 48897DF8 		movq	%rdi, -8(%rbp)
 208:libusbwrap.c  **** 	if ( tx ) {
 839              		.loc 3 208 5
 840 0727 48837DF8 		cmpq	$0, -8(%rbp)
 840      00
 841 072c 741B     		je	.L68
 209:libusbwrap.c  **** 		libusb_free_transfer(tx->transfer);
 842              		.loc 3 209 3
 843 072e 488B45F8 		movq	-8(%rbp), %rax
 844 0732 488B00   		movq	(%rax), %rax
 845 0735 4889C7   		movq	%rax, %rdi
 846 0738 E8000000 		call	libusb_free_transfer@PLT
 846      00
 210:libusbwrap.c  **** 		free((void*)tx);
 847              		.loc 3 210 3
 848 073d 488B45F8 		movq	-8(%rbp), %rax
 849 0741 4889C7   		movq	%rax, %rdi
 850 0744 E8000000 		call	free@PLT
 850      00
 851              	.L68:
 211:libusbwrap.c  **** 	}
 212:libusbwrap.c  **** }
 852              		.loc 3 212 1
 853 0749 90       		nop
 854 074a C9       		leave
 855              		.cfi_def_cfa 7, 8
 856 074b C3       		ret
 857              		.cfi_endproc
 858              	.LFE30:
 860              		.section	.rodata
 861 00f2 00000000 		.align 8
 861      0000
 862              	.LC5:
 863 00f8 7573624F 		.string	"usbOpenDevice(): you forgot to call usbInitialise()!"
 863      70656E44 
 863      65766963 
 863      6528293A 
 863      20796F75 
 864 012d 000000   		.align 8
 865              	.LC6:
 866 0130 7573624F 		.string	"usbOpenDevice(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602
 866      70656E44 
 866      65766963 
 866      6528293A 
 866      20546865 
 867 019b 00000000 		.align 8
 867      00
 868              	.LC7:
 869 01a0 7573624F 		.string	"usbOpenDevice(): Out of memory!"
 869      70656E44 
 869      65766963 
 869      6528293A 
 869      204F7574 
 870              	.LC8:
 871 01c0 7573624F 		.string	"usbOpenDevice()"
 871      70656E44 
 871      65766963 
 871      65282900 
 872              	.LC9:
 873 01d0 7573624F 		.string	"usbOpenDevice(): %s"
 873      70656E44 
 873      65766963 
 873      6528293A 
 873      20257300 
 874              		.text
 875              		.globl	usbOpenDevice
 877              	usbOpenDevice:
 878              	.LFB31:
 213:libusbwrap.c  **** 
 214:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 215:libusbwrap.c  **** //
 216:libusbwrap.c  **** DLLEXPORT(USBStatus) usbOpenDevice(
 217:libusbwrap.c  **** 	const char *vp, int configuration, int iface, int altSetting,
 218:libusbwrap.c  **** 	struct USBDevice **devHandlePtr, const char **error)
 219:libusbwrap.c  **** {
 879              		.loc 3 219 1
 880              		.cfi_startproc
 881 074c F30F1EFA 		endbr64
 882 0750 55       		pushq	%rbp
 883              		.cfi_def_cfa_offset 16
 884              		.cfi_offset 6, -16
 885 0751 4889E5   		movq	%rsp, %rbp
 886              		.cfi_def_cfa_register 6
 887 0754 4883EC50 		subq	$80, %rsp
 888 0758 48897DD8 		movq	%rdi, -40(%rbp)
 889 075c 8975D4   		movl	%esi, -44(%rbp)
 890 075f 8955D0   		movl	%edx, -48(%rbp)
 891 0762 894DCC   		movl	%ecx, -52(%rbp)
 892 0765 4C8945C0 		movq	%r8, -64(%rbp)
 893 0769 4C894DB8 		movq	%r9, -72(%rbp)
 220:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 894              		.loc 3 220 12
 895 076d C745E800 		movl	$0, -24(%rbp)
 895      000000
 221:libusbwrap.c  **** 	uint16 vid, pid, did;
 222:libusbwrap.c  **** 	int status;
 223:libusbwrap.c  **** 	struct USBDevice *newWrapper;
 224:libusbwrap.c  **** 	struct libusb_device_handle *newHandle;
 225:libusbwrap.c  **** 	CHECK_STATUS(
 896              		.loc 3 225 2
 897 0774 488B0500 		movq	m_ctx(%rip), %rax
 897      000000
 898 077b 4885C0   		testq	%rax, %rax
 899 077e 7522     		jne	.L70
 900              		.loc 3 225 2 is_stmt 0 discriminator 1
 901 0780 488B45B8 		movq	-72(%rbp), %rax
 902 0784 488D1500 		leaq	.LC5(%rip), %rdx
 902      000000
 903 078b 4889D6   		movq	%rdx, %rsi
 904 078e 4889C7   		movq	%rax, %rdi
 905 0791 E8000000 		call	errPrefix@PLT
 905      00
 906 0796 C745E802 		movl	$2, -24(%rbp)
 906      000000
 907 079d E9C10200 		jmp	.L71
 907      00
 908              	.L70:
 226:libusbwrap.c  **** 		!m_ctx, USB_INIT, exit,
 227:libusbwrap.c  **** 		"usbOpenDevice(): you forgot to call usbInitialise()!");
 228:libusbwrap.c  **** 	CHECK_STATUS(
 909              		.loc 3 228 2 is_stmt 1
 910 07a2 488B45D8 		movq	-40(%rbp), %rax
 911 07a6 4889C7   		movq	%rax, %rdi
 912 07a9 E8000000 		call	usbValidateVidPid@PLT
 912      00
 913 07ae 83F001   		xorl	$1, %eax
 914 07b1 84C0     		testb	%al, %al
 915 07b3 742B     		je	.L72
 916              		.loc 3 228 2 is_stmt 0 discriminator 1
 917 07b5 488B55D8 		movq	-40(%rbp), %rdx
 918 07b9 488B45B8 		movq	-72(%rbp), %rax
 919 07bd 488D0D00 		leaq	.LC6(%rip), %rcx
 919      000000
 920 07c4 4889CE   		movq	%rcx, %rsi
 921 07c7 4889C7   		movq	%rax, %rdi
 922 07ca B8000000 		movl	$0, %eax
 922      00
 923 07cf E8000000 		call	errRender@PLT
 923      00
 924 07d4 C745E801 		movl	$1, -24(%rbp)
 924      000000
 925 07db E9830200 		jmp	.L71
 925      00
 926              	.L72:
 229:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, exit,
 230:libusbwrap.c  **** 		"usbOpenDevice(): "FORMAT_ERR, vp);
 231:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 927              		.loc 3 231 16 is_stmt 1
 928 07e0 488B45D8 		movq	-40(%rbp), %rax
 929 07e4 BA100000 		movl	$16, %edx
 929      00
 930 07e9 BE000000 		movl	$0, %esi
 930      00
 931 07ee 4889C7   		movq	%rax, %rdi
 932 07f1 E8000000 		call	strtoul@PLT
 932      00
 933              		.loc 3 231 6
 934 07f6 668945E2 		movw	%ax, -30(%rbp)
 232:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 935              		.loc 3 232 16
 936 07fa 488B45D8 		movq	-40(%rbp), %rax
 937 07fe 4883C005 		addq	$5, %rax
 938 0802 BA100000 		movl	$16, %edx
 938      00
 939 0807 BE000000 		movl	$0, %esi
 939      00
 940 080c 4889C7   		movq	%rax, %rdi
 941 080f E8000000 		call	strtoul@PLT
 941      00
 942              		.loc 3 232 6
 943 0814 668945E4 		movw	%ax, -28(%rbp)
 233:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 944              		.loc 3 233 18
 945 0818 488B45D8 		movq	-40(%rbp), %rax
 946 081c 4889C7   		movq	%rax, %rdi
 947 081f E8000000 		call	strlen@PLT
 947      00
 948              		.loc 3 233 8
 949 0824 4883F80E 		cmpq	$14, %rax
 950 0828 751C     		jne	.L73
 951              		.loc 3 233 38 discriminator 1
 952 082a 488B45D8 		movq	-40(%rbp), %rax
 953 082e 4883C00A 		addq	$10, %rax
 954 0832 BA100000 		movl	$16, %edx
 954      00
 955 0837 BE000000 		movl	$0, %esi
 955      00
 956 083c 4889C7   		movq	%rax, %rdi
 957 083f E8000000 		call	strtoul@PLT
 957      00
 958 0844 EB05     		jmp	.L74
 959              	.L73:
 960              		.loc 3 233 8 discriminator 2
 961 0846 B8000000 		movl	$0, %eax
 961      00
 962              	.L74:
 963              		.loc 3 233 6 discriminator 4
 964 084b 668945E6 		movw	%ax, -26(%rbp)
 234:libusbwrap.c  **** 	newWrapper = (struct USBDevice *)malloc(sizeof(struct USBDevice));
 965              		.loc 3 234 35 discriminator 4
 966 084f BF400000 		movl	$64, %edi
 966      00
 967 0854 E8000000 		call	malloc@PLT
 967      00
 968 0859 488945F0 		movq	%rax, -16(%rbp)
 235:libusbwrap.c  **** 	CHECK_STATUS(newWrapper == NULL, USB_ALLOC_ERR, exit, "usbOpenDevice(): Out of memory!");
 969              		.loc 3 235 2 discriminator 4
 970 085d 48837DF0 		cmpq	$0, -16(%rbp)
 970      00
 971 0862 7522     		jne	.L75
 972              		.loc 3 235 2 is_stmt 0 discriminator 1
 973 0864 488B45B8 		movq	-72(%rbp), %rax
 974 0868 488D1500 		leaq	.LC7(%rip), %rdx
 974      000000
 975 086f 4889D6   		movq	%rdx, %rsi
 976 0872 4889C7   		movq	%rax, %rdi
 977 0875 E8000000 		call	errPrefix@PLT
 977      00
 978 087a C745E80C 		movl	$12, -24(%rbp)
 978      000000
 979 0881 E9DD0100 		jmp	.L71
 979      00
 980              	.L75:
 236:libusbwrap.c  **** 	status = queueInit(&newWrapper->queue, 4, (CreateFunc)createTransfer, (DestroyFunc)destroyTransfer
 981              		.loc 3 236 11 is_stmt 1
 982 0886 488B45F0 		movq	-16(%rbp), %rax
 983 088a 4883C008 		addq	$8, %rax
 984 088e 488D1582 		leaq	destroyTransfer(%rip), %rdx
 984      FEFFFF
 985 0895 4889D1   		movq	%rdx, %rcx
 986 0898 488B1500 		movq	createTransfer@GOTPCREL(%rip), %rdx
 986      000000
 987 089f BE040000 		movl	$4, %esi
 987      00
 988 08a4 4889C7   		movq	%rax, %rdi
 989 08a7 E8000000 		call	queueInit@PLT
 989      00
 990              		.loc 3 236 9
 991 08ac 8945EC   		movl	%eax, -20(%rbp)
 237:libusbwrap.c  **** 	CHECK_STATUS(status, USB_ALLOC_ERR, freeWrap, "usbOpenDevice(): Out of memory!");
 992              		.loc 3 237 2
 993 08af 837DEC00 		cmpl	$0, -20(%rbp)
 994 08b3 7422     		je	.L76
 995              		.loc 3 237 2 is_stmt 0 discriminator 1
 996 08b5 488B45B8 		movq	-72(%rbp), %rax
 997 08b9 488D1500 		leaq	.LC7(%rip), %rdx
 997      000000
 998 08c0 4889D6   		movq	%rdx, %rsi
 999 08c3 4889C7   		movq	%rax, %rdi
 1000 08c6 E8000000 		call	errPrefix@PLT
 1000      00
 1001 08cb C745E80C 		movl	$12, -24(%rbp)
 1001      000000
 1002 08d2 E9800100 		jmp	.L77
 1002      00
 1003              	.L76:
 238:libusbwrap.c  **** 	newHandle = libusbOpenWithVidPid(m_ctx, vid, pid, did, error);
 1004              		.loc 3 238 14 is_stmt 1
 1005 08d7 0FB74DE6 		movzwl	-26(%rbp), %ecx
 1006 08db 0FB755E4 		movzwl	-28(%rbp), %edx
 1007 08df 0FB775E2 		movzwl	-30(%rbp), %esi
 1008 08e3 488B0500 		movq	m_ctx(%rip), %rax
 1008      000000
 1009 08ea 488B7DB8 		movq	-72(%rbp), %rdi
 1010 08ee 4989F8   		movq	%rdi, %r8
 1011 08f1 4889C7   		movq	%rax, %rdi
 1012 08f4 E88FF7FF 		call	libusbOpenWithVidPid
 1012      FF
 1013 08f9 488945F8 		movq	%rax, -8(%rbp)
 239:libusbwrap.c  **** 	CHECK_STATUS(!newHandle, USB_CANNOT_OPEN_DEVICE, freeQueue, "usbOpenDevice()");
 1014              		.loc 3 239 2
 1015 08fd 48837DF8 		cmpq	$0, -8(%rbp)
 1015      00
 1016 0902 7522     		jne	.L78
 1017              		.loc 3 239 2 is_stmt 0 discriminator 1
 1018 0904 488B45B8 		movq	-72(%rbp), %rax
 1019 0908 488D1500 		leaq	.LC8(%rip), %rdx
 1019      000000
 1020 090f 4889D6   		movq	%rdx, %rsi
 1021 0912 4889C7   		movq	%rax, %rdi
 1022 0915 E8000000 		call	errPrefix@PLT
 1022      00
 1023 091a C745E805 		movl	$5, -24(%rbp)
 1023      000000
 1024 0921 E9210100 		jmp	.L79
 1024      00
 1025              	.L78:
 240:libusbwrap.c  **** 	status = libusb_set_configuration(newHandle, configuration);
 1026              		.loc 3 240 11 is_stmt 1
 1027 0926 8B55D4   		movl	-44(%rbp), %edx
 1028 0929 488B45F8 		movq	-8(%rbp), %rax
 1029 092d 89D6     		movl	%edx, %esi
 1030 092f 4889C7   		movq	%rax, %rdi
 1031 0932 E8000000 		call	libusb_set_configuration@PLT
 1031      00
 1032 0937 8945EC   		movl	%eax, -20(%rbp)
 241:libusbwrap.c  **** 	CHECK_STATUS(
 1033              		.loc 3 241 2
 1034 093a 837DEC00 		cmpl	$0, -20(%rbp)
 1035 093e 7934     		jns	.L80
 1036              		.loc 3 241 2 is_stmt 0 discriminator 1
 1037 0940 8B45EC   		movl	-20(%rbp), %eax
 1038 0943 89C7     		movl	%eax, %edi
 1039 0945 E8000000 		call	libusb_error_name@PLT
 1039      00
 1040 094a 4889C2   		movq	%rax, %rdx
 1041 094d 488B45B8 		movq	-72(%rbp), %rax
 1042 0951 488D0D00 		leaq	.LC9(%rip), %rcx
 1042      000000
 1043 0958 4889CE   		movq	%rcx, %rsi
 1044 095b 4889C7   		movq	%rax, %rdi
 1045 095e B8000000 		movl	$0, %eax
 1045      00
 1046 0963 E8000000 		call	errRender@PLT
 1046      00
 1047 0968 C745E806 		movl	$6, -24(%rbp)
 1047      000000
 1048 096f E9C70000 		jmp	.L81
 1048      00
 1049              	.L80:
 242:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_CONFIGURATION, closeDev,
 243:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 244:libusbwrap.c  **** 	status = libusb_claim_interface(newHandle, iface);
 1050              		.loc 3 244 11 is_stmt 1
 1051 0974 8B55D0   		movl	-48(%rbp), %edx
 1052 0977 488B45F8 		movq	-8(%rbp), %rax
 1053 097b 89D6     		movl	%edx, %esi
 1054 097d 4889C7   		movq	%rax, %rdi
 1055 0980 E8000000 		call	libusb_claim_interface@PLT
 1055      00
 1056 0985 8945EC   		movl	%eax, -20(%rbp)
 245:libusbwrap.c  **** 	CHECK_STATUS(
 1057              		.loc 3 245 2
 1058 0988 837DEC00 		cmpl	$0, -20(%rbp)
 1059 098c 7931     		jns	.L82
 1060              		.loc 3 245 2 is_stmt 0 discriminator 1
 1061 098e 8B45EC   		movl	-20(%rbp), %eax
 1062 0991 89C7     		movl	%eax, %edi
 1063 0993 E8000000 		call	libusb_error_name@PLT
 1063      00
 1064 0998 4889C2   		movq	%rax, %rdx
 1065 099b 488B45B8 		movq	-72(%rbp), %rax
 1066 099f 488D0D00 		leaq	.LC9(%rip), %rcx
 1066      000000
 1067 09a6 4889CE   		movq	%rcx, %rsi
 1068 09a9 4889C7   		movq	%rax, %rdi
 1069 09ac B8000000 		movl	$0, %eax
 1069      00
 1070 09b1 E8000000 		call	errRender@PLT
 1070      00
 1071 09b6 C745E807 		movl	$7, -24(%rbp)
 1071      000000
 1072 09bd EB7C     		jmp	.L81
 1073              	.L82:
 246:libusbwrap.c  **** 		status < 0, USB_CANNOT_CLAIM_INTERFACE, closeDev,
 247:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 248:libusbwrap.c  **** 	status = libusb_set_interface_alt_setting(newHandle, iface, altSetting);
 1074              		.loc 3 248 11 is_stmt 1
 1075 09bf 8B55CC   		movl	-52(%rbp), %edx
 1076 09c2 8B4DD0   		movl	-48(%rbp), %ecx
 1077 09c5 488B45F8 		movq	-8(%rbp), %rax
 1078 09c9 89CE     		movl	%ecx, %esi
 1079 09cb 4889C7   		movq	%rax, %rdi
 1080 09ce E8000000 		call	libusb_set_interface_alt_setting@PLT
 1080      00
 1081 09d3 8945EC   		movl	%eax, -20(%rbp)
 249:libusbwrap.c  **** 	CHECK_STATUS(
 1082              		.loc 3 249 2
 1083 09d6 837DEC00 		cmpl	$0, -20(%rbp)
 1084 09da 7942     		jns	.L83
 1085              		.loc 3 249 2 is_stmt 0 discriminator 1
 1086 09dc 8B45EC   		movl	-20(%rbp), %eax
 1087 09df 89C7     		movl	%eax, %edi
 1088 09e1 E8000000 		call	libusb_error_name@PLT
 1088      00
 1089 09e6 4889C2   		movq	%rax, %rdx
 1090 09e9 488B45B8 		movq	-72(%rbp), %rax
 1091 09ed 488D0D00 		leaq	.LC9(%rip), %rcx
 1091      000000
 1092 09f4 4889CE   		movq	%rcx, %rsi
 1093 09f7 4889C7   		movq	%rax, %rdi
 1094 09fa B8000000 		movl	$0, %eax
 1094      00
 1095 09ff E8000000 		call	errRender@PLT
 1095      00
 1096 0a04 C745E808 		movl	$8, -24(%rbp)
 1096      000000
 1097              	.L84:
 250:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_ALTINT, release,
 251:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 252:libusbwrap.c  **** 	newWrapper->handle = newHandle;	
 253:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 254:libusbwrap.c  **** 	return USB_SUCCESS;
 255:libusbwrap.c  **** release:
 256:libusbwrap.c  **** 	libusb_release_interface(newHandle, iface);
 1098              		.loc 3 256 2 is_stmt 1 discriminator 1
 1099 0a0b 8B55D0   		movl	-48(%rbp), %edx
 1100 0a0e 488B45F8 		movq	-8(%rbp), %rax
 1101 0a12 89D6     		movl	%edx, %esi
 1102 0a14 4889C7   		movq	%rax, %rdi
 1103 0a17 E8000000 		call	libusb_release_interface@PLT
 1103      00
 1104 0a1c EB1D     		jmp	.L81
 1105              	.L83:
 252:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 1106              		.loc 3 252 21
 1107 0a1e 488B45F0 		movq	-16(%rbp), %rax
 1108 0a22 488B55F8 		movq	-8(%rbp), %rdx
 1109 0a26 488910   		movq	%rdx, (%rax)
 253:libusbwrap.c  **** 	return USB_SUCCESS;
 1110              		.loc 3 253 16
 1111 0a29 488B45C0 		movq	-64(%rbp), %rax
 1112 0a2d 488B55F0 		movq	-16(%rbp), %rdx
 1113 0a31 488910   		movq	%rdx, (%rax)
 254:libusbwrap.c  **** release:
 1114              		.loc 3 254 9
 1115 0a34 B8000000 		movl	$0, %eax
 1115      00
 1116 0a39 EB36     		jmp	.L85
 1117              	.L81:
 257:libusbwrap.c  **** closeDev:
 258:libusbwrap.c  **** 	libusb_close(newHandle);	
 1118              		.loc 3 258 2
 1119 0a3b 488B45F8 		movq	-8(%rbp), %rax
 1120 0a3f 4889C7   		movq	%rax, %rdi
 1121 0a42 E8000000 		call	libusb_close@PLT
 1121      00
 1122              	.L79:
 259:libusbwrap.c  **** freeQueue:
 260:libusbwrap.c  **** 	queueDestroy(&newWrapper->queue);
 1123              		.loc 3 260 2
 1124 0a47 488B45F0 		movq	-16(%rbp), %rax
 1125 0a4b 4883C008 		addq	$8, %rax
 1126 0a4f 4889C7   		movq	%rax, %rdi
 1127 0a52 E8000000 		call	queueDestroy@PLT
 1127      00
 1128              	.L77:
 261:libusbwrap.c  **** freeWrap:
 262:libusbwrap.c  **** 	free((void*)newWrapper);
 1129              		.loc 3 262 2
 1130 0a57 488B45F0 		movq	-16(%rbp), %rax
 1131 0a5b 4889C7   		movq	%rax, %rdi
 1132 0a5e E8000000 		call	free@PLT
 1132      00
 1133              	.L71:
 263:libusbwrap.c  **** exit:
 264:libusbwrap.c  **** 	*devHandlePtr = NULL;
 1134              		.loc 3 264 16
 1135 0a63 488B45C0 		movq	-64(%rbp), %rax
 1136 0a67 48C70000 		movq	$0, (%rax)
 1136      000000
 265:libusbwrap.c  **** 	return retVal;
 1137              		.loc 3 265 9
 1138 0a6e 8B45E8   		movl	-24(%rbp), %eax
 1139              	.L85:
 266:libusbwrap.c  **** }
 1140              		.loc 3 266 1
 1141 0a71 C9       		leave
 1142              		.cfi_def_cfa 7, 8
 1143 0a72 C3       		ret
 1144              		.cfi_endproc
 1145              	.LFE31:
 1147              		.globl	usbCloseDevice
 1149              	usbCloseDevice:
 1150              	.LFB32:
 267:libusbwrap.c  **** 
 268:libusbwrap.c  **** DLLEXPORT(void) usbCloseDevice(struct USBDevice *dev, int iface) {
 1151              		.loc 3 268 66
 1152              		.cfi_startproc
 1153 0a73 F30F1EFA 		endbr64
 1154 0a77 55       		pushq	%rbp
 1155              		.cfi_def_cfa_offset 16
 1156              		.cfi_offset 6, -16
 1157 0a78 4889E5   		movq	%rsp, %rbp
 1158              		.cfi_def_cfa_register 6
 1159 0a7b 4883EC20 		subq	$32, %rsp
 1160 0a7f 48897DE8 		movq	%rdi, -24(%rbp)
 1161 0a83 8975E4   		movl	%esi, -28(%rbp)
 269:libusbwrap.c  **** 	if ( dev ) {
 1162              		.loc 3 269 5
 1163 0a86 48837DE8 		cmpq	$0, -24(%rbp)
 1163      00
 1164 0a8b 7444     		je	.L88
 1165              	.LBB3:
 270:libusbwrap.c  **** 		struct libusb_device_handle *ptr = dev->handle;
 1166              		.loc 3 270 32
 1167 0a8d 488B45E8 		movq	-24(%rbp), %rax
 1168 0a91 488B00   		movq	(%rax), %rax
 1169 0a94 488945F8 		movq	%rax, -8(%rbp)
 271:libusbwrap.c  **** 		libusb_release_interface(ptr, iface);
 1170              		.loc 3 271 3
 1171 0a98 8B55E4   		movl	-28(%rbp), %edx
 1172 0a9b 488B45F8 		movq	-8(%rbp), %rax
 1173 0a9f 89D6     		movl	%edx, %esi
 1174 0aa1 4889C7   		movq	%rax, %rdi
 1175 0aa4 E8000000 		call	libusb_release_interface@PLT
 1175      00
 272:libusbwrap.c  **** 		libusb_close(ptr);
 1176              		.loc 3 272 3
 1177 0aa9 488B45F8 		movq	-8(%rbp), %rax
 1178 0aad 4889C7   		movq	%rax, %rdi
 1179 0ab0 E8000000 		call	libusb_close@PLT
 1179      00
 273:libusbwrap.c  **** 		queueDestroy(&dev->queue);
 1180              		.loc 3 273 3
 1181 0ab5 488B45E8 		movq	-24(%rbp), %rax
 1182 0ab9 4883C008 		addq	$8, %rax
 1183 0abd 4889C7   		movq	%rax, %rdi
 1184 0ac0 E8000000 		call	queueDestroy@PLT
 1184      00
 274:libusbwrap.c  **** 		free((void*)dev);
 1185              		.loc 3 274 3
 1186 0ac5 488B45E8 		movq	-24(%rbp), %rax
 1187 0ac9 4889C7   		movq	%rax, %rdi
 1188 0acc E8000000 		call	free@PLT
 1188      00
 1189              	.L88:
 1190              	.LBE3:
 275:libusbwrap.c  **** 	}
 276:libusbwrap.c  **** }
 1191              		.loc 3 276 1
 1192 0ad1 90       		nop
 1193 0ad2 C9       		leave
 1194              		.cfi_def_cfa 7, 8
 1195 0ad3 C3       		ret
 1196              		.cfi_endproc
 1197              	.LFE32:
 1199              		.section	.rodata
 1200              	.LC10:
 1201 01e4 75736243 		.string	"usbControlRead(): Timeout!"
 1201      6F6E7472 
 1201      6F6C5265 
 1201      61642829 
 1201      3A205469 
 1202              	.LC11:
 1203 01ff 75736243 		.string	"usbControlRead(): %s"
 1203      6F6E7472 
 1203      6F6C5265 
 1203      61642829 
 1203      3A202573 
 1204 0214 00000000 		.align 8
 1205              	.LC12:
 1206 0218 75736243 		.string	"usbControlRead(): Expected to read %d bytes but actually read %d"
 1206      6F6E7472 
 1206      6F6C5265 
 1206      61642829 
 1206      3A204578 
 1207              		.text
 1208              		.globl	usbControlRead
 1210              	usbControlRead:
 1211              	.LFB33:
 277:libusbwrap.c  **** 
 278:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlRead(
 279:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 280:libusbwrap.c  **** 	uint8 *data, uint16 wLength,
 281:libusbwrap.c  **** 	uint32 timeout, const char **error)
 282:libusbwrap.c  **** {
 1212              		.loc 3 282 1
 1213              		.cfi_startproc
 1214 0ad4 F30F1EFA 		endbr64
 1215 0ad8 55       		pushq	%rbp
 1216              		.cfi_def_cfa_offset 16
 1217              		.cfi_offset 6, -16
 1218 0ad9 4889E5   		movq	%rsp, %rbp
 1219              		.cfi_def_cfa_register 6
 1220 0adc 4883EC30 		subq	$48, %rsp
 1221 0ae0 48897DE8 		movq	%rdi, -24(%rbp)
 1222 0ae4 89C8     		movl	%ecx, %eax
 1223 0ae6 4C8945D0 		movq	%r8, -48(%rbp)
 1224 0aea 4489C9   		movl	%r9d, %ecx
 1225 0aed 408875E4 		movb	%sil, -28(%rbp)
 1226 0af1 668955E0 		movw	%dx, -32(%rbp)
 1227 0af5 668945DC 		movw	%ax, -36(%rbp)
 1228 0af9 89C8     		movl	%ecx, %eax
 1229 0afb 668945D8 		movw	%ax, -40(%rbp)
 283:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1230              		.loc 3 283 12
 1231 0aff C745F800 		movl	$0, -8(%rbp)
 1231      000000
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1232              		.loc 3 284 15
 1233 0b06 0FB775D8 		movzwl	-40(%rbp), %esi
 1234 0b0a 440FB745 		movzwl	-36(%rbp), %r8d
 1234      DC
 1235 0b0f 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1236 0b13 0FB655E4 		movzbl	-28(%rbp), %edx
 285:libusbwrap.c  **** 		dev->handle,
 1237              		.loc 3 285 6
 1238 0b17 488B45E8 		movq	-24(%rbp), %rax
 1239 0b1b 488B00   		movq	(%rax), %rax
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1240              		.loc 3 284 15
 1241 0b1e 4C8B4DD0 		movq	-48(%rbp), %r9
 1242 0b22 8B7D10   		movl	16(%rbp), %edi
 1243 0b25 57       		pushq	%rdi
 1244 0b26 56       		pushq	%rsi
 1245 0b27 BEC00000 		movl	$192, %esi
 1245      00
 1246 0b2c 4889C7   		movq	%rax, %rdi
 1247 0b2f E8000000 		call	libusb_control_transfer@PLT
 1247      00
 1248 0b34 4883C410 		addq	$16, %rsp
 1249 0b38 8945FC   		movl	%eax, -4(%rbp)
 286:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 287:libusbwrap.c  **** 		bRequest,
 288:libusbwrap.c  **** 		wValue,
 289:libusbwrap.c  **** 		wIndex,
 290:libusbwrap.c  **** 		(uint8 *)data,
 291:libusbwrap.c  **** 		wLength,
 292:libusbwrap.c  **** 		timeout
 293:libusbwrap.c  **** 	);
 294:libusbwrap.c  **** 	CHECK_STATUS(
 1250              		.loc 3 294 2
 1251 0b3b 837DFCF9 		cmpl	$-7, -4(%rbp)
 1252 0b3f 751F     		jne	.L90
 1253              		.loc 3 294 2 is_stmt 0 discriminator 1
 1254 0b41 488B4518 		movq	24(%rbp), %rax
 1255 0b45 488D1500 		leaq	.LC10(%rip), %rdx
 1255      000000
 1256 0b4c 4889D6   		movq	%rdx, %rsi
 1257 0b4f 4889C7   		movq	%rax, %rdi
 1258 0b52 E8000000 		call	errPrefix@PLT
 1258      00
 1259 0b57 C745F812 		movl	$18, -8(%rbp)
 1259      000000
 1260 0b5e EB69     		jmp	.L91
 1261              	.L90:
 295:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 296:libusbwrap.c  **** 		"usbControlRead(): Timeout!");
 297:libusbwrap.c  **** 	CHECK_STATUS(
 1262              		.loc 3 297 2 is_stmt 1
 1263 0b60 837DFC00 		cmpl	$0, -4(%rbp)
 1264 0b64 7931     		jns	.L92
 1265              		.loc 3 297 2 is_stmt 0 discriminator 1
 1266 0b66 8B45FC   		movl	-4(%rbp), %eax
 1267 0b69 89C7     		movl	%eax, %edi
 1268 0b6b E8000000 		call	libusb_error_name@PLT
 1268      00
 1269 0b70 4889C2   		movq	%rax, %rdx
 1270 0b73 488B4518 		movq	24(%rbp), %rax
 1271 0b77 488D0D00 		leaq	.LC11(%rip), %rcx
 1271      000000
 1272 0b7e 4889CE   		movq	%rcx, %rsi
 1273 0b81 4889C7   		movq	%rax, %rdi
 1274 0b84 B8000000 		movl	$0, %eax
 1274      00
 1275 0b89 E8000000 		call	errRender@PLT
 1275      00
 1276 0b8e C745F80A 		movl	$10, -8(%rbp)
 1276      000000
 1277 0b95 EB32     		jmp	.L91
 1278              	.L92:
 298:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 299:libusbwrap.c  **** 		"usbControlRead(): %s", libusb_error_name(status));
 300:libusbwrap.c  **** 	CHECK_STATUS(
 1279              		.loc 3 300 2 is_stmt 1
 1280 0b97 0FB745D8 		movzwl	-40(%rbp), %eax
 1281 0b9b 3945FC   		cmpl	%eax, -4(%rbp)
 1282 0b9e 7428     		je	.L94
 1283              		.loc 3 300 2 is_stmt 0 discriminator 1
 1284 0ba0 0FB755D8 		movzwl	-40(%rbp), %edx
 1285 0ba4 8B4DFC   		movl	-4(%rbp), %ecx
 1286 0ba7 488B4518 		movq	24(%rbp), %rax
 1287 0bab 488D3500 		leaq	.LC12(%rip), %rsi
 1287      000000
 1288 0bb2 4889C7   		movq	%rax, %rdi
 1289 0bb5 B8000000 		movl	$0, %eax
 1289      00
 1290 0bba E8000000 		call	errRender@PLT
 1290      00
 1291 0bbf C745F80A 		movl	$10, -8(%rbp)
 1291      000000
 1292 0bc6 EB01     		jmp	.L91
 1293              	.L94:
 301:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 302:libusbwrap.c  **** 		"usbControlRead(): Expected to read %d bytes but actually read %d", wLength, status);
 303:libusbwrap.c  **** cleanup:
 1294              		.loc 3 303 1 is_stmt 1
 1295 0bc8 90       		nop
 1296              	.L91:
 304:libusbwrap.c  **** 	return retVal;
 1297              		.loc 3 304 9
 1298 0bc9 8B45F8   		movl	-8(%rbp), %eax
 305:libusbwrap.c  **** }
 1299              		.loc 3 305 1
 1300 0bcc C9       		leave
 1301              		.cfi_def_cfa 7, 8
 1302 0bcd C3       		ret
 1303              		.cfi_endproc
 1304              	.LFE33:
 1306              		.section	.rodata
 1307              	.LC13:
 1308 0259 75736243 		.string	"usbControlWrite(): Timeout"
 1308      6F6E7472 
 1308      6F6C5772 
 1308      69746528 
 1308      293A2054 
 1309              	.LC14:
 1310 0274 75736243 		.string	"usbControlWrite(): %s"
 1310      6F6E7472 
 1310      6F6C5772 
 1310      69746528 
 1310      293A2025 
 1311 028a 00000000 		.align 8
 1311      0000
 1312              	.LC15:
 1313 0290 75736243 		.string	"usbControlWrite(): Expected to write %d bytes but actually wrote %d"
 1313      6F6E7472 
 1313      6F6C5772 
 1313      69746528 
 1313      293A2045 
 1314              		.text
 1315              		.globl	usbControlWrite
 1317              	usbControlWrite:
 1318              	.LFB34:
 306:libusbwrap.c  **** 
 307:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlWrite(
 308:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 309:libusbwrap.c  **** 	const uint8 *data, uint16 wLength,
 310:libusbwrap.c  **** 	uint32 timeout, const char **error)
 311:libusbwrap.c  **** {
 1319              		.loc 3 311 1
 1320              		.cfi_startproc
 1321 0bce F30F1EFA 		endbr64
 1322 0bd2 55       		pushq	%rbp
 1323              		.cfi_def_cfa_offset 16
 1324              		.cfi_offset 6, -16
 1325 0bd3 4889E5   		movq	%rsp, %rbp
 1326              		.cfi_def_cfa_register 6
 1327 0bd6 4883EC30 		subq	$48, %rsp
 1328 0bda 48897DE8 		movq	%rdi, -24(%rbp)
 1329 0bde 89C8     		movl	%ecx, %eax
 1330 0be0 4C8945D0 		movq	%r8, -48(%rbp)
 1331 0be4 4489C9   		movl	%r9d, %ecx
 1332 0be7 408875E4 		movb	%sil, -28(%rbp)
 1333 0beb 668955E0 		movw	%dx, -32(%rbp)
 1334 0bef 668945DC 		movw	%ax, -36(%rbp)
 1335 0bf3 89C8     		movl	%ecx, %eax
 1336 0bf5 668945D8 		movw	%ax, -40(%rbp)
 312:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1337              		.loc 3 312 12
 1338 0bf9 C745F800 		movl	$0, -8(%rbp)
 1338      000000
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1339              		.loc 3 313 15
 1340 0c00 0FB775D8 		movzwl	-40(%rbp), %esi
 1341 0c04 440FB745 		movzwl	-36(%rbp), %r8d
 1341      DC
 1342 0c09 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1343 0c0d 0FB655E4 		movzbl	-28(%rbp), %edx
 314:libusbwrap.c  **** 		dev->handle,
 1344              		.loc 3 314 6
 1345 0c11 488B45E8 		movq	-24(%rbp), %rax
 1346 0c15 488B00   		movq	(%rax), %rax
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1347              		.loc 3 313 15
 1348 0c18 4C8B4DD0 		movq	-48(%rbp), %r9
 1349 0c1c 8B7D10   		movl	16(%rbp), %edi
 1350 0c1f 57       		pushq	%rdi
 1351 0c20 56       		pushq	%rsi
 1352 0c21 BE400000 		movl	$64, %esi
 1352      00
 1353 0c26 4889C7   		movq	%rax, %rdi
 1354 0c29 E8000000 		call	libusb_control_transfer@PLT
 1354      00
 1355 0c2e 4883C410 		addq	$16, %rsp
 1356 0c32 8945FC   		movl	%eax, -4(%rbp)
 315:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 316:libusbwrap.c  **** 		bRequest,
 317:libusbwrap.c  **** 		wValue,
 318:libusbwrap.c  **** 		wIndex,
 319:libusbwrap.c  **** 		(uint8 *)data,
 320:libusbwrap.c  **** 		wLength,
 321:libusbwrap.c  **** 		timeout
 322:libusbwrap.c  **** 	);
 323:libusbwrap.c  **** 	CHECK_STATUS(
 1357              		.loc 3 323 2
 1358 0c35 837DFCF9 		cmpl	$-7, -4(%rbp)
 1359 0c39 751F     		jne	.L96
 1360              		.loc 3 323 2 is_stmt 0 discriminator 1
 1361 0c3b 488B4518 		movq	24(%rbp), %rax
 1362 0c3f 488D1500 		leaq	.LC13(%rip), %rdx
 1362      000000
 1363 0c46 4889D6   		movq	%rdx, %rsi
 1364 0c49 4889C7   		movq	%rax, %rdi
 1365 0c4c E8000000 		call	errPrefix@PLT
 1365      00
 1366 0c51 C745F812 		movl	$18, -8(%rbp)
 1366      000000
 1367 0c58 EB69     		jmp	.L97
 1368              	.L96:
 324:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 325:libusbwrap.c  **** 		"usbControlWrite(): Timeout");
 326:libusbwrap.c  **** 	CHECK_STATUS(
 1369              		.loc 3 326 2 is_stmt 1
 1370 0c5a 837DFC00 		cmpl	$0, -4(%rbp)
 1371 0c5e 7931     		jns	.L98
 1372              		.loc 3 326 2 is_stmt 0 discriminator 1
 1373 0c60 8B45FC   		movl	-4(%rbp), %eax
 1374 0c63 89C7     		movl	%eax, %edi
 1375 0c65 E8000000 		call	libusb_error_name@PLT
 1375      00
 1376 0c6a 4889C2   		movq	%rax, %rdx
 1377 0c6d 488B4518 		movq	24(%rbp), %rax
 1378 0c71 488D0D00 		leaq	.LC14(%rip), %rcx
 1378      000000
 1379 0c78 4889CE   		movq	%rcx, %rsi
 1380 0c7b 4889C7   		movq	%rax, %rdi
 1381 0c7e B8000000 		movl	$0, %eax
 1381      00
 1382 0c83 E8000000 		call	errRender@PLT
 1382      00
 1383 0c88 C745F80A 		movl	$10, -8(%rbp)
 1383      000000
 1384 0c8f EB32     		jmp	.L97
 1385              	.L98:
 327:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 328:libusbwrap.c  **** 		"usbControlWrite(): %s", libusb_error_name(status));
 329:libusbwrap.c  **** 	CHECK_STATUS(
 1386              		.loc 3 329 2 is_stmt 1
 1387 0c91 0FB745D8 		movzwl	-40(%rbp), %eax
 1388 0c95 3945FC   		cmpl	%eax, -4(%rbp)
 1389 0c98 7428     		je	.L100
 1390              		.loc 3 329 2 is_stmt 0 discriminator 1
 1391 0c9a 0FB755D8 		movzwl	-40(%rbp), %edx
 1392 0c9e 8B4DFC   		movl	-4(%rbp), %ecx
 1393 0ca1 488B4518 		movq	24(%rbp), %rax
 1394 0ca5 488D3500 		leaq	.LC15(%rip), %rsi
 1394      000000
 1395 0cac 4889C7   		movq	%rax, %rdi
 1396 0caf B8000000 		movl	$0, %eax
 1396      00
 1397 0cb4 E8000000 		call	errRender@PLT
 1397      00
 1398 0cb9 C745F80A 		movl	$10, -8(%rbp)
 1398      000000
 1399 0cc0 EB01     		jmp	.L97
 1400              	.L100:
 330:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 331:libusbwrap.c  **** 		"usbControlWrite(): Expected to write %d bytes but actually wrote %d", wLength, status);
 332:libusbwrap.c  **** cleanup:
 1401              		.loc 3 332 1 is_stmt 1
 1402 0cc2 90       		nop
 1403              	.L97:
 333:libusbwrap.c  **** 	return retVal;
 1404              		.loc 3 333 9
 1405 0cc3 8B45F8   		movl	-8(%rbp), %eax
 334:libusbwrap.c  **** }
 1406              		.loc 3 334 1
 1407 0cc6 C9       		leave
 1408              		.cfi_def_cfa 7, 8
 1409 0cc7 C3       		ret
 1410              		.cfi_endproc
 1411              	.LFE34:
 1413              		.section	.rodata
 1414              	.LC16:
 1415 02d4 75736242 		.string	"usbBulkRead(): Timeout"
 1415      756C6B52 
 1415      65616428 
 1415      293A2054 
 1415      696D656F 
 1416              	.LC17:
 1417 02eb 75736242 		.string	"usbBulkRead(): %s"
 1417      756C6B52 
 1417      65616428 
 1417      293A2025 
 1417      7300
 1418 02fd 000000   		.align 8
 1419              	.LC18:
 1420 0300 75736242 		.string	"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s"
 1420      756C6B52 
 1420      65616428 
 1420      293A2045 
 1420      78706563 
 1421              		.text
 1422              		.globl	usbBulkRead
 1424              	usbBulkRead:
 1425              	.LFB35:
 335:libusbwrap.c  **** 
 336:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkRead(
 337:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *data, uint32 count,
 338:libusbwrap.c  **** 	uint32 timeout, const char **error)
 339:libusbwrap.c  **** {
 1426              		.loc 3 339 1
 1427              		.cfi_startproc
 1428 0cc8 F30F1EFA 		endbr64
 1429 0ccc 55       		pushq	%rbp
 1430              		.cfi_def_cfa_offset 16
 1431              		.cfi_offset 6, -16
 1432 0ccd 4889E5   		movq	%rsp, %rbp
 1433              		.cfi_def_cfa_register 6
 1434 0cd0 4883EC50 		subq	$80, %rsp
 1435 0cd4 48897DD8 		movq	%rdi, -40(%rbp)
 1436 0cd8 89F0     		movl	%esi, %eax
 1437 0cda 488955C8 		movq	%rdx, -56(%rbp)
 1438 0cde 894DD0   		movl	%ecx, -48(%rbp)
 1439 0ce1 448945C4 		movl	%r8d, -60(%rbp)
 1440 0ce5 4C894DB8 		movq	%r9, -72(%rbp)
 1441 0ce9 8845D4   		movb	%al, -44(%rbp)
 1442              		.loc 3 339 1
 1443 0cec 64488B04 		movq	%fs:40, %rax
 1443      25280000 
 1443      00
 1444 0cf5 488945F8 		movq	%rax, -8(%rbp)
 1445 0cf9 31C0     		xorl	%eax, %eax
 340:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1446              		.loc 3 340 12
 1447 0cfb C745F000 		movl	$0, -16(%rbp)
 1447      000000
 341:libusbwrap.c  **** 	int numRead;
 342:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1448              		.loc 3 342 15
 1449 0d02 8B4DD0   		movl	-48(%rbp), %ecx
 1450 0d05 0FB645D4 		movzbl	-44(%rbp), %eax
 1451 0d09 83C880   		orl	$-128, %eax
 1452 0d0c 0FB6F0   		movzbl	%al, %esi
 343:libusbwrap.c  **** 		dev->handle,
 1453              		.loc 3 343 6
 1454 0d0f 488B45D8 		movq	-40(%rbp), %rax
 1455 0d13 488B00   		movq	(%rax), %rax
 342:libusbwrap.c  **** 		dev->handle,
 1456              		.loc 3 342 15
 1457 0d16 448B45C4 		movl	-60(%rbp), %r8d
 1458 0d1a 488D7DEC 		leaq	-20(%rbp), %rdi
 1459 0d1e 488B55C8 		movq	-56(%rbp), %rdx
 1460 0d22 4589C1   		movl	%r8d, %r9d
 1461 0d25 4989F8   		movq	%rdi, %r8
 1462 0d28 4889C7   		movq	%rax, %rdi
 1463 0d2b E8000000 		call	libusb_bulk_transfer@PLT
 1463      00
 1464 0d30 8945F4   		movl	%eax, -12(%rbp)
 344:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | endpoint,
 345:libusbwrap.c  **** 		data,
 346:libusbwrap.c  **** 		(int)count,
 347:libusbwrap.c  **** 		&numRead,
 348:libusbwrap.c  **** 		timeout
 349:libusbwrap.c  **** 	);
 350:libusbwrap.c  **** 	CHECK_STATUS(
 1465              		.loc 3 350 2
 1466 0d33 837DF4F9 		cmpl	$-7, -12(%rbp)
 1467 0d37 751F     		jne	.L102
 1468              		.loc 3 350 2 is_stmt 0 discriminator 1
 1469 0d39 488B45B8 		movq	-72(%rbp), %rax
 1470 0d3d 488D1500 		leaq	.LC16(%rip), %rdx
 1470      000000
 1471 0d44 4889D6   		movq	%rdx, %rsi
 1472 0d47 4889C7   		movq	%rax, %rdi
 1473 0d4a E8000000 		call	errPrefix@PLT
 1473      00
 1474 0d4f C745F012 		movl	$18, -16(%rbp)
 1474      000000
 1475 0d56 EB7F     		jmp	.L103
 1476              	.L102:
 351:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 352:libusbwrap.c  **** 		"usbBulkRead(): Timeout");
 353:libusbwrap.c  **** 	CHECK_STATUS(
 1477              		.loc 3 353 2 is_stmt 1
 1478 0d58 837DF400 		cmpl	$0, -12(%rbp)
 1479 0d5c 7931     		jns	.L104
 1480              		.loc 3 353 2 is_stmt 0 discriminator 1
 1481 0d5e 8B45F4   		movl	-12(%rbp), %eax
 1482 0d61 89C7     		movl	%eax, %edi
 1483 0d63 E8000000 		call	libusb_error_name@PLT
 1483      00
 1484 0d68 4889C2   		movq	%rax, %rdx
 1485 0d6b 488B45B8 		movq	-72(%rbp), %rax
 1486 0d6f 488D0D00 		leaq	.LC17(%rip), %rcx
 1486      000000
 1487 0d76 4889CE   		movq	%rcx, %rsi
 1488 0d79 4889C7   		movq	%rax, %rdi
 1489 0d7c B8000000 		movl	$0, %eax
 1489      00
 1490 0d81 E8000000 		call	errRender@PLT
 1490      00
 1491 0d86 C745F00B 		movl	$11, -16(%rbp)
 1491      000000
 1492 0d8d EB48     		jmp	.L103
 1493              	.L104:
 354:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 355:libusbwrap.c  **** 		"usbBulkRead(): %s", libusb_error_name(status));
 356:libusbwrap.c  **** 	CHECK_STATUS(
 1494              		.loc 3 356 2 is_stmt 1
 1495 0d8f 8B55EC   		movl	-20(%rbp), %edx
 1496 0d92 8B45D0   		movl	-48(%rbp), %eax
 1497 0d95 39C2     		cmpl	%eax, %edx
 1498 0d97 743D     		je	.L107
 1499              		.loc 3 356 2 is_stmt 0 discriminator 1
 1500 0d99 8B45F4   		movl	-12(%rbp), %eax
 1501 0d9c 89C7     		movl	%eax, %edi
 1502 0d9e E8000000 		call	libusb_error_name@PLT
 1502      00
 1503 0da3 4889C6   		movq	%rax, %rsi
 1504 0da6 8B4DEC   		movl	-20(%rbp), %ecx
 1505 0da9 8B7DF4   		movl	-12(%rbp), %edi
 1506 0dac 8B55D0   		movl	-48(%rbp), %edx
 1507 0daf 488B45B8 		movq	-72(%rbp), %rax
 1508 0db3 4989F1   		movq	%rsi, %r9
 1509 0db6 4189F8   		movl	%edi, %r8d
 1510 0db9 488D3500 		leaq	.LC18(%rip), %rsi
 1510      000000
 1511 0dc0 4889C7   		movq	%rax, %rdi
 1512 0dc3 B8000000 		movl	$0, %eax
 1512      00
 1513 0dc8 E8000000 		call	errRender@PLT
 1513      00
 1514 0dcd C745F00B 		movl	$11, -16(%rbp)
 1514      000000
 1515 0dd4 EB01     		jmp	.L103
 1516              	.L107:
 357:libusbwrap.c  **** 		(uint32)numRead != count, USB_BULK, cleanup,
 358:libusbwrap.c  **** 		"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s",
 359:libusbwrap.c  **** 		count, numRead, status, libusb_error_name(status));
 360:libusbwrap.c  **** cleanup:
 1517              		.loc 3 360 1 is_stmt 1
 1518 0dd6 90       		nop
 1519              	.L103:
 361:libusbwrap.c  **** 	return retVal;
 1520              		.loc 3 361 9
 1521 0dd7 8B45F0   		movl	-16(%rbp), %eax
 362:libusbwrap.c  **** }
 1522              		.loc 3 362 1
 1523 0dda 488B55F8 		movq	-8(%rbp), %rdx
 1524 0dde 64482B14 		subq	%fs:40, %rdx
 1524      25280000 
 1524      00
 1525 0de7 7405     		je	.L106
 1526 0de9 E8000000 		call	__stack_chk_fail@PLT
 1526      00
 1527              	.L106:
 1528 0dee C9       		leave
 1529              		.cfi_def_cfa 7, 8
 1530 0def C3       		ret
 1531              		.cfi_endproc
 1532              	.LFE35:
 1534              		.section	.rodata
 1535              	.LC19:
 1536 0350 75736242 		.string	"usbBulkWrite(): Timeout"
 1536      756C6B57 
 1536      72697465 
 1536      28293A20 
 1536      54696D65 
 1537              	.LC20:
 1538 0368 75736242 		.string	"usbBulkWrite(): %s"
 1538      756C6B57 
 1538      72697465 
 1538      28293A20 
 1538      257300
 1539 037b 00000000 		.align 8
 1539      00
 1540              	.LC21:
 1541 0380 75736242 		.string	"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s"
 1541      756C6B57 
 1541      72697465 
 1541      28293A20 
 1541      45787065 
 1542              		.text
 1543              		.globl	usbBulkWrite
 1545              	usbBulkWrite:
 1546              	.LFB36:
 363:libusbwrap.c  **** 
 364:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWrite(
 365:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *data, uint32 count,
 366:libusbwrap.c  **** 	uint32 timeout, const char **error)
 367:libusbwrap.c  **** {
 1547              		.loc 3 367 1
 1548              		.cfi_startproc
 1549 0df0 F30F1EFA 		endbr64
 1550 0df4 55       		pushq	%rbp
 1551              		.cfi_def_cfa_offset 16
 1552              		.cfi_offset 6, -16
 1553 0df5 4889E5   		movq	%rsp, %rbp
 1554              		.cfi_def_cfa_register 6
 1555 0df8 4883EC50 		subq	$80, %rsp
 1556 0dfc 48897DD8 		movq	%rdi, -40(%rbp)
 1557 0e00 89F0     		movl	%esi, %eax
 1558 0e02 488955C8 		movq	%rdx, -56(%rbp)
 1559 0e06 894DD0   		movl	%ecx, -48(%rbp)
 1560 0e09 448945C4 		movl	%r8d, -60(%rbp)
 1561 0e0d 4C894DB8 		movq	%r9, -72(%rbp)
 1562 0e11 8845D4   		movb	%al, -44(%rbp)
 1563              		.loc 3 367 1
 1564 0e14 64488B04 		movq	%fs:40, %rax
 1564      25280000 
 1564      00
 1565 0e1d 488945F8 		movq	%rax, -8(%rbp)
 1566 0e21 31C0     		xorl	%eax, %eax
 368:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1567              		.loc 3 368 12
 1568 0e23 C745F000 		movl	$0, -16(%rbp)
 1568      000000
 369:libusbwrap.c  **** 	int numWritten;
 370:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1569              		.loc 3 370 15
 1570 0e2a 8B4DD0   		movl	-48(%rbp), %ecx
 1571 0e2d 0FB675D4 		movzbl	-44(%rbp), %esi
 371:libusbwrap.c  **** 		dev->handle,
 1572              		.loc 3 371 6
 1573 0e31 488B45D8 		movq	-40(%rbp), %rax
 1574 0e35 488B00   		movq	(%rax), %rax
 370:libusbwrap.c  **** 		dev->handle,
 1575              		.loc 3 370 15
 1576 0e38 448B45C4 		movl	-60(%rbp), %r8d
 1577 0e3c 488D7DEC 		leaq	-20(%rbp), %rdi
 1578 0e40 488B55C8 		movq	-56(%rbp), %rdx
 1579 0e44 4589C1   		movl	%r8d, %r9d
 1580 0e47 4989F8   		movq	%rdi, %r8
 1581 0e4a 4889C7   		movq	%rax, %rdi
 1582 0e4d E8000000 		call	libusb_bulk_transfer@PLT
 1582      00
 1583 0e52 8945F4   		movl	%eax, -12(%rbp)
 372:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | endpoint,
 373:libusbwrap.c  **** 		(uint8 *)data,
 374:libusbwrap.c  **** 		(int)count,
 375:libusbwrap.c  **** 		&numWritten,
 376:libusbwrap.c  **** 		timeout
 377:libusbwrap.c  **** 	);
 378:libusbwrap.c  **** 	CHECK_STATUS(
 1584              		.loc 3 378 2
 1585 0e55 837DF4F9 		cmpl	$-7, -12(%rbp)
 1586 0e59 751F     		jne	.L109
 1587              		.loc 3 378 2 is_stmt 0 discriminator 1
 1588 0e5b 488B45B8 		movq	-72(%rbp), %rax
 1589 0e5f 488D1500 		leaq	.LC19(%rip), %rdx
 1589      000000
 1590 0e66 4889D6   		movq	%rdx, %rsi
 1591 0e69 4889C7   		movq	%rax, %rdi
 1592 0e6c E8000000 		call	errPrefix@PLT
 1592      00
 1593 0e71 C745F012 		movl	$18, -16(%rbp)
 1593      000000
 1594 0e78 EB7F     		jmp	.L110
 1595              	.L109:
 379:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 380:libusbwrap.c  **** 		"usbBulkWrite(): Timeout");
 381:libusbwrap.c  **** 	CHECK_STATUS(
 1596              		.loc 3 381 2 is_stmt 1
 1597 0e7a 837DF400 		cmpl	$0, -12(%rbp)
 1598 0e7e 7931     		jns	.L111
 1599              		.loc 3 381 2 is_stmt 0 discriminator 1
 1600 0e80 8B45F4   		movl	-12(%rbp), %eax
 1601 0e83 89C7     		movl	%eax, %edi
 1602 0e85 E8000000 		call	libusb_error_name@PLT
 1602      00
 1603 0e8a 4889C2   		movq	%rax, %rdx
 1604 0e8d 488B45B8 		movq	-72(%rbp), %rax
 1605 0e91 488D0D00 		leaq	.LC20(%rip), %rcx
 1605      000000
 1606 0e98 4889CE   		movq	%rcx, %rsi
 1607 0e9b 4889C7   		movq	%rax, %rdi
 1608 0e9e B8000000 		movl	$0, %eax
 1608      00
 1609 0ea3 E8000000 		call	errRender@PLT
 1609      00
 1610 0ea8 C745F00B 		movl	$11, -16(%rbp)
 1610      000000
 1611 0eaf EB48     		jmp	.L110
 1612              	.L111:
 382:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 383:libusbwrap.c  **** 		"usbBulkWrite(): %s", libusb_error_name(status));
 384:libusbwrap.c  **** 	CHECK_STATUS(
 1613              		.loc 3 384 2 is_stmt 1
 1614 0eb1 8B55EC   		movl	-20(%rbp), %edx
 1615 0eb4 8B45D0   		movl	-48(%rbp), %eax
 1616 0eb7 39C2     		cmpl	%eax, %edx
 1617 0eb9 743D     		je	.L114
 1618              		.loc 3 384 2 is_stmt 0 discriminator 1
 1619 0ebb 8B45F4   		movl	-12(%rbp), %eax
 1620 0ebe 89C7     		movl	%eax, %edi
 1621 0ec0 E8000000 		call	libusb_error_name@PLT
 1621      00
 1622 0ec5 4889C6   		movq	%rax, %rsi
 1623 0ec8 8B4DEC   		movl	-20(%rbp), %ecx
 1624 0ecb 8B7DF4   		movl	-12(%rbp), %edi
 1625 0ece 8B55D0   		movl	-48(%rbp), %edx
 1626 0ed1 488B45B8 		movq	-72(%rbp), %rax
 1627 0ed5 4989F1   		movq	%rsi, %r9
 1628 0ed8 4189F8   		movl	%edi, %r8d
 1629 0edb 488D3500 		leaq	.LC21(%rip), %rsi
 1629      000000
 1630 0ee2 4889C7   		movq	%rax, %rdi
 1631 0ee5 B8000000 		movl	$0, %eax
 1631      00
 1632 0eea E8000000 		call	errRender@PLT
 1632      00
 1633 0eef C745F00B 		movl	$11, -16(%rbp)
 1633      000000
 1634 0ef6 EB01     		jmp	.L110
 1635              	.L114:
 385:libusbwrap.c  **** 		(uint32)numWritten != count, USB_BULK, cleanup,
 386:libusbwrap.c  **** 		"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s",
 387:libusbwrap.c  **** 		count, numWritten, status, libusb_error_name(status));
 388:libusbwrap.c  **** cleanup:
 1636              		.loc 3 388 1 is_stmt 1
 1637 0ef8 90       		nop
 1638              	.L110:
 389:libusbwrap.c  **** 	return retVal;
 1639              		.loc 3 389 9
 1640 0ef9 8B45F0   		movl	-16(%rbp), %eax
 390:libusbwrap.c  **** }
 1641              		.loc 3 390 1
 1642 0efc 488B55F8 		movq	-8(%rbp), %rdx
 1643 0f00 64482B14 		subq	%fs:40, %rdx
 1643      25280000 
 1643      00
 1644 0f09 7405     		je	.L113
 1645 0f0b E8000000 		call	__stack_chk_fail@PLT
 1645      00
 1646              	.L113:
 1647 0f10 C9       		leave
 1648              		.cfi_def_cfa 7, 8
 1649 0f11 C3       		ret
 1650              		.cfi_endproc
 1651              	.LFE36:
 1654              	bulk_transfer_cb:
 1655              	.LFB37:
 391:libusbwrap.c  **** 
 392:libusbwrap.c  **** static void LIBUSB_CALL bulk_transfer_cb(struct libusb_transfer *transfer) {
 1656              		.loc 3 392 76
 1657              		.cfi_startproc
 1658 0f12 F30F1EFA 		endbr64
 1659 0f16 55       		pushq	%rbp
 1660              		.cfi_def_cfa_offset 16
 1661              		.cfi_offset 6, -16
 1662 0f17 4889E5   		movq	%rsp, %rbp
 1663              		.cfi_def_cfa_register 6
 1664 0f1a 48897DE8 		movq	%rdi, -24(%rbp)
 393:libusbwrap.c  **** 	int *completed = transfer->user_data;
 1665              		.loc 3 393 7
 1666 0f1e 488B45E8 		movq	-24(%rbp), %rax
 1667 0f22 488B4028 		movq	40(%rax), %rax
 1668 0f26 488945F8 		movq	%rax, -8(%rbp)
 394:libusbwrap.c  **** 	*completed = 1;
 1669              		.loc 3 394 13
 1670 0f2a 488B45F8 		movq	-8(%rbp), %rax
 1671 0f2e C7000100 		movl	$1, (%rax)
 1671      0000
 395:libusbwrap.c  **** }
 1672              		.loc 3 395 1
 1673 0f34 90       		nop
 1674 0f35 5D       		popq	%rbp
 1675              		.cfi_def_cfa 7, 8
 1676 0f36 C3       		ret
 1677              		.cfi_endproc
 1678              	.LFE37:
 1680              		.section	.rodata
 1681 03d3 00000000 		.align 8
 1681      00
 1682              	.LC22:
 1683 03d8 75736242 		.string	"usbBulkWriteAsync(): Submission error: %s"
 1683      756C6B57 
 1683      72697465 
 1683      4173796E 
 1683      6328293A 
 1684              		.text
 1685              		.globl	usbBulkWriteAsync
 1687              	usbBulkWriteAsync:
 1688              	.LFB38:
 396:libusbwrap.c  **** 
 397:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsync(
 398:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *buffer, uint32 length, uint32 timeout,
 399:libusbwrap.c  **** 	const char **error)
 400:libusbwrap.c  **** {
 1689              		.loc 3 400 1
 1690              		.cfi_startproc
 1691 0f37 F30F1EFA 		endbr64
 1692 0f3b 55       		pushq	%rbp
 1693              		.cfi_def_cfa_offset 16
 1694              		.cfi_offset 6, -16
 1695 0f3c 4889E5   		movq	%rsp, %rbp
 1696              		.cfi_def_cfa_register 6
 1697 0f3f 4883EC60 		subq	$96, %rsp
 1698 0f43 48897DC8 		movq	%rdi, -56(%rbp)
 1699 0f47 89F0     		movl	%esi, %eax
 1700 0f49 488955B8 		movq	%rdx, -72(%rbp)
 1701 0f4d 894DC0   		movl	%ecx, -64(%rbp)
 1702 0f50 448945B4 		movl	%r8d, -76(%rbp)
 1703 0f54 4C894DA8 		movq	%r9, -88(%rbp)
 1704 0f58 8845C4   		movb	%al, -60(%rbp)
 1705              		.loc 3 400 1
 1706 0f5b 64488B04 		movq	%fs:40, %rax
 1706      25280000 
 1706      00
 1707 0f64 488945F8 		movq	%rax, -8(%rbp)
 1708 0f68 31C0     		xorl	%eax, %eax
 401:libusbwrap.c  **** 	int retVal = USB_SUCCESS;
 1709              		.loc 3 401 6
 1710 0f6a C745D400 		movl	$0, -44(%rbp)
 1710      000000
 402:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 403:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 404:libusbwrap.c  **** 	int *completed;
 405:libusbwrap.c  **** 	int iStatus;
 406:libusbwrap.c  **** 	USBStatus uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1711              		.loc 3 406 22
 1712 0f71 488B45C8 		movq	-56(%rbp), %rax
 1713 0f75 488D5008 		leaq	8(%rax), %rdx
 1714 0f79 488D45E0 		leaq	-32(%rbp), %rax
 1715 0f7d 4889C6   		movq	%rax, %rsi
 1716 0f80 4889D7   		movq	%rdx, %rdi
 1717 0f83 E8000000 		call	queuePut@PLT
 1717      00
 1718 0f88 8945D8   		movl	%eax, -40(%rbp)
 407:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup);
 1719              		.loc 3 407 2
 1720 0f8b 837DD800 		cmpl	$0, -40(%rbp)
 1721 0f8f 740B     		je	.L117
 1722              		.loc 3 407 2 is_stmt 0 discriminator 1
 1723 0f91 8B45D8   		movl	-40(%rbp), %eax
 1724 0f94 8945D4   		movl	%eax, -44(%rbp)
 1725 0f97 E9BE0000 		jmp	.L118
 1725      00
 1726              	.L117:
 408:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1727              		.loc 3 408 20 is_stmt 1
 1728 0f9c 488B45E0 		movq	-32(%rbp), %rax
 1729              		.loc 3 408 11
 1730 0fa0 488B00   		movq	(%rax), %rax
 1731 0fa3 488945E8 		movq	%rax, -24(%rbp)
 409:libusbwrap.c  **** 	completed = &wrapper->completed;
 1732              		.loc 3 409 22
 1733 0fa7 488B45E0 		movq	-32(%rbp), %rax
 1734              		.loc 3 409 12
 1735 0fab 4883C008 		addq	$8, %rax
 1736 0faf 488945F0 		movq	%rax, -16(%rbp)
 410:libusbwrap.c  **** 	*completed = 0;
 1737              		.loc 3 410 13
 1738 0fb3 488B45F0 		movq	-16(%rbp), %rax
 1739 0fb7 C7000000 		movl	$0, (%rax)
 1739      0000
 411:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1740              		.loc 3 411 9
 1741 0fbd 488B45E0 		movq	-32(%rbp), %rax
 1742              		.loc 3 411 24
 1743 0fc1 0FB6500C 		movzbl	12(%rax), %edx
 1744 0fc5 83E2FE   		andl	$-2, %edx
 1745 0fc8 88500C   		movb	%dl, 12(%rax)
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1746              		.loc 3 412 2
 1747 0fcb 448B45C0 		movl	-64(%rbp), %r8d
 1748 0fcf 0FB655C4 		movzbl	-60(%rbp), %edx
 413:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, (uint8 *)buffer, (int)length,
 1749              		.loc 3 413 16
 1750 0fd3 488B45C8 		movq	-56(%rbp), %rax
 1751 0fd7 488B30   		movq	(%rax), %rsi
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1752              		.loc 3 412 2
 1753 0fda 488B4DB8 		movq	-72(%rbp), %rcx
 1754 0fde 488B45E8 		movq	-24(%rbp), %rax
 1755 0fe2 8B7DB4   		movl	-76(%rbp), %edi
 1756 0fe5 57       		pushq	%rdi
 1757 0fe6 FF75F0   		pushq	-16(%rbp)
 1758 0fe9 4C8D0D22 		leaq	bulk_transfer_cb(%rip), %r9
 1758      FFFFFF
 1759 0ff0 4889C7   		movq	%rax, %rdi
 1760 0ff3 E81AF0FF 		call	libusb_fill_bulk_transfer
 1760      FF
 1761 0ff8 4883C410 		addq	$16, %rsp
 414:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 415:libusbwrap.c  **** 	);
 416:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1762              		.loc 3 416 17
 1763 0ffc 488B45E8 		movq	-24(%rbp), %rax
 1764 1000 C6400A02 		movb	$2, 10(%rax)
 417:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1765              		.loc 3 417 12
 1766 1004 488B45E8 		movq	-24(%rbp), %rax
 1767 1008 4889C7   		movq	%rax, %rdi
 1768 100b E8000000 		call	libusb_submit_transfer@PLT
 1768      00
 1769 1010 8945DC   		movl	%eax, -36(%rbp)
 418:libusbwrap.c  **** 	CHECK_STATUS(
 1770              		.loc 3 418 2
 1771 1013 837DDC00 		cmpl	$0, -36(%rbp)
 1772 1017 7431     		je	.L119
 1773              		.loc 3 418 2 is_stmt 0 discriminator 1
 1774 1019 8B45DC   		movl	-36(%rbp), %eax
 1775 101c 89C7     		movl	%eax, %edi
 1776 101e E8000000 		call	libusb_error_name@PLT
 1776      00
 1777 1023 4889C2   		movq	%rax, %rdx
 1778 1026 488B45A8 		movq	-88(%rbp), %rax
 1779 102a 488D0D00 		leaq	.LC22(%rip), %rcx
 1779      000000
 1780 1031 4889CE   		movq	%rcx, %rsi
 1781 1034 4889C7   		movq	%rax, %rdi
 1782 1037 B8000000 		movl	$0, %eax
 1782      00
 1783 103c E8000000 		call	errRender@PLT
 1783      00
 1784 1041 C745D40E 		movl	$14, -44(%rbp)
 1784      000000
 1785 1048 EB10     		jmp	.L118
 1786              	.L119:
 419:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 420:libusbwrap.c  **** 		"usbBulkWriteAsync(): Submission error: %s", libusb_error_name(iStatus)
 421:libusbwrap.c  **** 	);
 422:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1787              		.loc 3 422 2 is_stmt 1
 1788 104a 488B45C8 		movq	-56(%rbp), %rax
 1789 104e 4883C008 		addq	$8, %rax
 1790 1052 4889C7   		movq	%rax, %rdi
 1791 1055 E8000000 		call	queueCommitPut@PLT
 1791      00
 1792              	.L118:
 423:libusbwrap.c  **** cleanup:
 424:libusbwrap.c  **** 	return retVal;
 1793              		.loc 3 424 9
 1794 105a 8B45D4   		movl	-44(%rbp), %eax
 425:libusbwrap.c  **** }
 1795              		.loc 3 425 1
 1796 105d 488B55F8 		movq	-8(%rbp), %rdx
 1797 1061 64482B14 		subq	%fs:40, %rdx
 1797      25280000 
 1797      00
 1798 106a 7405     		je	.L121
 1799 106c E8000000 		call	__stack_chk_fail@PLT
 1799      00
 1800              	.L121:
 1801 1071 C9       		leave
 1802              		.cfi_def_cfa 7, 8
 1803 1072 C3       		ret
 1804              		.cfi_endproc
 1805              	.LFE38:
 1807              		.section	.rodata
 1808 0402 00000000 		.align 8
 1808      0000
 1809              	.LC23:
 1810 0408 75736242 		.string	"usbBulkWriteAsyncPrepare(): Work queue insertion error"
 1810      756C6B57 
 1810      72697465 
 1810      4173796E 
 1810      63507265 
 1811              		.text
 1812              		.globl	usbBulkWriteAsyncPrepare
 1814              	usbBulkWriteAsyncPrepare:
 1815              	.LFB39:
 426:libusbwrap.c  **** 
 427:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncPrepare(
 428:libusbwrap.c  **** 	struct USBDevice *dev, uint8 **buffer, const char **error)
 429:libusbwrap.c  **** {
 1816              		.loc 3 429 1
 1817              		.cfi_startproc
 1818 1073 F30F1EFA 		endbr64
 1819 1077 55       		pushq	%rbp
 1820              		.cfi_def_cfa_offset 16
 1821              		.cfi_offset 6, -16
 1822 1078 4889E5   		movq	%rsp, %rbp
 1823              		.cfi_def_cfa_register 6
 1824 107b 4883EC40 		subq	$64, %rsp
 1825 107f 48897DD8 		movq	%rdi, -40(%rbp)
 1826 1083 488975D0 		movq	%rsi, -48(%rbp)
 1827 1087 488955C8 		movq	%rdx, -56(%rbp)
 1828              		.loc 3 429 1
 1829 108b 64488B04 		movq	%fs:40, %rax
 1829      25280000 
 1829      00
 1830 1094 488945F8 		movq	%rax, -8(%rbp)
 1831 1098 31C0     		xorl	%eax, %eax
 430:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1832              		.loc 3 430 12
 1833 109a C745E800 		movl	$0, -24(%rbp)
 1833      000000
 431:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 432:libusbwrap.c  **** 	USBStatus status = queuePut(&dev->queue, (Item*)&wrapper);
 1834              		.loc 3 432 21
 1835 10a1 488B45D8 		movq	-40(%rbp), %rax
 1836 10a5 488D5008 		leaq	8(%rax), %rdx
 1837 10a9 488D45F0 		leaq	-16(%rbp), %rax
 1838 10ad 4889C6   		movq	%rax, %rsi
 1839 10b0 4889D7   		movq	%rdx, %rdi
 1840 10b3 E8000000 		call	queuePut@PLT
 1840      00
 1841 10b8 8945EC   		movl	%eax, -20(%rbp)
 433:libusbwrap.c  **** 	CHECK_STATUS(status, status, cleanup, "usbBulkWriteAsyncPrepare(): Work queue insertion error");
 1842              		.loc 3 433 2
 1843 10bb 837DEC00 		cmpl	$0, -20(%rbp)
 1844 10bf 741E     		je	.L123
 1845              		.loc 3 433 2 is_stmt 0 discriminator 1
 1846 10c1 488B45C8 		movq	-56(%rbp), %rax
 1847 10c5 488D1500 		leaq	.LC23(%rip), %rdx
 1847      000000
 1848 10cc 4889D6   		movq	%rdx, %rsi
 1849 10cf 4889C7   		movq	%rax, %rdi
 1850 10d2 E8000000 		call	errPrefix@PLT
 1850      00
 1851 10d7 8B45EC   		movl	-20(%rbp), %eax
 1852 10da 8945E8   		movl	%eax, -24(%rbp)
 1853 10dd EB0F     		jmp	.L124
 1854              	.L123:
 434:libusbwrap.c  **** 	*buffer = wrapper->buffer;
 1855              		.loc 3 434 19 is_stmt 1
 1856 10df 488B45F0 		movq	-16(%rbp), %rax
 1857              		.loc 3 434 12
 1858 10e3 488D5010 		leaq	16(%rax), %rdx
 1859              		.loc 3 434 10
 1860 10e7 488B45D0 		movq	-48(%rbp), %rax
 1861 10eb 488910   		movq	%rdx, (%rax)
 1862              	.L124:
 435:libusbwrap.c  **** cleanup:
 436:libusbwrap.c  **** 	return retVal;
 1863              		.loc 3 436 9
 1864 10ee 8B45E8   		movl	-24(%rbp), %eax
 437:libusbwrap.c  **** }
 1865              		.loc 3 437 1
 1866 10f1 488B55F8 		movq	-8(%rbp), %rdx
 1867 10f5 64482B14 		subq	%fs:40, %rdx
 1867      25280000 
 1867      00
 1868 10fe 7405     		je	.L126
 1869 1100 E8000000 		call	__stack_chk_fail@PLT
 1869      00
 1870              	.L126:
 1871 1105 C9       		leave
 1872              		.cfi_def_cfa 7, 8
 1873 1106 C3       		ret
 1874              		.cfi_endproc
 1875              	.LFE39:
 1877              		.section	.rodata
 1878 043f 00       		.align 8
 1879              	.LC24:
 1880 0440 75736242 		.string	"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000"
 1880      756C6B57 
 1880      72697465 
 1880      4173796E 
 1880      63537562 
 1881 047b 00000000 		.align 8
 1881      00
 1882              	.LC25:
 1883 0480 75736242 		.string	"usbBulkWriteAsyncSubmit(): Work queue insertion error"
 1883      756C6B57 
 1883      72697465 
 1883      4173796E 
 1883      63537562 
 1884 04b6 0000     		.align 8
 1885              	.LC26:
 1886 04b8 75736242 		.string	"usbBulkWriteAsyncSubmit(): Submission error: %s"
 1886      756C6B57 
 1886      72697465 
 1886      4173796E 
 1886      63537562 
 1887              		.text
 1888              		.globl	usbBulkWriteAsyncSubmit
 1890              	usbBulkWriteAsyncSubmit:
 1891              	.LFB40:
 438:libusbwrap.c  **** 
 439:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncSubmit(
 440:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint32 length, uint32 timeout, const char **error)
 441:libusbwrap.c  **** {
 1892              		.loc 3 441 1
 1893              		.cfi_startproc
 1894 1107 F30F1EFA 		endbr64
 1895 110b 55       		pushq	%rbp
 1896              		.cfi_def_cfa_offset 16
 1897              		.cfi_offset 6, -16
 1898 110c 4889E5   		movq	%rsp, %rbp
 1899              		.cfi_def_cfa_register 6
 1900 110f 4883EC50 		subq	$80, %rsp
 1901 1113 48897DC8 		movq	%rdi, -56(%rbp)
 1902 1117 89F0     		movl	%esi, %eax
 1903 1119 8955C0   		movl	%edx, -64(%rbp)
 1904 111c 894DBC   		movl	%ecx, -68(%rbp)
 1905 111f 4C8945B0 		movq	%r8, -80(%rbp)
 1906 1123 8845C4   		movb	%al, -60(%rbp)
 1907              		.loc 3 441 1
 1908 1126 64488B04 		movq	%fs:40, %rax
 1908      25280000 
 1908      00
 1909 112f 488945F8 		movq	%rax, -8(%rbp)
 1910 1133 31C0     		xorl	%eax, %eax
 442:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1911              		.loc 3 442 12
 1912 1135 C745D400 		movl	$0, -44(%rbp)
 1912      000000
 443:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 444:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 445:libusbwrap.c  **** 	int *completed;
 446:libusbwrap.c  **** 	USBStatus uStatus;
 447:libusbwrap.c  **** 	int iStatus;
 448:libusbwrap.c  **** 	CHECK_STATUS(
 1913              		.loc 3 448 2
 1914 113c 817DC000 		cmpl	$65536, -64(%rbp)
 1914      000100
 1915 1143 7622     		jbe	.L128
 1916              		.loc 3 448 2 is_stmt 0 discriminator 1
 1917 1145 488B45B0 		movq	-80(%rbp), %rax
 1918 1149 488D1500 		leaq	.LC24(%rip), %rdx
 1918      000000
 1919 1150 4889D6   		movq	%rdx, %rsi
 1920 1153 4889C7   		movq	%rax, %rdi
 1921 1156 E8000000 		call	errPrefix@PLT
 1921      00
 1922 115b C745D411 		movl	$17, -44(%rbp)
 1922      000000
 1923 1162 E9030100 		jmp	.L129
 1923      00
 1924              	.L128:
 449:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 450:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000");
 451:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1925              		.loc 3 451 12 is_stmt 1
 1926 1167 488B45C8 		movq	-56(%rbp), %rax
 1927 116b 488D5008 		leaq	8(%rax), %rdx
 1928 116f 488D45E0 		leaq	-32(%rbp), %rax
 1929 1173 4889C6   		movq	%rax, %rsi
 1930 1176 4889D7   		movq	%rdx, %rdi
 1931 1179 E8000000 		call	queuePut@PLT
 1931      00
 1932 117e 8945D8   		movl	%eax, -40(%rbp)
 452:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkWriteAsyncSubmit(): Work queue insertion error");
 1933              		.loc 3 452 2
 1934 1181 837DD800 		cmpl	$0, -40(%rbp)
 1935 1185 7421     		je	.L130
 1936              		.loc 3 452 2 is_stmt 0 discriminator 1
 1937 1187 488B45B0 		movq	-80(%rbp), %rax
 1938 118b 488D1500 		leaq	.LC25(%rip), %rdx
 1938      000000
 1939 1192 4889D6   		movq	%rdx, %rsi
 1940 1195 4889C7   		movq	%rax, %rdi
 1941 1198 E8000000 		call	errPrefix@PLT
 1941      00
 1942 119d 8B45D8   		movl	-40(%rbp), %eax
 1943 11a0 8945D4   		movl	%eax, -44(%rbp)
 1944 11a3 E9C20000 		jmp	.L129
 1944      00
 1945              	.L130:
 453:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1946              		.loc 3 453 20 is_stmt 1
 1947 11a8 488B45E0 		movq	-32(%rbp), %rax
 1948              		.loc 3 453 11
 1949 11ac 488B00   		movq	(%rax), %rax
 1950 11af 488945E8 		movq	%rax, -24(%rbp)
 454:libusbwrap.c  **** 	completed = &wrapper->completed;
 1951              		.loc 3 454 22
 1952 11b3 488B45E0 		movq	-32(%rbp), %rax
 1953              		.loc 3 454 12
 1954 11b7 4883C008 		addq	$8, %rax
 1955 11bb 488945F0 		movq	%rax, -16(%rbp)
 455:libusbwrap.c  **** 	*completed = 0;
 1956              		.loc 3 455 13
 1957 11bf 488B45F0 		movq	-16(%rbp), %rax
 1958 11c3 C7000000 		movl	$0, (%rax)
 1958      0000
 456:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1959              		.loc 3 456 9
 1960 11c9 488B45E0 		movq	-32(%rbp), %rax
 1961              		.loc 3 456 24
 1962 11cd 0FB6500C 		movzbl	12(%rax), %edx
 1963 11d1 83E2FE   		andl	$-2, %edx
 1964 11d4 88500C   		movb	%dl, 12(%rax)
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1965              		.loc 3 457 2
 1966 11d7 448B45C0 		movl	-64(%rbp), %r8d
 458:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, wrapper->buffer, (int)length,
 1967              		.loc 3 458 65
 1968 11db 488B45E0 		movq	-32(%rbp), %rax
 1969 11df 488D4810 		leaq	16(%rax), %rcx
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1970              		.loc 3 457 2
 1971 11e3 0FB655C4 		movzbl	-60(%rbp), %edx
 1972              		.loc 3 458 16
 1973 11e7 488B45C8 		movq	-56(%rbp), %rax
 1974 11eb 488B30   		movq	(%rax), %rsi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1975              		.loc 3 457 2
 1976 11ee 488B45E8 		movq	-24(%rbp), %rax
 1977 11f2 8B7DBC   		movl	-68(%rbp), %edi
 1978 11f5 57       		pushq	%rdi
 1979 11f6 FF75F0   		pushq	-16(%rbp)
 1980 11f9 4C8D0D12 		leaq	bulk_transfer_cb(%rip), %r9
 1980      FDFFFF
 1981 1200 4889C7   		movq	%rax, %rdi
 1982 1203 E80AEEFF 		call	libusb_fill_bulk_transfer
 1982      FF
 1983 1208 4883C410 		addq	$16, %rsp
 459:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 460:libusbwrap.c  **** 	);
 461:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1984              		.loc 3 461 17
 1985 120c 488B45E8 		movq	-24(%rbp), %rax
 1986 1210 C6400A02 		movb	$2, 10(%rax)
 462:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1987              		.loc 3 462 12
 1988 1214 488B45E8 		movq	-24(%rbp), %rax
 1989 1218 4889C7   		movq	%rax, %rdi
 1990 121b E8000000 		call	libusb_submit_transfer@PLT
 1990      00
 1991 1220 8945DC   		movl	%eax, -36(%rbp)
 463:libusbwrap.c  **** 	CHECK_STATUS(
 1992              		.loc 3 463 2
 1993 1223 837DDC00 		cmpl	$0, -36(%rbp)
 1994 1227 7431     		je	.L131
 1995              		.loc 3 463 2 is_stmt 0 discriminator 1
 1996 1229 8B45DC   		movl	-36(%rbp), %eax
 1997 122c 89C7     		movl	%eax, %edi
 1998 122e E8000000 		call	libusb_error_name@PLT
 1998      00
 1999 1233 4889C2   		movq	%rax, %rdx
 2000 1236 488B45B0 		movq	-80(%rbp), %rax
 2001 123a 488D0D00 		leaq	.LC26(%rip), %rcx
 2001      000000
 2002 1241 4889CE   		movq	%rcx, %rsi
 2003 1244 4889C7   		movq	%rax, %rdi
 2004 1247 B8000000 		movl	$0, %eax
 2004      00
 2005 124c E8000000 		call	errRender@PLT
 2005      00
 2006 1251 C745D40E 		movl	$14, -44(%rbp)
 2006      000000
 2007 1258 EB10     		jmp	.L129
 2008              	.L131:
 464:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 465:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Submission error: %s", libusb_error_name(iStatus));
 466:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 2009              		.loc 3 466 2 is_stmt 1
 2010 125a 488B45C8 		movq	-56(%rbp), %rax
 2011 125e 4883C008 		addq	$8, %rax
 2012 1262 4889C7   		movq	%rax, %rdi
 2013 1265 E8000000 		call	queueCommitPut@PLT
 2013      00
 2014              	.L129:
 467:libusbwrap.c  **** cleanup:
 468:libusbwrap.c  **** 	return retVal;
 2015              		.loc 3 468 9
 2016 126a 8B45D4   		movl	-44(%rbp), %eax
 469:libusbwrap.c  **** }
 2017              		.loc 3 469 1
 2018 126d 488B55F8 		movq	-8(%rbp), %rdx
 2019 1271 64482B14 		subq	%fs:40, %rdx
 2019      25280000 
 2019      00
 2020 127a 7405     		je	.L133
 2021 127c E8000000 		call	__stack_chk_fail@PLT
 2021      00
 2022              	.L133:
 2023 1281 C9       		leave
 2024              		.cfi_def_cfa 7, 8
 2025 1282 C3       		ret
 2026              		.cfi_endproc
 2027              	.LFE40:
 2029              		.section	.rodata
 2030              		.align 8
 2031              	.LC27:
 2032 04e8 75736242 		.string	"usbBulkReadAsync(): Transfer length exceeds 0x10000"
 2032      756C6B52 
 2032      65616441 
 2032      73796E63 
 2032      28293A20 
 2033 051c 00000000 		.align 8
 2034              	.LC28:
 2035 0520 75736242 		.string	"usbBulkReadAsync(): Work queue insertion error"
 2035      756C6B52 
 2035      65616441 
 2035      73796E63 
 2035      28293A20 
 2036 054f 00       		.align 8
 2037              	.LC29:
 2038 0550 75736242 		.string	"usbBulkReadAsync(): Submission error: %s"
 2038      756C6B52 
 2038      65616441 
 2038      73796E63 
 2038      28293A20 
 2039              		.text
 2040              		.globl	usbBulkReadAsync
 2042              	usbBulkReadAsync:
 2043              	.LFB41:
 470:libusbwrap.c  **** 
 471:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkReadAsync(
 472:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *buffer, uint32 length, uint32 timeout, const char **
 473:libusbwrap.c  **** {
 2044              		.loc 3 473 1
 2045              		.cfi_startproc
 2046 1283 F30F1EFA 		endbr64
 2047 1287 55       		pushq	%rbp
 2048              		.cfi_def_cfa_offset 16
 2049              		.cfi_offset 6, -16
 2050 1288 4889E5   		movq	%rsp, %rbp
 2051              		.cfi_def_cfa_register 6
 2052 128b 4883EC60 		subq	$96, %rsp
 2053 128f 48897DC8 		movq	%rdi, -56(%rbp)
 2054 1293 89F0     		movl	%esi, %eax
 2055 1295 488955B8 		movq	%rdx, -72(%rbp)
 2056 1299 894DC0   		movl	%ecx, -64(%rbp)
 2057 129c 448945B4 		movl	%r8d, -76(%rbp)
 2058 12a0 4C894DA8 		movq	%r9, -88(%rbp)
 2059 12a4 8845C4   		movb	%al, -60(%rbp)
 2060              		.loc 3 473 1
 2061 12a7 64488B04 		movq	%fs:40, %rax
 2061      25280000 
 2061      00
 2062 12b0 488945F8 		movq	%rax, -8(%rbp)
 2063 12b4 31C0     		xorl	%eax, %eax
 474:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 2064              		.loc 3 474 12
 2065 12b6 C745D400 		movl	$0, -44(%rbp)
 2065      000000
 475:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 476:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 477:libusbwrap.c  **** 	int *completed;
 478:libusbwrap.c  **** 	USBStatus uStatus;
 479:libusbwrap.c  **** 	int iStatus;
 480:libusbwrap.c  **** 	CHECK_STATUS(
 2066              		.loc 3 480 2
 2067 12bd 817DC000 		cmpl	$65536, -64(%rbp)
 2067      000100
 2068 12c4 7622     		jbe	.L135
 2069              		.loc 3 480 2 is_stmt 0 discriminator 1
 2070 12c6 488B45A8 		movq	-88(%rbp), %rax
 2071 12ca 488D1500 		leaq	.LC27(%rip), %rdx
 2071      000000
 2072 12d1 4889D6   		movq	%rdx, %rsi
 2073 12d4 4889C7   		movq	%rax, %rdi
 2074 12d7 E8000000 		call	errPrefix@PLT
 2074      00
 2075 12dc C745D411 		movl	$17, -44(%rbp)
 2075      000000
 2076 12e3 E9290100 		jmp	.L136
 2076      00
 2077              	.L135:
 481:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 482:libusbwrap.c  **** 		"usbBulkReadAsync(): Transfer length exceeds 0x10000");
 483:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 2078              		.loc 3 483 12 is_stmt 1
 2079 12e8 488B45C8 		movq	-56(%rbp), %rax
 2080 12ec 488D5008 		leaq	8(%rax), %rdx
 2081 12f0 488D45E0 		leaq	-32(%rbp), %rax
 2082 12f4 4889C6   		movq	%rax, %rsi
 2083 12f7 4889D7   		movq	%rdx, %rdi
 2084 12fa E8000000 		call	queuePut@PLT
 2084      00
 2085 12ff 8945D8   		movl	%eax, -40(%rbp)
 484:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkReadAsync(): Work queue insertion error");
 2086              		.loc 3 484 2
 2087 1302 837DD800 		cmpl	$0, -40(%rbp)
 2088 1306 7421     		je	.L137
 2089              		.loc 3 484 2 is_stmt 0 discriminator 1
 2090 1308 488B45A8 		movq	-88(%rbp), %rax
 2091 130c 488D1500 		leaq	.LC28(%rip), %rdx
 2091      000000
 2092 1313 4889D6   		movq	%rdx, %rsi
 2093 1316 4889C7   		movq	%rax, %rdi
 2094 1319 E8000000 		call	errPrefix@PLT
 2094      00
 2095 131e 8B45D8   		movl	-40(%rbp), %eax
 2096 1321 8945D4   		movl	%eax, -44(%rbp)
 2097 1324 E9E80000 		jmp	.L136
 2097      00
 2098              	.L137:
 485:libusbwrap.c  **** 	transfer = wrapper->transfer;
 2099              		.loc 3 485 20 is_stmt 1
 2100 1329 488B45E0 		movq	-32(%rbp), %rax
 2101              		.loc 3 485 11
 2102 132d 488B00   		movq	(%rax), %rax
 2103 1330 488945E8 		movq	%rax, -24(%rbp)
 486:libusbwrap.c  **** 	completed = &wrapper->completed;
 2104              		.loc 3 486 22
 2105 1334 488B45E0 		movq	-32(%rbp), %rax
 2106              		.loc 3 486 12
 2107 1338 4883C008 		addq	$8, %rax
 2108 133c 488945F0 		movq	%rax, -16(%rbp)
 487:libusbwrap.c  **** 	*completed = 0;
 2109              		.loc 3 487 13
 2110 1340 488B45F0 		movq	-16(%rbp), %rax
 2111 1344 C7000000 		movl	$0, (%rax)
 2111      0000
 488:libusbwrap.c  **** 	wrapper->flags.isRead = 1;
 2112              		.loc 3 488 9
 2113 134a 488B45E0 		movq	-32(%rbp), %rax
 2114              		.loc 3 488 24
 2115 134e 0FB6500C 		movzbl	12(%rax), %edx
 2116 1352 83CA01   		orl	$1, %edx
 2117 1355 88500C   		movb	%dl, 12(%rax)
 489:libusbwrap.c  **** 	if ( buffer ) {
 2118              		.loc 3 489 5
 2119 1358 48837DB8 		cmpq	$0, -72(%rbp)
 2119      00
 2120 135d 7411     		je	.L138
 490:libusbwrap.c  **** 		wrapper->bufPtr = buffer;
 2121              		.loc 3 490 10
 2122 135f 488B45E0 		movq	-32(%rbp), %rax
 2123              		.loc 3 490 19
 2124 1363 488B55B8 		movq	-72(%rbp), %rdx
 2125 1367 48899010 		movq	%rdx, 65552(%rax)
 2125      000100
 2126 136e EB0C     		jmp	.L139
 2127              	.L138:
 491:libusbwrap.c  **** 	} else {
 492:libusbwrap.c  **** 		buffer = wrapper->buffer;
 2128              		.loc 3 492 19
 2129 1370 488B45E0 		movq	-32(%rbp), %rax
 2130              		.loc 3 492 10
 2131 1374 4883C010 		addq	$16, %rax
 2132 1378 488945B8 		movq	%rax, -72(%rbp)
 2133              	.L139:
 493:libusbwrap.c  **** 	}
 494:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 2134              		.loc 3 494 2
 2135 137c 448B45C0 		movl	-64(%rbp), %r8d
 2136 1380 0FB645C4 		movzbl	-60(%rbp), %eax
 2137 1384 83C880   		orl	$-128, %eax
 2138 1387 0FB6D0   		movzbl	%al, %edx
 495:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 2139              		.loc 3 495 16
 2140 138a 488B45C8 		movq	-56(%rbp), %rax
 2141 138e 488B30   		movq	(%rax), %rsi
 494:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 2142              		.loc 3 494 2
 2143 1391 488B4DB8 		movq	-72(%rbp), %rcx
 2144 1395 488B45E8 		movq	-24(%rbp), %rax
 2145 1399 8B7DB4   		movl	-76(%rbp), %edi
 2146 139c 57       		pushq	%rdi
 2147 139d FF75F0   		pushq	-16(%rbp)
 2148 13a0 4C8D0D6B 		leaq	bulk_transfer_cb(%rip), %r9
 2148      FBFFFF
 2149 13a7 4889C7   		movq	%rax, %rdi
 2150 13aa E863ECFF 		call	libusb_fill_bulk_transfer
 2150      FF
 2151 13af 4883C410 		addq	$16, %rsp
 496:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 497:libusbwrap.c  **** 	);
 498:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 2152              		.loc 3 498 17
 2153 13b3 488B45E8 		movq	-24(%rbp), %rax
 2154 13b7 C6400A02 		movb	$2, 10(%rax)
 499:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 2155              		.loc 3 499 12
 2156 13bb 488B45E8 		movq	-24(%rbp), %rax
 2157 13bf 4889C7   		movq	%rax, %rdi
 2158 13c2 E8000000 		call	libusb_submit_transfer@PLT
 2158      00
 2159 13c7 8945DC   		movl	%eax, -36(%rbp)
 500:libusbwrap.c  **** 	CHECK_STATUS(
 2160              		.loc 3 500 2
 2161 13ca 837DDC00 		cmpl	$0, -36(%rbp)
 2162 13ce 7431     		je	.L140
 2163              		.loc 3 500 2 is_stmt 0 discriminator 1
 2164 13d0 8B45DC   		movl	-36(%rbp), %eax
 2165 13d3 89C7     		movl	%eax, %edi
 2166 13d5 E8000000 		call	libusb_error_name@PLT
 2166      00
 2167 13da 4889C2   		movq	%rax, %rdx
 2168 13dd 488B45A8 		movq	-88(%rbp), %rax
 2169 13e1 488D0D00 		leaq	.LC29(%rip), %rcx
 2169      000000
 2170 13e8 4889CE   		movq	%rcx, %rsi
 2171 13eb 4889C7   		movq	%rax, %rdi
 2172 13ee B8000000 		movl	$0, %eax
 2172      00
 2173 13f3 E8000000 		call	errRender@PLT
 2173      00
 2174 13f8 C745D40E 		movl	$14, -44(%rbp)
 2174      000000
 2175 13ff EB10     		jmp	.L136
 2176              	.L140:
 501:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 502:libusbwrap.c  **** 		"usbBulkReadAsync(): Submission error: %s", libusb_error_name(iStatus));
 503:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 2177              		.loc 3 503 2 is_stmt 1
 2178 1401 488B45C8 		movq	-56(%rbp), %rax
 2179 1405 4883C008 		addq	$8, %rax
 2180 1409 4889C7   		movq	%rax, %rdi
 2181 140c E8000000 		call	queueCommitPut@PLT
 2181      00
 2182              	.L136:
 504:libusbwrap.c  **** cleanup:
 505:libusbwrap.c  **** 	return retVal;
 2183              		.loc 3 505 9
 2184 1411 8B45D4   		movl	-44(%rbp), %eax
 506:libusbwrap.c  **** }
 2185              		.loc 3 506 1
 2186 1414 488B55F8 		movq	-8(%rbp), %rdx
 2187 1418 64482B14 		subq	%fs:40, %rdx
 2187      25280000 
 2187      00
 2188 1421 7405     		je	.L142
 2189 1423 E8000000 		call	__stack_chk_fail@PLT
 2189      00
 2190              	.L142:
 2191 1428 C9       		leave
 2192              		.cfi_def_cfa 7, 8
 2193 1429 C3       		ret
 2194              		.cfi_endproc
 2195              	.LFE41:
 2197              		.section	.rodata
 2198 0579 00000000 		.align 8
 2198      000000
 2199              	.LC30:
 2200 0580 75736242 		.string	"usbBulkAwaitCompletion(): Work queue fetch error"
 2200      756C6B41 
 2200      77616974 
 2200      436F6D70 
 2200      6C657469 
 2201 05b1 00000000 		.align 8
 2201      000000
 2202              	.LC31:
 2203 05b8 75736242 		.string	"usbBulkAwaitCompletion(): Event error: %s"
 2203      756C6B41 
 2203      77616974 
 2203      436F6D70 
 2203      6C657469 
 2204 05e2 00000000 		.align 8
 2204      0000
 2205              	.LC32:
 2206 05e8 75736242 		.string	"usbBulkAwaitCompletion(): Timeout"
 2206      756C6B41 
 2206      77616974 
 2206      436F6D70 
 2206      6C657469 
 2207 060a 00000000 		.align 8
 2207      0000
 2208              	.LC33:
 2209 0610 75736242 		.string	"usbBulkAwaitCompletion(): Transfer error: %s"
 2209      756C6B41 
 2209      77616974 
 2209      436F6D70 
 2209      6C657469 
 2210              		.text
 2211              		.globl	usbBulkAwaitCompletion
 2213              	usbBulkAwaitCompletion:
 2214              	.LFB42:
 507:libusbwrap.c  **** 
 508:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkAwaitCompletion(
 509:libusbwrap.c  **** 	struct USBDevice *dev, struct CompletionReport *report, const char **error)
 510:libusbwrap.c  **** {
 2215              		.loc 3 510 1
 2216              		.cfi_startproc
 2217 142a F30F1EFA 		endbr64
 2218 142e 55       		pushq	%rbp
 2219              		.cfi_def_cfa_offset 16
 2220              		.cfi_offset 6, -16
 2221 142f 4889E5   		movq	%rsp, %rbp
 2222              		.cfi_def_cfa_register 6
 2223 1432 4883EC70 		subq	$112, %rsp
 2224 1436 48897DA8 		movq	%rdi, -88(%rbp)
 2225 143a 488975A0 		movq	%rsi, -96(%rbp)
 2226 143e 48895598 		movq	%rdx, -104(%rbp)
 2227              		.loc 3 510 1
 2228 1442 64488B04 		movq	%fs:40, %rax
 2228      25280000 
 2228      00
 2229 144b 488945F8 		movq	%rax, -8(%rbp)
 2230 144f 31C0     		xorl	%eax, %eax
 511:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 2231              		.loc 3 511 12
 2232 1451 C745BC00 		movl	$0, -68(%rbp)
 2232      000000
 512:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 513:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 514:libusbwrap.c  **** 	int *completed;
 515:libusbwrap.c  **** 	int iStatus;
 516:libusbwrap.c  **** 	struct timeval timeout = {UINT_MAX/1000, 1000*(UINT_MAX%1000)};
 2233              		.loc 3 516 17
 2234 1458 48C745E0 		movq	$4294967, -32(%rbp)
 2234      37894100 
 2235 1460 48C745E8 		movq	$295000, -24(%rbp)
 2235      58800400 
 517:libusbwrap.c  **** 	                         // This horrible thing should boil down to a call to poll() with
 518:libusbwrap.c  **** 	                         // timeout -1ms, which will be interpreted as "no timeout" on all
 519:libusbwrap.c  **** 	                         // platforms.
 520:libusbwrap.c  **** 	USBStatus uStatus = queueTake(&dev->queue, (Item*)&wrapper);
 2236              		.loc 3 520 22
 2237 1468 488B45A8 		movq	-88(%rbp), %rax
 2238 146c 488D5008 		leaq	8(%rax), %rdx
 2239 1470 488D45C8 		leaq	-56(%rbp), %rax
 2240 1474 4889C6   		movq	%rax, %rsi
 2241 1477 4889D7   		movq	%rdx, %rdi
 2242 147a E8000000 		call	queueTake@PLT
 2242      00
 2243 147f 8945C4   		movl	%eax, -60(%rbp)
 521:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, exit, "usbBulkAwaitCompletion(): Work queue fetch error");
 2244              		.loc 3 521 2
 2245 1482 837DC400 		cmpl	$0, -60(%rbp)
 2246 1486 7421     		je	.L144
 2247              		.loc 3 521 2 is_stmt 0 discriminator 1
 2248 1488 488B4598 		movq	-104(%rbp), %rax
 2249 148c 488D1500 		leaq	.LC30(%rip), %rdx
 2249      000000
 2250 1493 4889D6   		movq	%rdx, %rsi
 2251 1496 4889C7   		movq	%rax, %rdi
 2252 1499 E8000000 		call	errPrefix@PLT
 2252      00
 2253 149e 8B45C4   		movl	-60(%rbp), %eax
 2254 14a1 8945BC   		movl	%eax, -68(%rbp)
 2255 14a4 E9EB0100 		jmp	.L145
 2255      00
 2256              	.L144:
 522:libusbwrap.c  **** 	transfer = wrapper->transfer;
 2257              		.loc 3 522 20 is_stmt 1
 2258 14a9 488B45C8 		movq	-56(%rbp), %rax
 2259              		.loc 3 522 11
 2260 14ad 488B00   		movq	(%rax), %rax
 2261 14b0 488945D0 		movq	%rax, -48(%rbp)
 523:libusbwrap.c  **** 	completed = &wrapper->completed;
 2262              		.loc 3 523 22
 2263 14b4 488B45C8 		movq	-56(%rbp), %rax
 2264              		.loc 3 523 12
 2265 14b8 4883C008 		addq	$8, %rax
 2266 14bc 488945D8 		movq	%rax, -40(%rbp)
 524:libusbwrap.c  **** 	wrapper->bufPtr = NULL;
 2267              		.loc 3 524 9
 2268 14c0 488B45C8 		movq	-56(%rbp), %rax
 2269              		.loc 3 524 18
 2270 14c4 48C78010 		movq	$0, 65552(%rax)
 2270      00010000 
 2270      000000
 525:libusbwrap.c  **** 	while ( *completed == 0 ) {
 2271              		.loc 3 525 8
 2272 14cf E99C0000 		jmp	.L146
 2272      00
 2273              	.L152:
 526:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2274              		.loc 3 526 13
 2275 14d4 488B0500 		movq	m_ctx(%rip), %rax
 2275      000000
 2276 14db 488B55D8 		movq	-40(%rbp), %rdx
 2277 14df 488D4DE0 		leaq	-32(%rbp), %rcx
 2278 14e3 4889CE   		movq	%rcx, %rsi
 2279 14e6 4889C7   		movq	%rax, %rdi
 2280 14e9 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2280      00
 2281 14ee 8945C0   		movl	%eax, -64(%rbp)
 527:libusbwrap.c  **** 		if ( iStatus < 0 ) {
 2282              		.loc 3 527 6
 2283 14f1 837DC000 		cmpl	$0, -64(%rbp)
 2284 14f5 7979     		jns	.L146
 528:libusbwrap.c  **** 			if ( iStatus == LIBUSB_ERROR_INTERRUPTED ) {
 2285              		.loc 3 528 7
 2286 14f7 837DC0F6 		cmpl	$-10, -64(%rbp)
 2287 14fb 7502     		jne	.L147
 529:libusbwrap.c  **** 				continue;
 2288              		.loc 3 529 5 discriminator 1
 2289 14fd EB71     		jmp	.L146
 2290              	.L147:
 530:libusbwrap.c  **** 			}
 531:libusbwrap.c  **** 			if ( libusb_cancel_transfer(transfer) == LIBUSB_SUCCESS ) {
 2291              		.loc 3 531 9
 2292 14ff 488B45D0 		movq	-48(%rbp), %rax
 2293 1503 4889C7   		movq	%rax, %rdi
 2294 1506 E8000000 		call	libusb_cancel_transfer@PLT
 2294      00
 2295              		.loc 3 531 7
 2296 150b 85C0     		testl	%eax, %eax
 2297 150d 752D     		jne	.L165
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2298              		.loc 3 532 11
 2299 150f EB1E     		jmp	.L149
 2300              	.L150:
 533:libusbwrap.c  **** 					if ( libusb_handle_events_timeout_completed(m_ctx, &timeout, completed) < 0 ) {
 2301              		.loc 3 533 11
 2302 1511 488B0500 		movq	m_ctx(%rip), %rax
 2302      000000
 2303 1518 488B55D8 		movq	-40(%rbp), %rdx
 2304 151c 488D4DE0 		leaq	-32(%rbp), %rcx
 2305 1520 4889CE   		movq	%rcx, %rsi
 2306 1523 4889C7   		movq	%rax, %rdi
 2307 1526 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2307      00
 2308              		.loc 3 533 9
 2309 152b 85C0     		testl	%eax, %eax
 2310 152d 780C     		js	.L166
 2311              	.L149:
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2312              		.loc 3 532 13
 2313 152f 488B45D8 		movq	-40(%rbp), %rax
 2314 1533 8B00     		movl	(%rax), %eax
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2315              		.loc 3 532 24
 2316 1535 85C0     		testl	%eax, %eax
 2317 1537 74D8     		je	.L150
 2318 1539 EB01     		jmp	.L165
 2319              	.L166:
 534:libusbwrap.c  **** 						break;
 2320              		.loc 3 534 7
 2321 153b 90       		nop
 2322              	.L165:
 535:libusbwrap.c  **** 					}
 536:libusbwrap.c  **** 				}
 537:libusbwrap.c  **** 			}
 538:libusbwrap.c  **** 			CHECK_STATUS(
 2323              		.loc 3 538 4 discriminator 1
 2324 153c 8B45C0   		movl	-64(%rbp), %eax
 2325 153f 89C7     		movl	%eax, %edi
 2326 1541 E8000000 		call	libusb_error_name@PLT
 2326      00
 2327 1546 4889C2   		movq	%rax, %rdx
 2328 1549 488B4598 		movq	-104(%rbp), %rax
 2329 154d 488D0D00 		leaq	.LC31(%rip), %rcx
 2329      000000
 2330 1554 4889CE   		movq	%rcx, %rsi
 2331 1557 4889C7   		movq	%rax, %rdi
 2332 155a B8000000 		movl	$0, %eax
 2332      00
 2333 155f E8000000 		call	errRender@PLT
 2333      00
 2334 1564 C745BC0F 		movl	$15, -68(%rbp)
 2334      000000
 2335 156b E9140100 		jmp	.L151
 2335      00
 2336              	.L146:
 525:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2337              		.loc 3 525 10
 2338 1570 488B45D8 		movq	-40(%rbp), %rax
 2339 1574 8B00     		movl	(%rax), %eax
 525:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2340              		.loc 3 525 21
 2341 1576 85C0     		testl	%eax, %eax
 2342 1578 0F8456FF 		je	.L152
 2342      FFFF
 539:libusbwrap.c  **** 				true, USB_ASYNC_EVENT, commit,
 540:libusbwrap.c  **** 				"usbBulkAwaitCompletion(): Event error: %s", libusb_error_name(iStatus));
 541:libusbwrap.c  **** 		}
 542:libusbwrap.c  **** 	}
 543:libusbwrap.c  **** 
 544:libusbwrap.c  **** 	report->buffer = transfer->buffer;
 2343              		.loc 3 544 27
 2344 157e 488B45D0 		movq	-48(%rbp), %rax
 2345 1582 488B5030 		movq	48(%rax), %rdx
 2346              		.loc 3 544 17
 2347 1586 488B45A0 		movq	-96(%rbp), %rax
 2348 158a 488910   		movq	%rdx, (%rax)
 545:libusbwrap.c  **** 	report->requestLength = (uint32)transfer->length;
 2349              		.loc 3 545 42
 2350 158d 488B45D0 		movq	-48(%rbp), %rax
 2351 1591 8B4014   		movl	20(%rax), %eax
 2352              		.loc 3 545 26
 2353 1594 89C2     		movl	%eax, %edx
 2354              		.loc 3 545 24
 2355 1596 488B45A0 		movq	-96(%rbp), %rax
 2356 159a 895008   		movl	%edx, 8(%rax)
 546:libusbwrap.c  **** 	report->actualLength = (uint32)transfer->actual_length;
 2357              		.loc 3 546 41
 2358 159d 488B45D0 		movq	-48(%rbp), %rax
 2359 15a1 8B4018   		movl	24(%rax), %eax
 2360              		.loc 3 546 25
 2361 15a4 89C2     		movl	%eax, %edx
 2362              		.loc 3 546 23
 2363 15a6 488B45A0 		movq	-96(%rbp), %rax
 2364 15aa 89500C   		movl	%edx, 12(%rax)
 547:libusbwrap.c  **** 	report->flags = wrapper->flags;
 2365              		.loc 3 547 25
 2366 15ad 488B55C8 		movq	-56(%rbp), %rdx
 2367              		.loc 3 547 16
 2368 15b1 488B45A0 		movq	-96(%rbp), %rax
 2369 15b5 8B520C   		movl	12(%rdx), %edx
 2370 15b8 895010   		movl	%edx, 16(%rax)
 548:libusbwrap.c  **** 
 549:libusbwrap.c  **** 	switch ( transfer->status ) {
 2371              		.loc 3 549 19
 2372 15bb 488B45D0 		movq	-48(%rbp), %rax
 2373 15bf 8B4010   		movl	16(%rax), %eax
 2374              		.loc 3 549 2
 2375 15c2 83F806   		cmpl	$6, %eax
 2376 15c5 7759     		ja	.L153
 2377 15c7 89C0     		movl	%eax, %eax
 2378 15c9 488D1485 		leaq	0(,%rax,4), %rdx
 2378      00000000 
 2379 15d1 488D0500 		leaq	.L155(%rip), %rax
 2379      000000
 2380 15d8 8B0402   		movl	(%rdx,%rax), %eax
 2381 15db 4898     		cltq
 2382 15dd 488D1500 		leaq	.L155(%rip), %rdx
 2382      000000
 2383 15e4 4801D0   		addq	%rdx, %rax
 2384 15e7 3EFFE0   		notrack jmp	*%rax
 2385              		.section	.rodata
 2386 063d 000000   		.align 4
 2387              		.align 4
 2388              	.L155:
 2389 0640 00000000 		.long	.L160-.L155
 2390 0644 00000000 		.long	.L158-.L155
 2391 0648 00000000 		.long	.L159-.L155
 2392 064c 00000000 		.long	.L158-.L155
 2393 0650 00000000 		.long	.L157-.L155
 2394 0654 00000000 		.long	.L156-.L155
 2395 0658 00000000 		.long	.L154-.L155
 2396              		.text
 2397              	.L160:
 550:libusbwrap.c  **** 	case LIBUSB_TRANSFER_COMPLETED:
 551:libusbwrap.c  **** 		iStatus = 0;
 2398              		.loc 3 551 11
 2399 15ea C745C000 		movl	$0, -64(%rbp)
 2399      000000
 552:libusbwrap.c  **** 		break;
 2400              		.loc 3 552 3
 2401 15f1 EB34     		jmp	.L161
 2402              	.L159:
 553:libusbwrap.c  **** 	case LIBUSB_TRANSFER_TIMED_OUT:
 554:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_TIMEOUT;
 2403              		.loc 3 554 11
 2404 15f3 C745C0F9 		movl	$-7, -64(%rbp)
 2404      FFFFFF
 555:libusbwrap.c  **** 		break;
 2405              		.loc 3 555 3
 2406 15fa EB2B     		jmp	.L161
 2407              	.L157:
 556:libusbwrap.c  **** 	case LIBUSB_TRANSFER_STALL:
 557:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_PIPE;
 2408              		.loc 3 557 11
 2409 15fc C745C0F7 		movl	$-9, -64(%rbp)
 2409      FFFFFF
 558:libusbwrap.c  **** 		break;
 2410              		.loc 3 558 3
 2411 1603 EB22     		jmp	.L161
 2412              	.L154:
 559:libusbwrap.c  **** 	case LIBUSB_TRANSFER_OVERFLOW:
 560:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OVERFLOW;
 2413              		.loc 3 560 11
 2414 1605 C745C0F8 		movl	$-8, -64(%rbp)
 2414      FFFFFF
 561:libusbwrap.c  **** 		break;
 2415              		.loc 3 561 3
 2416 160c EB19     		jmp	.L161
 2417              	.L156:
 562:libusbwrap.c  **** 	case LIBUSB_TRANSFER_NO_DEVICE:
 563:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_NO_DEVICE;
 2418              		.loc 3 563 11
 2419 160e C745C0FC 		movl	$-4, -64(%rbp)
 2419      FFFFFF
 564:libusbwrap.c  **** 		break;
 2420              		.loc 3 564 3
 2421 1615 EB10     		jmp	.L161
 2422              	.L158:
 565:libusbwrap.c  **** 	case LIBUSB_TRANSFER_ERROR:
 566:libusbwrap.c  **** 	case LIBUSB_TRANSFER_CANCELLED:
 567:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_IO;
 2423              		.loc 3 567 11
 2424 1617 C745C0FF 		movl	$-1, -64(%rbp)
 2424      FFFFFF
 568:libusbwrap.c  **** 		break;
 2425              		.loc 3 568 3
 2426 161e EB07     		jmp	.L161
 2427              	.L153:
 569:libusbwrap.c  **** 	default:
 570:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OTHER;
 2428              		.loc 3 570 11
 2429 1620 C745C09D 		movl	$-99, -64(%rbp)
 2429      FFFFFF
 2430              	.L161:
 571:libusbwrap.c  **** 	}
 572:libusbwrap.c  **** 	CHECK_STATUS(
 2431              		.loc 3 572 2
 2432 1627 837DC0F9 		cmpl	$-7, -64(%rbp)
 2433 162b 751F     		jne	.L162
 2434              		.loc 3 572 2 is_stmt 0 discriminator 1
 2435 162d 488B4598 		movq	-104(%rbp), %rax
 2436 1631 488D1500 		leaq	.LC32(%rip), %rdx
 2436      000000
 2437 1638 4889D6   		movq	%rdx, %rsi
 2438 163b 4889C7   		movq	%rax, %rdi
 2439 163e E8000000 		call	errPrefix@PLT
 2439      00
 2440 1643 C745BC12 		movl	$18, -68(%rbp)
 2440      000000
 2441 164a EB38     		jmp	.L151
 2442              	.L162:
 573:libusbwrap.c  **** 		iStatus == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, commit,
 574:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Timeout");
 575:libusbwrap.c  **** 	CHECK_STATUS(
 2443              		.loc 3 575 2 is_stmt 1
 2444 164c 837DC000 		cmpl	$0, -64(%rbp)
 2445 1650 7431     		je	.L167
 2446              		.loc 3 575 2 is_stmt 0 discriminator 1
 2447 1652 8B45C0   		movl	-64(%rbp), %eax
 2448 1655 89C7     		movl	%eax, %edi
 2449 1657 E8000000 		call	libusb_error_name@PLT
 2449      00
 2450 165c 4889C2   		movq	%rax, %rdx
 2451 165f 488B4598 		movq	-104(%rbp), %rax
 2452 1663 488D0D00 		leaq	.LC33(%rip), %rcx
 2452      000000
 2453 166a 4889CE   		movq	%rcx, %rsi
 2454 166d 4889C7   		movq	%rax, %rdi
 2455 1670 B8000000 		movl	$0, %eax
 2455      00
 2456 1675 E8000000 		call	errRender@PLT
 2456      00
 2457 167a C745BC10 		movl	$16, -68(%rbp)
 2457      000000
 2458 1681 EB01     		jmp	.L151
 2459              	.L167:
 576:libusbwrap.c  **** 		iStatus, USB_ASYNC_TRANSFER, commit,
 577:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Transfer error: %s", libusb_error_name(iStatus));
 578:libusbwrap.c  **** commit:
 2460              		.loc 3 578 1 is_stmt 1
 2461 1683 90       		nop
 2462              	.L151:
 579:libusbwrap.c  **** 	queueCommitTake(&dev->queue);
 2463              		.loc 3 579 2
 2464 1684 488B45A8 		movq	-88(%rbp), %rax
 2465 1688 4883C008 		addq	$8, %rax
 2466 168c 4889C7   		movq	%rax, %rdi
 2467 168f E8000000 		call	queueCommitTake@PLT
 2467      00
 2468              	.L145:
 580:libusbwrap.c  **** exit:
 581:libusbwrap.c  **** 	return retVal;
 2469              		.loc 3 581 9
 2470 1694 8B45BC   		movl	-68(%rbp), %eax
 582:libusbwrap.c  **** }
 2471              		.loc 3 582 1
 2472 1697 488B55F8 		movq	-8(%rbp), %rdx
 2473 169b 64482B14 		subq	%fs:40, %rdx
 2473      25280000 
 2473      00
 2474 16a4 7405     		je	.L164
 2475 16a6 E8000000 		call	__stack_chk_fail@PLT
 2475      00
 2476              	.L164:
 2477 16ab C9       		leave
 2478              		.cfi_def_cfa 7, 8
 2479 16ac C3       		ret
 2480              		.cfi_endproc
 2481              	.LFE42:
 2483              		.globl	usbNumOutstandingRequests
 2485              	usbNumOutstandingRequests:
 2486              	.LFB43:
 583:libusbwrap.c  **** 
 584:libusbwrap.c  **** DLLEXPORT(size_t) usbNumOutstandingRequests(struct USBDevice *dev) {
 2487              		.loc 3 584 68
 2488              		.cfi_startproc
 2489 16ad F30F1EFA 		endbr64
 2490 16b1 55       		pushq	%rbp
 2491              		.cfi_def_cfa_offset 16
 2492              		.cfi_offset 6, -16
 2493 16b2 4889E5   		movq	%rsp, %rbp
 2494              		.cfi_def_cfa_register 6
 2495 16b5 4883EC08 		subq	$8, %rsp
 2496 16b9 48897DF8 		movq	%rdi, -8(%rbp)
 585:libusbwrap.c  **** 	return queueSize(&dev->queue);
 2497              		.loc 3 585 19
 2498 16bd 488B45F8 		movq	-8(%rbp), %rax
 2499 16c1 4883C008 		addq	$8, %rax
 2500              		.loc 3 585 9
 2501 16c5 4889C7   		movq	%rax, %rdi
 2502 16c8 E833E9FF 		call	queueSize
 2502      FF
 586:libusbwrap.c  **** }
 2503              		.loc 3 586 1
 2504 16cd C9       		leave
 2505              		.cfi_def_cfa 7, 8
 2506 16ce C3       		ret
 2507              		.cfi_endproc
 2508              	.LFE43:
 2510              	.Letext0:
 2511              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2512              		.file 5 "/usr/include/unistd.h"
 2513              		.file 6 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
 2514              		.file 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
 2515              		.file 8 "/home/pong/FPGALink/makestuff/common/makestuff.h"
 2516              		.file 9 "libusbwrap.h"
 2517              		.file 10 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
 2518              		.file 11 "private.h"
 2519              		.file 12 "/usr/include/stdlib.h"
 2520              		.file 13 "/usr/include/string.h"
 2521              		.file 14 "/home/pong/FPGALink/makestuff/libs/liberror/liberror.h"
 6733              		.section	.note.gnu.property,"a"
 6734              		.align 8
 6735 0000 04000000 		.long	1f - 0f
 6736 0004 10000000 		.long	4f - 1f
 6737 0008 05000000 		.long	5
 6738              	0:
 6739 000c 474E5500 		.string	"GNU"
 6740              	1:
 6741              		.align 8
 6742 0010 020000C0 		.long	0xc0000002
 6743 0014 04000000 		.long	3f - 2f
 6744              	2:
 6745 0018 03000000 		.long	0x3
 6746              	3:
 6747 001c 00000000 		.align 8
 6748              	4:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 libusbwrap.c
     /tmp/ccyas0fd.s:6      .text:0000000000000000 queueSize
     /tmp/ccyas0fd.s:28     .text:0000000000000012 libusb_fill_bulk_transfer
     /tmp/ccyas0fd.s:85     .bss:0000000000000000 m_ctx
     /tmp/ccyas0fd.s:91     .text:0000000000000088 libusbOpenWithVidPid
     /tmp/ccyas0fd.s:277    .text:0000000000000267 usbValidateVidPid
     /tmp/ccyas0fd.s:493    .text:00000000000003ed usbInitialise
     /tmp/ccyas0fd.s:558    .text:0000000000000469 usbIsDeviceAvailable
     /tmp/ccyas0fd.s:769    .text:00000000000006a7 createTransfer
     /tmp/ccyas0fd.s:827    .text:0000000000000717 destroyTransfer
     /tmp/ccyas0fd.s:877    .text:000000000000074c usbOpenDevice
     /tmp/ccyas0fd.s:1149   .text:0000000000000a73 usbCloseDevice
     /tmp/ccyas0fd.s:1210   .text:0000000000000ad4 usbControlRead
     /tmp/ccyas0fd.s:1317   .text:0000000000000bce usbControlWrite
     /tmp/ccyas0fd.s:1424   .text:0000000000000cc8 usbBulkRead
     /tmp/ccyas0fd.s:1545   .text:0000000000000df0 usbBulkWrite
     /tmp/ccyas0fd.s:1654   .text:0000000000000f12 bulk_transfer_cb
     /tmp/ccyas0fd.s:1687   .text:0000000000000f37 usbBulkWriteAsync
     /tmp/ccyas0fd.s:1814   .text:0000000000001073 usbBulkWriteAsyncPrepare
     /tmp/ccyas0fd.s:1890   .text:0000000000001107 usbBulkWriteAsyncSubmit
     /tmp/ccyas0fd.s:2042   .text:0000000000001283 usbBulkReadAsync
     /tmp/ccyas0fd.s:2213   .text:000000000000142a usbBulkAwaitCompletion
     /tmp/ccyas0fd.s:2485   .text:00000000000016ad usbNumOutstandingRequests

UNDEFINED SYMBOLS
libusb_get_device_list
libusb_error_name
errPrefix
libusb_get_device_descriptor
libusb_open
errRender
libusb_free_device_list
__stack_chk_fail
strlen
libusb_init
libusb_set_debug
strtoul
calloc
libusb_alloc_transfer
free
libusb_free_transfer
malloc
_GLOBAL_OFFSET_TABLE_
queueInit
libusb_set_configuration
libusb_claim_interface
libusb_set_interface_alt_setting
libusb_release_interface
libusb_close
queueDestroy
libusb_control_transfer
libusb_bulk_transfer
queuePut
libusb_submit_transfer
queueCommitPut
queueTake
libusb_handle_events_timeout_completed
libusb_cancel_transfer
queueCommitTake
