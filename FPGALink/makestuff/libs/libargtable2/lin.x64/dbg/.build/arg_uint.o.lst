   1              		.file	"arg_uint.c"
   2              		.text
   3              	.Ltext0:
   4              		.file 0 "/home/pong/FPGALink/makestuff/libs/libargtable2" "arg_uint.c"
   6              	resetfn:
   7              	.LFB0:
   8              		.file 1 "arg_uint.c"
   1:arg_uint.c    **** /*********************************************************************
   2:arg_uint.c    **** This file is part of the argtable2 library.
   3:arg_uint.c    **** Copyright (C) 1998-2001,2003-2011 Stewart Heitmann
   4:arg_uint.c    **** sheitmann@users.sourceforge.net
   5:arg_uint.c    **** 
   6:arg_uint.c    **** The argtable2 library is free software; you can redistribute it and/or
   7:arg_uint.c    **** modify it under the terms of the GNU Library General Public License as
   8:arg_uint.c    **** published by the Free Software Foundation; either version 2 of the
   9:arg_uint.c    **** License, or (at your option) any later version.
  10:arg_uint.c    **** 
  11:arg_uint.c    **** This software is distributed in the hope that it will be useful,
  12:arg_uint.c    **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:arg_uint.c    **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14:arg_uint.c    **** Library General Public License for more details.
  15:arg_uint.c    **** 
  16:arg_uint.c    **** You should have received a copy of the GNU Library General Public
  17:arg_uint.c    **** License along with this library; if not, write to the Free Software
  18:arg_uint.c    **** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
  19:arg_uint.c    **** USA.
  20:arg_uint.c    **** **********************************************************************/
  21:arg_uint.c    **** 
  22:arg_uint.c    **** /* config.h must be included before anything else */
  23:arg_uint.c    **** #ifdef HAVE_CONFIG_H
  24:arg_uint.c    **** #include "config.h"
  25:arg_uint.c    **** #endif
  26:arg_uint.c    **** 
  27:arg_uint.c    **** #include <ctype.h>
  28:arg_uint.c    **** 
  29:arg_uint.c    **** /* #ifdef HAVE_STDLIB_H */
  30:arg_uint.c    **** #include <stdlib.h>
  31:arg_uint.c    **** /* #endif */
  32:arg_uint.c    **** 
  33:arg_uint.c    **** #include <ctype.h>
  34:arg_uint.c    **** #include "argtable2.h"
  35:arg_uint.c    **** #include <limits.h>
  36:arg_uint.c    **** 
  37:arg_uint.c    **** /* local error codes */
  38:arg_uint.c    **** enum {EMINCOUNT=1,EMAXCOUNT,EBADINT,EOVERFLOW};
  39:arg_uint.c    **** 
  40:arg_uint.c    **** static void resetfn(struct arg_uint *parent)
  41:arg_uint.c    ****     {
   9              		.loc 1 41 5
  10              		.cfi_startproc
  11 0000 F30F1EFA 		endbr64
  12 0004 55       		pushq	%rbp
  13              		.cfi_def_cfa_offset 16
  14              		.cfi_offset 6, -16
  15 0005 4889E5   		movq	%rsp, %rbp
  16              		.cfi_def_cfa_register 6
  17 0008 48897DF8 		movq	%rdi, -8(%rbp)
  42:arg_uint.c    ****     /*printf("%s:resetfn(%p)\n",__FILE__,parent);*/
  43:arg_uint.c    ****     parent->count=0;
  18              		.loc 1 43 18
  19 000c 488B45F8 		movq	-8(%rbp), %rax
  20 0010 C7406000 		movl	$0, 96(%rax)
  20      000000
  44:arg_uint.c    ****     }
  21              		.loc 1 44 5
  22 0017 90       		nop
  23 0018 5D       		popq	%rbp
  24              		.cfi_def_cfa 7, 8
  25 0019 C3       		ret
  26              		.cfi_endproc
  27              	.LFE0:
  30              	strtol0X:
  31              	.LFB1:
  45:arg_uint.c    **** 
  46:arg_uint.c    **** /* strtol0x() is like strtol() except that the numeric string is    */
  47:arg_uint.c    **** /* expected to be prefixed by "0X" where X is a user supplied char. */
  48:arg_uint.c    **** /* The string may optionally be prefixed by white space and + or -  */
  49:arg_uint.c    **** /* as in +0X123 or -0X123.                                          */
  50:arg_uint.c    **** /* Once the prefix has been scanned, the remainder of the numeric   */
  51:arg_uint.c    **** /* string is converted using strtol() with the given base.          */
  52:arg_uint.c    **** /* eg: to parse hex str="-0X12324", specify X='X' and base=16.      */
  53:arg_uint.c    **** /* eg: to parse oct str="+0o12324", specify X='O' and base=8.       */
  54:arg_uint.c    **** /* eg: to parse bin str="-0B01010", specify X='B' and base=2.       */
  55:arg_uint.c    **** /* Failure of conversion is indicated by result where *endptr==str. */
  56:arg_uint.c    **** static unsigned long int strtol0X(const char* str, const char **endptr, char X, int base)
  57:arg_uint.c    ****     {
  32              		.loc 1 57 5
  33              		.cfi_startproc
  34 001a F30F1EFA 		endbr64
  35 001e 55       		pushq	%rbp
  36              		.cfi_def_cfa_offset 16
  37              		.cfi_offset 6, -16
  38 001f 4889E5   		movq	%rsp, %rbp
  39              		.cfi_def_cfa_register 6
  40 0022 53       		pushq	%rbx
  41 0023 4883EC38 		subq	$56, %rsp
  42              		.cfi_offset 3, -24
  43 0027 48897DD8 		movq	%rdi, -40(%rbp)
  44 002b 488975D0 		movq	%rsi, -48(%rbp)
  45 002f 89D0     		movl	%edx, %eax
  46 0031 894DC8   		movl	%ecx, -56(%rbp)
  47 0034 8845CC   		movb	%al, -52(%rbp)
  58:arg_uint.c    ****     unsigned long int val;               /* stores result */
  59:arg_uint.c    ****     const char *ptr=str;        /* ptr to current position in str */
  48              		.loc 1 59 17
  49 0037 488B45D8 		movq	-40(%rbp), %rax
  50 003b 488945E0 		movq	%rax, -32(%rbp)
  60:arg_uint.c    **** 
  61:arg_uint.c    ****     /* skip leading whitespace */
  62:arg_uint.c    ****     while (isspace(*ptr))
  51              		.loc 1 62 11
  52 003f EB05     		jmp	.L3
  53              	.L4:
  63:arg_uint.c    ****         ptr++;
  54              		.loc 1 63 12
  55 0041 488345E0 		addq	$1, -32(%rbp)
  55      01
  56              	.L3:
  62:arg_uint.c    ****         ptr++;
  57              		.loc 1 62 12
  58 0046 E8000000 		call	__ctype_b_loc@PLT
  58      00
  59 004b 488B10   		movq	(%rax), %rdx
  60 004e 488B45E0 		movq	-32(%rbp), %rax
  61 0052 0FB600   		movzbl	(%rax), %eax
  62 0055 480FBEC0 		movsbq	%al, %rax
  63 0059 4801C0   		addq	%rax, %rax
  64 005c 4801D0   		addq	%rdx, %rax
  65 005f 0FB700   		movzwl	(%rax), %eax
  66 0062 0FB7C0   		movzwl	%ax, %eax
  67 0065 25002000 		andl	$8192, %eax
  67      00
  68 006a 85C0     		testl	%eax, %eax
  69 006c 75D3     		jne	.L4
  64:arg_uint.c    ****     /* printf("1) %s\n",ptr); */
  65:arg_uint.c    **** 
  66:arg_uint.c    ****     /* '0X' prefix */
  67:arg_uint.c    ****     if ((*ptr++)!='0')
  70              		.loc 1 67 14
  71 006e 488B45E0 		movq	-32(%rbp), %rax
  72 0072 488D5001 		leaq	1(%rax), %rdx
  73 0076 488955E0 		movq	%rdx, -32(%rbp)
  74              		.loc 1 67 10
  75 007a 0FB600   		movzbl	(%rax), %eax
  76              		.loc 1 67 8
  77 007d 3C30     		cmpb	$48, %al
  78 007f 7412     		je	.L5
  68:arg_uint.c    ****         { 
  69:arg_uint.c    ****         /* printf("failed to detect '0'\n"); */
  70:arg_uint.c    ****         *endptr=str;
  79              		.loc 1 70 16
  80 0081 488B45D0 		movq	-48(%rbp), %rax
  81 0085 488B55D8 		movq	-40(%rbp), %rdx
  82 0089 488910   		movq	%rdx, (%rax)
  71:arg_uint.c    ****         return 0;
  83              		.loc 1 71 16
  84 008c B8000000 		movl	$0, %eax
  84      00
  85 0091 EB79     		jmp	.L6
  86              	.L5:
  72:arg_uint.c    ****         }
  73:arg_uint.c    ****    /* printf("3) %s\n",ptr); */
  74:arg_uint.c    ****    if (toupper(*ptr++)!=toupper(X))
  87              		.loc 1 74 20
  88 0093 488B45E0 		movq	-32(%rbp), %rax
  89 0097 488D5001 		leaq	1(%rax), %rdx
  90 009b 488955E0 		movq	%rdx, -32(%rbp)
  91              		.loc 1 74 16
  92 009f 0FB600   		movzbl	(%rax), %eax
  93              		.loc 1 74 8
  94 00a2 0FBEC0   		movsbl	%al, %eax
  95 00a5 89C7     		movl	%eax, %edi
  96 00a7 E8000000 		call	toupper@PLT
  96      00
  97 00ac 89C3     		movl	%eax, %ebx
  98              		.loc 1 74 25
  99 00ae 0FBE45CC 		movsbl	-52(%rbp), %eax
 100 00b2 89C7     		movl	%eax, %edi
 101 00b4 E8000000 		call	toupper@PLT
 101      00
 102              		.loc 1 74 7
 103 00b9 39C3     		cmpl	%eax, %ebx
 104 00bb 7412     		je	.L7
  75:arg_uint.c    ****         {
  76:arg_uint.c    ****         /* printf("failed to detect '%c'\n",X); */
  77:arg_uint.c    ****         *endptr=str;
 105              		.loc 1 77 16
 106 00bd 488B45D0 		movq	-48(%rbp), %rax
 107 00c1 488B55D8 		movq	-40(%rbp), %rdx
 108 00c5 488910   		movq	%rdx, (%rax)
  78:arg_uint.c    ****         return 0;
 109              		.loc 1 78 16
 110 00c8 B8000000 		movl	$0, %eax
 110      00
 111 00cd EB3D     		jmp	.L6
 112              	.L7:
  79:arg_uint.c    ****         }
  80:arg_uint.c    ****     /* printf("4) %s\n",ptr); */
  81:arg_uint.c    **** 
  82:arg_uint.c    ****     /* attempt conversion on remainder of string using strtol() */
  83:arg_uint.c    ****     val = strtoul(ptr,(char**)endptr,base);
 113              		.loc 1 83 11
 114 00cf 8B55C8   		movl	-56(%rbp), %edx
 115 00d2 488B4DD0 		movq	-48(%rbp), %rcx
 116 00d6 488B45E0 		movq	-32(%rbp), %rax
 117 00da 4889CE   		movq	%rcx, %rsi
 118 00dd 4889C7   		movq	%rax, %rdi
 119 00e0 E8000000 		call	strtoul@PLT
 119      00
 120 00e5 488945E8 		movq	%rax, -24(%rbp)
  84:arg_uint.c    ****     if (*endptr==ptr)
 121              		.loc 1 84 9
 122 00e9 488B45D0 		movq	-48(%rbp), %rax
 123 00ed 488B00   		movq	(%rax), %rax
 124              		.loc 1 84 8
 125 00f0 483945E0 		cmpq	%rax, -32(%rbp)
 126 00f4 7512     		jne	.L8
  85:arg_uint.c    ****         {
  86:arg_uint.c    ****         /* conversion failed */
  87:arg_uint.c    ****         *endptr=str;
 127              		.loc 1 87 16
 128 00f6 488B45D0 		movq	-48(%rbp), %rax
 129 00fa 488B55D8 		movq	-40(%rbp), %rdx
 130 00fe 488910   		movq	%rdx, (%rax)
  88:arg_uint.c    ****         return 0;
 131              		.loc 1 88 16
 132 0101 B8000000 		movl	$0, %eax
 132      00
 133 0106 EB04     		jmp	.L6
 134              	.L8:
  89:arg_uint.c    ****         }
  90:arg_uint.c    **** 
  91:arg_uint.c    ****     /* success */
  92:arg_uint.c    ****     return val;
 135              		.loc 1 92 12
 136 0108 488B45E8 		movq	-24(%rbp), %rax
 137              	.L6:
  93:arg_uint.c    ****     }
 138              		.loc 1 93 5
 139 010c 488B5DF8 		movq	-8(%rbp), %rbx
 140 0110 C9       		leave
 141              		.cfi_def_cfa 7, 8
 142 0111 C3       		ret
 143              		.cfi_endproc
 144              	.LFE1:
 147              	detectsuffix:
 148              	.LFB2:
  94:arg_uint.c    **** 
  95:arg_uint.c    **** 
  96:arg_uint.c    **** /* Returns 1 if str matches suffix (case insensitive).    */
  97:arg_uint.c    **** /* Str may contain trailing whitespace, but nothing else. */
  98:arg_uint.c    **** static int detectsuffix(const char *str, const char *suffix)
  99:arg_uint.c    ****     {
 149              		.loc 1 99 5
 150              		.cfi_startproc
 151 0112 F30F1EFA 		endbr64
 152 0116 55       		pushq	%rbp
 153              		.cfi_def_cfa_offset 16
 154              		.cfi_offset 6, -16
 155 0117 4889E5   		movq	%rsp, %rbp
 156              		.cfi_def_cfa_register 6
 157 011a 53       		pushq	%rbx
 158 011b 4883EC18 		subq	$24, %rsp
 159              		.cfi_offset 3, -24
 160 011f 48897DE8 		movq	%rdi, -24(%rbp)
 161 0123 488975E0 		movq	%rsi, -32(%rbp)
 100:arg_uint.c    ****     /* scan pairwise through strings until mismatch detected */
 101:arg_uint.c    ****     while( toupper(*str) == toupper(*suffix) )
 162              		.loc 1 101 10
 163 0127 EB1F     		jmp	.L10
 164              	.L13:
 102:arg_uint.c    ****         {
 103:arg_uint.c    ****         /* printf("'%c' '%c'\n", *str, *suffix); */
 104:arg_uint.c    **** 
 105:arg_uint.c    ****         /* return 1 (success) if match persists until the string terminator */
 106:arg_uint.c    ****         if (*str=='\0')
 165              		.loc 1 106 13
 166 0129 488B45E8 		movq	-24(%rbp), %rax
 167 012d 0FB600   		movzbl	(%rax), %eax
 168              		.loc 1 106 12
 169 0130 84C0     		testb	%al, %al
 170 0132 750A     		jne	.L11
 107:arg_uint.c    ****            return 1; 
 171              		.loc 1 107 19
 172 0134 B8010000 		movl	$1, %eax
 172      00
 173 0139 E9800000 		jmp	.L12
 173      00
 174              	.L11:
 108:arg_uint.c    **** 
 109:arg_uint.c    ****         /* next chars */
 110:arg_uint.c    ****         str++;
 175              		.loc 1 110 12
 176 013e 488345E8 		addq	$1, -24(%rbp)
 176      01
 111:arg_uint.c    ****         suffix++;
 177              		.loc 1 111 15
 178 0143 488345E0 		addq	$1, -32(%rbp)
 178      01
 179              	.L10:
 101:arg_uint.c    ****         {
 180              		.loc 1 101 20
 181 0148 488B45E8 		movq	-24(%rbp), %rax
 182 014c 0FB600   		movzbl	(%rax), %eax
 101:arg_uint.c    ****         {
 183              		.loc 1 101 12
 184 014f 0FBEC0   		movsbl	%al, %eax
 185 0152 89C7     		movl	%eax, %edi
 186 0154 E8000000 		call	toupper@PLT
 186      00
 187 0159 89C3     		movl	%eax, %ebx
 101:arg_uint.c    ****         {
 188              		.loc 1 101 37
 189 015b 488B45E0 		movq	-32(%rbp), %rax
 190 015f 0FB600   		movzbl	(%rax), %eax
 101:arg_uint.c    ****         {
 191              		.loc 1 101 29
 192 0162 0FBEC0   		movsbl	%al, %eax
 193 0165 89C7     		movl	%eax, %edi
 194 0167 E8000000 		call	toupper@PLT
 194      00
 101:arg_uint.c    ****         {
 195              		.loc 1 101 26
 196 016c 39C3     		cmpl	%eax, %ebx
 197 016e 74B9     		je	.L13
 112:arg_uint.c    ****         }
 113:arg_uint.c    ****     /* printf("'%c' '%c' mismatch\n", *str, *suffix); */
 114:arg_uint.c    **** 
 115:arg_uint.c    ****     /* return 0 (fail) if the matching did not consume the entire suffix */
 116:arg_uint.c    ****     if (*suffix!=0)
 198              		.loc 1 116 9
 199 0170 488B45E0 		movq	-32(%rbp), %rax
 200 0174 0FB600   		movzbl	(%rax), %eax
 201              		.loc 1 116 8
 202 0177 84C0     		testb	%al, %al
 203 0179 740C     		je	.L15
 117:arg_uint.c    ****         return 0;   /* failed to consume entire suffix */
 204              		.loc 1 117 16
 205 017b B8000000 		movl	$0, %eax
 205      00
 206 0180 EB3C     		jmp	.L12
 207              	.L16:
 118:arg_uint.c    **** 
 119:arg_uint.c    ****     /* skip any remaining whitespace in str */
 120:arg_uint.c    ****     while (isspace(*str))
 121:arg_uint.c    ****         str++;
 208              		.loc 1 121 12
 209 0182 488345E8 		addq	$1, -24(%rbp)
 209      01
 210              	.L15:
 120:arg_uint.c    ****         str++;
 211              		.loc 1 120 12
 212 0187 E8000000 		call	__ctype_b_loc@PLT
 212      00
 213 018c 488B10   		movq	(%rax), %rdx
 214 018f 488B45E8 		movq	-24(%rbp), %rax
 215 0193 0FB600   		movzbl	(%rax), %eax
 216 0196 480FBEC0 		movsbq	%al, %rax
 217 019a 4801C0   		addq	%rax, %rax
 218 019d 4801D0   		addq	%rdx, %rax
 219 01a0 0FB700   		movzwl	(%rax), %eax
 220 01a3 0FB7C0   		movzwl	%ax, %eax
 221 01a6 25002000 		andl	$8192, %eax
 221      00
 222 01ab 85C0     		testl	%eax, %eax
 223 01ad 75D3     		jne	.L16
 122:arg_uint.c    **** 
 123:arg_uint.c    ****     /* return 1 (success) if we have reached end of str else return 0 (fail) */
 124:arg_uint.c    ****     return (*str=='\0') ? 1 : 0;
 224              		.loc 1 124 13
 225 01af 488B45E8 		movq	-24(%rbp), %rax
 226 01b3 0FB600   		movzbl	(%rax), %eax
 227              		.loc 1 124 29
 228 01b6 84C0     		testb	%al, %al
 229 01b8 0F94C0   		sete	%al
 230 01bb 0FB6C0   		movzbl	%al, %eax
 231              	.L12:
 125:arg_uint.c    ****     }
 232              		.loc 1 125 5
 233 01be 488B5DF8 		movq	-8(%rbp), %rbx
 234 01c2 C9       		leave
 235              		.cfi_def_cfa 7, 8
 236 01c3 C3       		ret
 237              		.cfi_endproc
 238              	.LFE2:
 240              		.section	.rodata
 241              	.LC0:
 242 0000 4B4200   		.string	"KB"
 243              	.LC1:
 244 0003 4D4200   		.string	"MB"
 245              	.LC2:
 246 0006 474200   		.string	"GB"
 247              	.LC3:
 248 0009 00       		.string	""
 249              		.text
 251              	scanfn:
 252              	.LFB3:
 126:arg_uint.c    **** 
 127:arg_uint.c    **** 
 128:arg_uint.c    **** static int scanfn(struct arg_uint *parent, const char *argval)
 129:arg_uint.c    ****     {
 253              		.loc 1 129 5
 254              		.cfi_startproc
 255 01c4 F30F1EFA 		endbr64
 256 01c8 55       		pushq	%rbp
 257              		.cfi_def_cfa_offset 16
 258              		.cfi_offset 6, -16
 259 01c9 4889E5   		movq	%rsp, %rbp
 260              		.cfi_def_cfa_register 6
 261 01cc 4883EC30 		subq	$48, %rsp
 262 01d0 48897DD8 		movq	%rdi, -40(%rbp)
 263 01d4 488975D0 		movq	%rsi, -48(%rbp)
 264              		.loc 1 129 5
 265 01d8 64488B04 		movq	%fs:40, %rax
 265      25280000 
 265      00
 266 01e1 488945F8 		movq	%rax, -8(%rbp)
 267 01e5 31C0     		xorl	%eax, %eax
 130:arg_uint.c    ****     int errorcode = 0;
 268              		.loc 1 130 9
 269 01e7 C745E400 		movl	$0, -28(%rbp)
 269      000000
 131:arg_uint.c    **** 
 132:arg_uint.c    ****     if (parent->count == parent->hdr.maxcount)
 270              		.loc 1 132 15
 271 01ee 488B45D8 		movq	-40(%rbp), %rax
 272 01f2 8B5060   		movl	96(%rax), %edx
 273              		.loc 1 132 37
 274 01f5 488B45D8 		movq	-40(%rbp), %rax
 275 01f9 8B402C   		movl	44(%rax), %eax
 276              		.loc 1 132 8
 277 01fc 39C2     		cmpl	%eax, %edx
 278 01fe 750C     		jne	.L18
 133:arg_uint.c    ****         {
 134:arg_uint.c    ****         /* maximum number of arguments exceeded */
 135:arg_uint.c    ****         errorcode = EMAXCOUNT;
 279              		.loc 1 135 19
 280 0200 C745E402 		movl	$2, -28(%rbp)
 280      000000
 281 0207 E9B70100 		jmp	.L19
 281      00
 282              	.L18:
 136:arg_uint.c    ****         }
 137:arg_uint.c    ****     else if (!argval)
 283              		.loc 1 137 13
 284 020c 48837DD0 		cmpq	$0, -48(%rbp)
 284      00
 285 0211 7516     		jne	.L20
 138:arg_uint.c    ****         {
 139:arg_uint.c    ****         /* a valid argument with no argument value was given. */
 140:arg_uint.c    ****         /* This happens when an optional argument value was invoked. */
 141:arg_uint.c    ****         /* leave parent arguiment value unaltered but still count the argument. */
 142:arg_uint.c    ****         parent->count++;
 286              		.loc 1 142 15
 287 0213 488B45D8 		movq	-40(%rbp), %rax
 288 0217 8B4060   		movl	96(%rax), %eax
 289              		.loc 1 142 22
 290 021a 8D5001   		leal	1(%rax), %edx
 291 021d 488B45D8 		movq	-40(%rbp), %rax
 292 0221 895060   		movl	%edx, 96(%rax)
 293 0224 E99A0100 		jmp	.L19
 293      00
 294              	.L20:
 295              	.LBB2:
 143:arg_uint.c    ****         }
 144:arg_uint.c    ****     else
 145:arg_uint.c    ****         {
 146:arg_uint.c    ****         unsigned long int val;
 147:arg_uint.c    ****         const char *end;
 148:arg_uint.c    **** 
 149:arg_uint.c    ****         /* attempt to extract hex integer (eg: +0x123) from argval into val conversion */
 150:arg_uint.c    ****         val = strtol0X(argval, &end, 'X', 16);
 296              		.loc 1 150 15
 297 0229 488D75E8 		leaq	-24(%rbp), %rsi
 298 022d 488B45D0 		movq	-48(%rbp), %rax
 299 0231 B9100000 		movl	$16, %ecx
 299      00
 300 0236 BA580000 		movl	$88, %edx
 300      00
 301 023b 4889C7   		movq	%rax, %rdi
 302 023e E8D7FDFF 		call	strtol0X
 302      FF
 303 0243 488945F0 		movq	%rax, -16(%rbp)
 151:arg_uint.c    ****         if (end==argval)
 304              		.loc 1 151 16
 305 0247 488B45E8 		movq	-24(%rbp), %rax
 306              		.loc 1 151 12
 307 024b 483945D0 		cmpq	%rax, -48(%rbp)
 308 024f 0F858000 		jne	.L21
 308      0000
 152:arg_uint.c    ****             {
 153:arg_uint.c    ****             /* hex failed, attempt octal conversion (eg +0o123) */
 154:arg_uint.c    ****             val = strtol0X(argval, &end, 'O', 8);
 309              		.loc 1 154 19
 310 0255 488D75E8 		leaq	-24(%rbp), %rsi
 311 0259 488B45D0 		movq	-48(%rbp), %rax
 312 025d B9080000 		movl	$8, %ecx
 312      00
 313 0262 BA4F0000 		movl	$79, %edx
 313      00
 314 0267 4889C7   		movq	%rax, %rdi
 315 026a E8ABFDFF 		call	strtol0X
 315      FF
 316 026f 488945F0 		movq	%rax, -16(%rbp)
 155:arg_uint.c    ****             if (end==argval)
 317              		.loc 1 155 20
 318 0273 488B45E8 		movq	-24(%rbp), %rax
 319              		.loc 1 155 16
 320 0277 483945D0 		cmpq	%rax, -48(%rbp)
 321 027b 7558     		jne	.L21
 156:arg_uint.c    ****                 {
 157:arg_uint.c    ****                 /* octal failed, attempt binary conversion (eg +0B101) */
 158:arg_uint.c    ****                 val = strtol0X(argval, &end, 'B', 2);
 322              		.loc 1 158 23
 323 027d 488D75E8 		leaq	-24(%rbp), %rsi
 324 0281 488B45D0 		movq	-48(%rbp), %rax
 325 0285 B9020000 		movl	$2, %ecx
 325      00
 326 028a BA420000 		movl	$66, %edx
 326      00
 327 028f 4889C7   		movq	%rax, %rdi
 328 0292 E883FDFF 		call	strtol0X
 328      FF
 329 0297 488945F0 		movq	%rax, -16(%rbp)
 159:arg_uint.c    ****                 if (end==argval)
 330              		.loc 1 159 24
 331 029b 488B45E8 		movq	-24(%rbp), %rax
 332              		.loc 1 159 20
 333 029f 483945D0 		cmpq	%rax, -48(%rbp)
 334 02a3 7530     		jne	.L21
 160:arg_uint.c    ****                     {
 161:arg_uint.c    ****                     /* binary failed, attempt decimal conversion with no prefix (eg 1234) */
 162:arg_uint.c    ****                     val = strtoul(argval, (char**)&end, 10);
 335              		.loc 1 162 27
 336 02a5 488D4DE8 		leaq	-24(%rbp), %rcx
 337 02a9 488B45D0 		movq	-48(%rbp), %rax
 338 02ad BA0A0000 		movl	$10, %edx
 338      00
 339 02b2 4889CE   		movq	%rcx, %rsi
 340 02b5 4889C7   		movq	%rax, %rdi
 341 02b8 E8000000 		call	strtoul@PLT
 341      00
 342 02bd 488945F0 		movq	%rax, -16(%rbp)
 163:arg_uint.c    ****                     if (end==argval)
 343              		.loc 1 163 28
 344 02c1 488B45E8 		movq	-24(%rbp), %rax
 345              		.loc 1 163 24
 346 02c5 483945D0 		cmpq	%rax, -48(%rbp)
 347 02c9 750A     		jne	.L21
 164:arg_uint.c    ****                         {
 165:arg_uint.c    ****                         /* all supported number formats failed */
 166:arg_uint.c    ****                         return EBADINT;
 348              		.loc 1 166 32
 349 02cb B8030000 		movl	$3, %eax
 349      00
 350 02d0 E9F10000 		jmp	.L22
 350      00
 351              	.L21:
 167:arg_uint.c    ****                         }
 168:arg_uint.c    ****                     }
 169:arg_uint.c    ****                 }
 170:arg_uint.c    ****             }
 171:arg_uint.c    **** 
 172:arg_uint.c    ****         /* Detect any suffixes (KB,MB,GB) and multiply argument value appropriately. */
 173:arg_uint.c    ****         /* We need to be mindful of integer overflows when using such big numbers.   */
 174:arg_uint.c    ****         if (detectsuffix(end,"KB"))             /* kilobytes */
 352              		.loc 1 174 13
 353 02d5 488B45E8 		movq	-24(%rbp), %rax
 354 02d9 488D1500 		leaq	.LC0(%rip), %rdx
 354      000000
 355 02e0 4889D6   		movq	%rdx, %rsi
 356 02e3 4889C7   		movq	%rax, %rdi
 357 02e6 E827FEFF 		call	detectsuffix
 357      FF
 358              		.loc 1 174 12
 359 02eb 85C0     		testl	%eax, %eax
 360 02ed 7420     		je	.L23
 175:arg_uint.c    ****             {
 176:arg_uint.c    ****             if ( val > UINT_MAX/1024 )
 361              		.loc 1 176 16
 362 02ef 48817DF0 		cmpq	$4194303, -16(%rbp)
 362      FFFF3F00 
 363 02f7 760C     		jbe	.L24
 177:arg_uint.c    ****                 errorcode = EOVERFLOW;          /* Overflow would occur if we proceed */
 364              		.loc 1 177 27
 365 02f9 C745E404 		movl	$4, -28(%rbp)
 365      000000
 366 0300 E9900000 		jmp	.L25
 366      00
 367              	.L24:
 178:arg_uint.c    ****             else
 179:arg_uint.c    ****                 val*=1024;                      /* 1KB = 1024 */
 368              		.loc 1 179 20
 369 0305 48C165F0 		salq	$10, -16(%rbp)
 369      0A
 370 030a E9860000 		jmp	.L25
 370      00
 371              	.L23:
 180:arg_uint.c    ****             }
 181:arg_uint.c    ****         else if (detectsuffix(end,"MB"))        /* megabytes */
 372              		.loc 1 181 18
 373 030f 488B45E8 		movq	-24(%rbp), %rax
 374 0313 488D1500 		leaq	.LC1(%rip), %rdx
 374      000000
 375 031a 4889D6   		movq	%rdx, %rsi
 376 031d 4889C7   		movq	%rax, %rdi
 377 0320 E8EDFDFF 		call	detectsuffix
 377      FF
 378              		.loc 1 181 17
 379 0325 85C0     		testl	%eax, %eax
 380 0327 741A     		je	.L26
 182:arg_uint.c    ****             {
 183:arg_uint.c    ****             if ( val > UINT_MAX/1048576 )
 381              		.loc 1 183 16
 382 0329 48817DF0 		cmpq	$4095, -16(%rbp)
 382      FF0F0000 
 383 0331 7609     		jbe	.L27
 184:arg_uint.c    ****                 errorcode = EOVERFLOW;          /* Overflow would occur if we proceed */
 384              		.loc 1 184 27
 385 0333 C745E404 		movl	$4, -28(%rbp)
 385      000000
 386 033a EB59     		jmp	.L25
 387              	.L27:
 185:arg_uint.c    ****             else
 186:arg_uint.c    ****                 val*=1048576;                   /* 1MB = 1024*1024 */
 388              		.loc 1 186 20
 389 033c 48C165F0 		salq	$20, -16(%rbp)
 389      14
 390 0341 EB52     		jmp	.L25
 391              	.L26:
 187:arg_uint.c    ****             }
 188:arg_uint.c    ****         else if (detectsuffix(end,"GB"))        /* gigabytes */
 392              		.loc 1 188 18
 393 0343 488B45E8 		movq	-24(%rbp), %rax
 394 0347 488D1500 		leaq	.LC2(%rip), %rdx
 394      000000
 395 034e 4889D6   		movq	%rdx, %rsi
 396 0351 4889C7   		movq	%rax, %rdi
 397 0354 E8B9FDFF 		call	detectsuffix
 397      FF
 398              		.loc 1 188 17
 399 0359 85C0     		testl	%eax, %eax
 400 035b 7417     		je	.L28
 189:arg_uint.c    ****             {
 190:arg_uint.c    ****             if ( val > UINT_MAX/1073741824 )
 401              		.loc 1 190 16
 402 035d 48837DF0 		cmpq	$3, -16(%rbp)
 402      03
 403 0362 7609     		jbe	.L29
 191:arg_uint.c    ****                 errorcode = EOVERFLOW;          /* Overflow would occur if we proceed */
 404              		.loc 1 191 27
 405 0364 C745E404 		movl	$4, -28(%rbp)
 405      000000
 406 036b EB28     		jmp	.L25
 407              	.L29:
 192:arg_uint.c    ****             else
 193:arg_uint.c    ****                 val*=1073741824;                /* 1GB = 1024*1024*1024 */
 408              		.loc 1 193 20
 409 036d 48C165F0 		salq	$30, -16(%rbp)
 409      1E
 410 0372 EB21     		jmp	.L25
 411              	.L28:
 194:arg_uint.c    ****             }
 195:arg_uint.c    ****         else if (!detectsuffix(end,""))  
 412              		.loc 1 195 19
 413 0374 488B45E8 		movq	-24(%rbp), %rax
 414 0378 488D1500 		leaq	.LC3(%rip), %rdx
 414      000000
 415 037f 4889D6   		movq	%rdx, %rsi
 416 0382 4889C7   		movq	%rax, %rdi
 417 0385 E888FDFF 		call	detectsuffix
 417      FF
 418              		.loc 1 195 17
 419 038a 85C0     		testl	%eax, %eax
 420 038c 7507     		jne	.L25
 196:arg_uint.c    ****             errorcode = EBADINT;                /* invalid suffix detected */
 421              		.loc 1 196 23
 422 038e C745E403 		movl	$3, -28(%rbp)
 422      000000
 423              	.L25:
 197:arg_uint.c    **** 
 198:arg_uint.c    ****         /* if success then store result in parent->ival[] array */
 199:arg_uint.c    ****         if (errorcode==0)
 424              		.loc 1 199 12
 425 0395 837DE400 		cmpl	$0, -28(%rbp)
 426 0399 7528     		jne	.L19
 200:arg_uint.c    ****             parent->ival[parent->count++] = val;
 427              		.loc 1 200 19
 428 039b 488B45D8 		movq	-40(%rbp), %rax
 429 039f 488B7068 		movq	104(%rax), %rsi
 430              		.loc 1 200 32
 431 03a3 488B45D8 		movq	-40(%rbp), %rax
 432 03a7 8B4060   		movl	96(%rax), %eax
 433              		.loc 1 200 39
 434 03aa 8D4801   		leal	1(%rax), %ecx
 435 03ad 488B55D8 		movq	-40(%rbp), %rdx
 436 03b1 894A60   		movl	%ecx, 96(%rdx)
 437 03b4 4898     		cltq
 438              		.loc 1 200 25
 439 03b6 48C1E002 		salq	$2, %rax
 440 03ba 4801F0   		addq	%rsi, %rax
 441              		.loc 1 200 43
 442 03bd 488B55F0 		movq	-16(%rbp), %rdx
 443 03c1 8910     		movl	%edx, (%rax)
 444              	.L19:
 445              	.LBE2:
 201:arg_uint.c    ****         }
 202:arg_uint.c    **** 
 203:arg_uint.c    ****     /* printf("%s:scanfn(%p,%p) returns %d\n",__FILE__,parent,argval,errorcode); */
 204:arg_uint.c    ****     return errorcode;
 446              		.loc 1 204 12
 447 03c3 8B45E4   		movl	-28(%rbp), %eax
 448              	.L22:
 205:arg_uint.c    ****     }
 449              		.loc 1 205 5
 450 03c6 488B55F8 		movq	-8(%rbp), %rdx
 451 03ca 64482B14 		subq	%fs:40, %rdx
 451      25280000 
 451      00
 452 03d3 7405     		je	.L31
 453 03d5 E8000000 		call	__stack_chk_fail@PLT
 453      00
 454              	.L31:
 455 03da C9       		leave
 456              		.cfi_def_cfa 7, 8
 457 03db C3       		ret
 458              		.cfi_endproc
 459              	.LFE3:
 462              	checkfn:
 463              	.LFB4:
 206:arg_uint.c    **** 
 207:arg_uint.c    **** static int checkfn(struct arg_uint *parent)
 208:arg_uint.c    ****     {
 464              		.loc 1 208 5
 465              		.cfi_startproc
 466 03dc F30F1EFA 		endbr64
 467 03e0 55       		pushq	%rbp
 468              		.cfi_def_cfa_offset 16
 469              		.cfi_offset 6, -16
 470 03e1 4889E5   		movq	%rsp, %rbp
 471              		.cfi_def_cfa_register 6
 472 03e4 48897DE8 		movq	%rdi, -24(%rbp)
 209:arg_uint.c    ****     int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;
 473              		.loc 1 209 28
 474 03e8 488B45E8 		movq	-24(%rbp), %rax
 475 03ec 8B5060   		movl	96(%rax), %edx
 476              		.loc 1 209 49
 477 03ef 488B45E8 		movq	-24(%rbp), %rax
 478 03f3 8B4028   		movl	40(%rax), %eax
 479              		.loc 1 209 72
 480 03f6 39C2     		cmpl	%eax, %edx
 481 03f8 0F9CC0   		setl	%al
 482              		.loc 1 209 9
 483 03fb 0FB6C0   		movzbl	%al, %eax
 484 03fe 8945FC   		movl	%eax, -4(%rbp)
 210:arg_uint.c    ****     /*printf("%s:checkfn(%p) returns %d\n",__FILE__,parent,errorcode);*/
 211:arg_uint.c    ****     return errorcode;
 485              		.loc 1 211 12
 486 0401 8B45FC   		movl	-4(%rbp), %eax
 212:arg_uint.c    ****     }
 487              		.loc 1 212 5
 488 0404 5D       		popq	%rbp
 489              		.cfi_def_cfa 7, 8
 490 0405 C3       		ret
 491              		.cfi_endproc
 492              	.LFE4:
 494              		.section	.rodata
 495              	.LC4:
 496 000a 25733A20 		.string	"%s: "
 496      00
 497              	.LC5:
 498 000f 6D697373 		.string	"missing option "
 498      696E6720 
 498      6F707469 
 498      6F6E2000 
 499              	.LC6:
 500 001f 0A00     		.string	"\n"
 501              	.LC7:
 502 0021 65786365 		.string	"excess option "
 502      7373206F 
 502      7074696F 
 502      6E2000
 503              		.align 8
 504              	.LC8:
 505 0030 696E7661 		.string	"invalid argument \"%s\" to option "
 505      6C696420 
 505      61726775 
 505      6D656E74 
 505      20222573 
 506              	.LC9:
 507 0051 696E7465 		.string	"integer overflow at option "
 507      67657220 
 507      6F766572 
 507      666C6F77 
 507      20617420 
 508              	.LC10:
 509 006d 2000     		.string	" "
 510              	.LC11:
 511 006f 28257320 		.string	"(%s is too large)\n"
 511      69732074 
 511      6F6F206C 
 511      61726765 
 511      290A00
 512              		.text
 514              	errorfn:
 515              	.LFB5:
 213:arg_uint.c    **** 
 214:arg_uint.c    **** static void errorfn(struct arg_uint *parent, FILE *fp, int errorcode, const char *argval, const cha
 215:arg_uint.c    ****     {
 516              		.loc 1 215 5
 517              		.cfi_startproc
 518 0406 F30F1EFA 		endbr64
 519 040a 55       		pushq	%rbp
 520              		.cfi_def_cfa_offset 16
 521              		.cfi_offset 6, -16
 522 040b 4889E5   		movq	%rsp, %rbp
 523              		.cfi_def_cfa_register 6
 524 040e 4883EC50 		subq	$80, %rsp
 525 0412 48897DD8 		movq	%rdi, -40(%rbp)
 526 0416 488975D0 		movq	%rsi, -48(%rbp)
 527 041a 8955CC   		movl	%edx, -52(%rbp)
 528 041d 48894DC0 		movq	%rcx, -64(%rbp)
 529 0421 4C8945B8 		movq	%r8, -72(%rbp)
 216:arg_uint.c    ****     const char *shortopts = parent->hdr.shortopts;
 530              		.loc 1 216 17
 531 0425 488B45D8 		movq	-40(%rbp), %rax
 532 0429 488B4008 		movq	8(%rax), %rax
 533 042d 488945E8 		movq	%rax, -24(%rbp)
 217:arg_uint.c    ****     const char *longopts  = parent->hdr.longopts;
 534              		.loc 1 217 17
 535 0431 488B45D8 		movq	-40(%rbp), %rax
 536 0435 488B4010 		movq	16(%rax), %rax
 537 0439 488945F0 		movq	%rax, -16(%rbp)
 218:arg_uint.c    ****     const char *datatype  = parent->hdr.datatype;
 538              		.loc 1 218 17
 539 043d 488B45D8 		movq	-40(%rbp), %rax
 540 0441 488B4018 		movq	24(%rax), %rax
 541 0445 488945F8 		movq	%rax, -8(%rbp)
 219:arg_uint.c    **** 
 220:arg_uint.c    ****     /* make argval NULL safe */
 221:arg_uint.c    ****     argval = argval ? argval : "";
 542              		.loc 1 221 30
 543 0449 48837DC0 		cmpq	$0, -64(%rbp)
 543      00
 544 044e 7406     		je	.L35
 545              		.loc 1 221 30 is_stmt 0 discriminator 1
 546 0450 488B45C0 		movq	-64(%rbp), %rax
 547 0454 EB07     		jmp	.L36
 548              	.L35:
 549              		.loc 1 221 30 discriminator 2
 550 0456 488D0500 		leaq	.LC3(%rip), %rax
 550      000000
 551              	.L36:
 552              		.loc 1 221 12 is_stmt 1 discriminator 4
 553 045d 488945C0 		movq	%rax, -64(%rbp)
 222:arg_uint.c    **** 
 223:arg_uint.c    ****     fprintf(fp,"%s: ",progname);
 554              		.loc 1 223 5 discriminator 4
 555 0461 488B55B8 		movq	-72(%rbp), %rdx
 556 0465 488B45D0 		movq	-48(%rbp), %rax
 557 0469 488D0D00 		leaq	.LC4(%rip), %rcx
 557      000000
 558 0470 4889CE   		movq	%rcx, %rsi
 559 0473 4889C7   		movq	%rax, %rdi
 560 0476 B8000000 		movl	$0, %eax
 560      00
 561 047b E8000000 		call	fprintf@PLT
 561      00
 224:arg_uint.c    ****     switch(errorcode)
 562              		.loc 1 224 5 discriminator 4
 563 0480 837DCC04 		cmpl	$4, -52(%rbp)
 564 0484 0F84F700 		je	.L37
 564      0000
 565              		.loc 1 224 5 is_stmt 0
 566 048a 837DCC04 		cmpl	$4, -52(%rbp)
 567 048e 0F8F4C01 		jg	.L42
 567      0000
 568 0494 837DCC03 		cmpl	$3, -52(%rbp)
 569 0498 0F84A300 		je	.L39
 569      0000
 570 049e 837DCC03 		cmpl	$3, -52(%rbp)
 571 04a2 0F8F3801 		jg	.L42
 571      0000
 572 04a8 837DCC01 		cmpl	$1, -52(%rbp)
 573 04ac 740B     		je	.L40
 574 04ae 837DCC02 		cmpl	$2, -52(%rbp)
 575 04b2 7449     		je	.L41
 225:arg_uint.c    ****         {
 226:arg_uint.c    ****         case EMINCOUNT:
 227:arg_uint.c    ****             fputs("missing option ",fp);
 228:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,datatype,"\n");
 229:arg_uint.c    ****             break;
 230:arg_uint.c    **** 
 231:arg_uint.c    ****         case EMAXCOUNT:
 232:arg_uint.c    ****             fputs("excess option ",fp);
 233:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,argval,"\n");
 234:arg_uint.c    ****             break;
 235:arg_uint.c    **** 
 236:arg_uint.c    ****         case EBADINT:
 237:arg_uint.c    ****             fprintf(fp,"invalid argument \"%s\" to option ",argval);
 238:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,datatype,"\n");
 239:arg_uint.c    ****             break;
 240:arg_uint.c    **** 
 241:arg_uint.c    ****         case EOVERFLOW:
 242:arg_uint.c    ****             fputs("integer overflow at option ",fp);
 243:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,datatype," ");
 244:arg_uint.c    ****             fprintf(fp,"(%s is too large)\n",argval);
 245:arg_uint.c    ****             break;
 246:arg_uint.c    ****         }
 247:arg_uint.c    ****     }
 576              		.loc 1 247 5 is_stmt 1
 577 04b4 E9270100 		jmp	.L42
 577      00
 578              	.L40:
 227:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,datatype,"\n");
 579              		.loc 1 227 13
 580 04b9 488B45D0 		movq	-48(%rbp), %rax
 581 04bd 4889C1   		movq	%rax, %rcx
 582 04c0 BA0F0000 		movl	$15, %edx
 582      00
 583 04c5 BE010000 		movl	$1, %esi
 583      00
 584 04ca 488D0500 		leaq	.LC5(%rip), %rax
 584      000000
 585 04d1 4889C7   		movq	%rax, %rdi
 586 04d4 E8000000 		call	fwrite@PLT
 586      00
 228:arg_uint.c    ****             break;
 587              		.loc 1 228 13
 588 04d9 488B4DF8 		movq	-8(%rbp), %rcx
 589 04dd 488B55F0 		movq	-16(%rbp), %rdx
 590 04e1 488B75E8 		movq	-24(%rbp), %rsi
 591 04e5 488B45D0 		movq	-48(%rbp), %rax
 592 04e9 4C8D0500 		leaq	.LC6(%rip), %r8
 592      000000
 593 04f0 4889C7   		movq	%rax, %rdi
 594 04f3 E8000000 		call	arg_print_option@PLT
 594      00
 229:arg_uint.c    **** 
 595              		.loc 1 229 13
 596 04f8 E9E30000 		jmp	.L38
 596      00
 597              	.L41:
 232:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,argval,"\n");
 598              		.loc 1 232 13
 599 04fd 488B45D0 		movq	-48(%rbp), %rax
 600 0501 4889C1   		movq	%rax, %rcx
 601 0504 BA0E0000 		movl	$14, %edx
 601      00
 602 0509 BE010000 		movl	$1, %esi
 602      00
 603 050e 488D0500 		leaq	.LC7(%rip), %rax
 603      000000
 604 0515 4889C7   		movq	%rax, %rdi
 605 0518 E8000000 		call	fwrite@PLT
 605      00
 233:arg_uint.c    ****             break;
 606              		.loc 1 233 13
 607 051d 488B4DC0 		movq	-64(%rbp), %rcx
 608 0521 488B55F0 		movq	-16(%rbp), %rdx
 609 0525 488B75E8 		movq	-24(%rbp), %rsi
 610 0529 488B45D0 		movq	-48(%rbp), %rax
 611 052d 4C8D0500 		leaq	.LC6(%rip), %r8
 611      000000
 612 0534 4889C7   		movq	%rax, %rdi
 613 0537 E8000000 		call	arg_print_option@PLT
 613      00
 234:arg_uint.c    **** 
 614              		.loc 1 234 13
 615 053c E99F0000 		jmp	.L38
 615      00
 616              	.L39:
 237:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,datatype,"\n");
 617              		.loc 1 237 13
 618 0541 488B55C0 		movq	-64(%rbp), %rdx
 619 0545 488B45D0 		movq	-48(%rbp), %rax
 620 0549 488D0D00 		leaq	.LC8(%rip), %rcx
 620      000000
 621 0550 4889CE   		movq	%rcx, %rsi
 622 0553 4889C7   		movq	%rax, %rdi
 623 0556 B8000000 		movl	$0, %eax
 623      00
 624 055b E8000000 		call	fprintf@PLT
 624      00
 238:arg_uint.c    ****             break;
 625              		.loc 1 238 13
 626 0560 488B4DF8 		movq	-8(%rbp), %rcx
 627 0564 488B55F0 		movq	-16(%rbp), %rdx
 628 0568 488B75E8 		movq	-24(%rbp), %rsi
 629 056c 488B45D0 		movq	-48(%rbp), %rax
 630 0570 4C8D0500 		leaq	.LC6(%rip), %r8
 630      000000
 631 0577 4889C7   		movq	%rax, %rdi
 632 057a E8000000 		call	arg_print_option@PLT
 632      00
 239:arg_uint.c    **** 
 633              		.loc 1 239 13
 634 057f EB5F     		jmp	.L38
 635              	.L37:
 242:arg_uint.c    ****             arg_print_option(fp,shortopts,longopts,datatype," ");
 636              		.loc 1 242 13
 637 0581 488B45D0 		movq	-48(%rbp), %rax
 638 0585 4889C1   		movq	%rax, %rcx
 639 0588 BA1B0000 		movl	$27, %edx
 639      00
 640 058d BE010000 		movl	$1, %esi
 640      00
 641 0592 488D0500 		leaq	.LC9(%rip), %rax
 641      000000
 642 0599 4889C7   		movq	%rax, %rdi
 643 059c E8000000 		call	fwrite@PLT
 643      00
 243:arg_uint.c    ****             fprintf(fp,"(%s is too large)\n",argval);
 644              		.loc 1 243 13
 645 05a1 488B4DF8 		movq	-8(%rbp), %rcx
 646 05a5 488B55F0 		movq	-16(%rbp), %rdx
 647 05a9 488B75E8 		movq	-24(%rbp), %rsi
 648 05ad 488B45D0 		movq	-48(%rbp), %rax
 649 05b1 4C8D0500 		leaq	.LC10(%rip), %r8
 649      000000
 650 05b8 4889C7   		movq	%rax, %rdi
 651 05bb E8000000 		call	arg_print_option@PLT
 651      00
 244:arg_uint.c    ****             break;
 652              		.loc 1 244 13
 653 05c0 488B55C0 		movq	-64(%rbp), %rdx
 654 05c4 488B45D0 		movq	-48(%rbp), %rax
 655 05c8 488D0D00 		leaq	.LC11(%rip), %rcx
 655      000000
 656 05cf 4889CE   		movq	%rcx, %rsi
 657 05d2 4889C7   		movq	%rax, %rdi
 658 05d5 B8000000 		movl	$0, %eax
 658      00
 659 05da E8000000 		call	fprintf@PLT
 659      00
 245:arg_uint.c    ****         }
 660              		.loc 1 245 13
 661 05df 90       		nop
 662              	.L38:
 663              	.L42:
 664              		.loc 1 247 5
 665 05e0 90       		nop
 666 05e1 C9       		leave
 667              		.cfi_def_cfa 7, 8
 668 05e2 C3       		ret
 669              		.cfi_endproc
 670              	.LFE5:
 672              		.globl	arg_uint0
 674              	arg_uint0:
 675              	.LFB6:
 248:arg_uint.c    **** 
 249:arg_uint.c    **** 
 250:arg_uint.c    **** struct arg_uint* arg_uint0(const char* shortopts,
 251:arg_uint.c    ****                          const char* longopts,
 252:arg_uint.c    ****                          const char *datatype,
 253:arg_uint.c    ****                          const char *glossary)
 254:arg_uint.c    ****     {
 676              		.loc 1 254 5
 677              		.cfi_startproc
 678 05e3 F30F1EFA 		endbr64
 679 05e7 55       		pushq	%rbp
 680              		.cfi_def_cfa_offset 16
 681              		.cfi_offset 6, -16
 682 05e8 4889E5   		movq	%rsp, %rbp
 683              		.cfi_def_cfa_register 6
 684 05eb 4883EC20 		subq	$32, %rsp
 685 05ef 48897DF8 		movq	%rdi, -8(%rbp)
 686 05f3 488975F0 		movq	%rsi, -16(%rbp)
 687 05f7 488955E8 		movq	%rdx, -24(%rbp)
 688 05fb 48894DE0 		movq	%rcx, -32(%rbp)
 255:arg_uint.c    ****     return arg_uintn(shortopts,longopts,datatype,0,1,glossary);
 689              		.loc 1 255 12
 690 05ff 488B4DE0 		movq	-32(%rbp), %rcx
 691 0603 488B55E8 		movq	-24(%rbp), %rdx
 692 0607 488B75F0 		movq	-16(%rbp), %rsi
 693 060b 488B45F8 		movq	-8(%rbp), %rax
 694 060f 4989C9   		movq	%rcx, %r9
 695 0612 41B80100 		movl	$1, %r8d
 695      0000
 696 0618 B9000000 		movl	$0, %ecx
 696      00
 697 061d 4889C7   		movq	%rax, %rdi
 698 0620 E8000000 		call	arg_uintn@PLT
 698      00
 256:arg_uint.c    ****     }
 699              		.loc 1 256 5
 700 0625 C9       		leave
 701              		.cfi_def_cfa 7, 8
 702 0626 C3       		ret
 703              		.cfi_endproc
 704              	.LFE6:
 706              		.globl	arg_uint1
 708              	arg_uint1:
 709              	.LFB7:
 257:arg_uint.c    **** 
 258:arg_uint.c    **** struct arg_uint* arg_uint1(const char* shortopts,
 259:arg_uint.c    ****                          const char* longopts,
 260:arg_uint.c    ****                          const char *datatype,
 261:arg_uint.c    ****                          const char *glossary)
 262:arg_uint.c    ****     {
 710              		.loc 1 262 5
 711              		.cfi_startproc
 712 0627 F30F1EFA 		endbr64
 713 062b 55       		pushq	%rbp
 714              		.cfi_def_cfa_offset 16
 715              		.cfi_offset 6, -16
 716 062c 4889E5   		movq	%rsp, %rbp
 717              		.cfi_def_cfa_register 6
 718 062f 4883EC20 		subq	$32, %rsp
 719 0633 48897DF8 		movq	%rdi, -8(%rbp)
 720 0637 488975F0 		movq	%rsi, -16(%rbp)
 721 063b 488955E8 		movq	%rdx, -24(%rbp)
 722 063f 48894DE0 		movq	%rcx, -32(%rbp)
 263:arg_uint.c    ****     return arg_uintn(shortopts,longopts,datatype,1,1,glossary);
 723              		.loc 1 263 12
 724 0643 488B4DE0 		movq	-32(%rbp), %rcx
 725 0647 488B55E8 		movq	-24(%rbp), %rdx
 726 064b 488B75F0 		movq	-16(%rbp), %rsi
 727 064f 488B45F8 		movq	-8(%rbp), %rax
 728 0653 4989C9   		movq	%rcx, %r9
 729 0656 41B80100 		movl	$1, %r8d
 729      0000
 730 065c B9010000 		movl	$1, %ecx
 730      00
 731 0661 4889C7   		movq	%rax, %rdi
 732 0664 E8000000 		call	arg_uintn@PLT
 732      00
 264:arg_uint.c    ****     }
 733              		.loc 1 264 5
 734 0669 C9       		leave
 735              		.cfi_def_cfa 7, 8
 736 066a C3       		ret
 737              		.cfi_endproc
 738              	.LFE7:
 740              		.section	.rodata
 741              	.LC12:
 742 0082 3C696E74 		.string	"<int>"
 742      3E00
 743              		.text
 744              		.globl	arg_uintn
 746              	arg_uintn:
 747              	.LFB8:
 265:arg_uint.c    **** 
 266:arg_uint.c    **** 
 267:arg_uint.c    **** struct arg_uint* arg_uintn(const char* shortopts,
 268:arg_uint.c    ****                          const char* longopts,
 269:arg_uint.c    ****                          const char *datatype,
 270:arg_uint.c    ****                          int mincount,
 271:arg_uint.c    ****                          int maxcount,
 272:arg_uint.c    ****                          const char *glossary)
 273:arg_uint.c    ****     {
 748              		.loc 1 273 5
 749              		.cfi_startproc
 750 066b F30F1EFA 		endbr64
 751 066f 55       		pushq	%rbp
 752              		.cfi_def_cfa_offset 16
 753              		.cfi_offset 6, -16
 754 0670 4889E5   		movq	%rsp, %rbp
 755              		.cfi_def_cfa_register 6
 756 0673 4883EC40 		subq	$64, %rsp
 757 0677 48897DE8 		movq	%rdi, -24(%rbp)
 758 067b 488975E0 		movq	%rsi, -32(%rbp)
 759 067f 488955D8 		movq	%rdx, -40(%rbp)
 760 0683 894DD4   		movl	%ecx, -44(%rbp)
 761 0686 448945D0 		movl	%r8d, -48(%rbp)
 762 068a 4C894DC8 		movq	%r9, -56(%rbp)
 274:arg_uint.c    ****     size_t nbytes;
 275:arg_uint.c    ****     struct arg_uint *result;
 276:arg_uint.c    **** 
 277:arg_uint.c    **** 	/* foolproof things by ensuring maxcount is not less than mincount */
 278:arg_uint.c    **** 	maxcount = (maxcount<mincount) ? mincount : maxcount;
 763              		.loc 1 278 11
 764 068e 8B55D0   		movl	-48(%rbp), %edx
 765 0691 8B45D4   		movl	-44(%rbp), %eax
 766 0694 39C2     		cmpl	%eax, %edx
 767 0696 0F4DC2   		cmovge	%edx, %eax
 768 0699 8945D0   		movl	%eax, -48(%rbp)
 279:arg_uint.c    **** 
 280:arg_uint.c    ****     nbytes = sizeof(struct arg_uint)     /* storage for struct arg_uint */
 281:arg_uint.c    ****            + maxcount * sizeof(int);    /* storage for ival[maxcount] array */
 769              		.loc 1 281 12
 770 069c 8B45D0   		movl	-48(%rbp), %eax
 771 069f 4898     		cltq
 772 06a1 4883C01C 		addq	$28, %rax
 280:arg_uint.c    ****            + maxcount * sizeof(int);    /* storage for ival[maxcount] array */
 773              		.loc 1 280 12
 774 06a5 48C1E002 		salq	$2, %rax
 775 06a9 488945F0 		movq	%rax, -16(%rbp)
 282:arg_uint.c    **** 
 283:arg_uint.c    ****     result = (struct arg_uint*)malloc(nbytes);
 776              		.loc 1 283 32
 777 06ad 488B45F0 		movq	-16(%rbp), %rax
 778 06b1 4889C7   		movq	%rax, %rdi
 779 06b4 E8000000 		call	malloc@PLT
 779      00
 780 06b9 488945F8 		movq	%rax, -8(%rbp)
 284:arg_uint.c    ****     if (result)
 781              		.loc 1 284 8
 782 06bd 48837DF8 		cmpq	$0, -8(%rbp)
 782      00
 783 06c2 0F84BE00 		je	.L48
 783      0000
 285:arg_uint.c    ****         {
 286:arg_uint.c    ****         /* init the arg_hdr struct */
 287:arg_uint.c    ****         result->hdr.flag      = ARG_HASVALUE;
 784              		.loc 1 287 31
 785 06c8 488B45F8 		movq	-8(%rbp), %rax
 786 06cc C60002   		movb	$2, (%rax)
 288:arg_uint.c    ****         result->hdr.shortopts = shortopts;
 787              		.loc 1 288 31
 788 06cf 488B45F8 		movq	-8(%rbp), %rax
 789 06d3 488B55E8 		movq	-24(%rbp), %rdx
 790 06d7 48895008 		movq	%rdx, 8(%rax)
 289:arg_uint.c    ****         result->hdr.longopts  = longopts;
 791              		.loc 1 289 31
 792 06db 488B45F8 		movq	-8(%rbp), %rax
 793 06df 488B55E0 		movq	-32(%rbp), %rdx
 794 06e3 48895010 		movq	%rdx, 16(%rax)
 290:arg_uint.c    ****         result->hdr.datatype  = datatype ? datatype : "<int>";
 795              		.loc 1 290 53
 796 06e7 48837DD8 		cmpq	$0, -40(%rbp)
 796      00
 797 06ec 7406     		je	.L49
 798              		.loc 1 290 53 is_stmt 0 discriminator 1
 799 06ee 488B45D8 		movq	-40(%rbp), %rax
 800 06f2 EB07     		jmp	.L50
 801              	.L49:
 802              		.loc 1 290 53 discriminator 2
 803 06f4 488D0500 		leaq	.LC12(%rip), %rax
 803      000000
 804              	.L50:
 805              		.loc 1 290 31 is_stmt 1 discriminator 4
 806 06fb 488B55F8 		movq	-8(%rbp), %rdx
 807 06ff 48894218 		movq	%rax, 24(%rdx)
 291:arg_uint.c    ****         result->hdr.glossary  = glossary;
 808              		.loc 1 291 31 discriminator 4
 809 0703 488B45F8 		movq	-8(%rbp), %rax
 810 0707 488B55C8 		movq	-56(%rbp), %rdx
 811 070b 48895020 		movq	%rdx, 32(%rax)
 292:arg_uint.c    ****         result->hdr.mincount  = mincount;
 812              		.loc 1 292 31 discriminator 4
 813 070f 488B45F8 		movq	-8(%rbp), %rax
 814 0713 8B55D4   		movl	-44(%rbp), %edx
 815 0716 895028   		movl	%edx, 40(%rax)
 293:arg_uint.c    ****         result->hdr.maxcount  = maxcount;
 816              		.loc 1 293 31 discriminator 4
 817 0719 488B45F8 		movq	-8(%rbp), %rax
 818 071d 8B55D0   		movl	-48(%rbp), %edx
 819 0720 89502C   		movl	%edx, 44(%rax)
 294:arg_uint.c    ****         result->hdr.parent    = result;
 820              		.loc 1 294 31 discriminator 4
 821 0723 488B45F8 		movq	-8(%rbp), %rax
 822 0727 488B55F8 		movq	-8(%rbp), %rdx
 823 072b 48895030 		movq	%rdx, 48(%rax)
 295:arg_uint.c    ****         result->hdr.resetfn   = (arg_resetfn*)resetfn;
 824              		.loc 1 295 31 discriminator 4
 825 072f 488B45F8 		movq	-8(%rbp), %rax
 826 0733 488D15C6 		leaq	resetfn(%rip), %rdx
 826      F8FFFF
 827 073a 48895038 		movq	%rdx, 56(%rax)
 296:arg_uint.c    ****         result->hdr.scanfn    = (arg_scanfn*)scanfn;
 828              		.loc 1 296 31 discriminator 4
 829 073e 488B45F8 		movq	-8(%rbp), %rax
 830 0742 488D157B 		leaq	scanfn(%rip), %rdx
 830      FAFFFF
 831 0749 48895040 		movq	%rdx, 64(%rax)
 297:arg_uint.c    ****         result->hdr.checkfn   = (arg_checkfn*)checkfn;
 832              		.loc 1 297 31 discriminator 4
 833 074d 488B45F8 		movq	-8(%rbp), %rax
 834 0751 488D1584 		leaq	checkfn(%rip), %rdx
 834      FCFFFF
 835 0758 48895048 		movq	%rdx, 72(%rax)
 298:arg_uint.c    ****         result->hdr.errorfn   = (arg_errorfn*)errorfn;
 836              		.loc 1 298 31 discriminator 4
 837 075c 488B45F8 		movq	-8(%rbp), %rax
 838 0760 488D159F 		leaq	errorfn(%rip), %rdx
 838      FCFFFF
 839 0767 48895050 		movq	%rdx, 80(%rax)
 299:arg_uint.c    **** 
 300:arg_uint.c    ****         /* store the ival[maxcount] array immediately after the arg_uint struct */
 301:arg_uint.c    ****         result->ival  = (unsigned int*)(result+1);
 840              		.loc 1 301 47 discriminator 4
 841 076b 488B45F8 		movq	-8(%rbp), %rax
 842 076f 488D5070 		leaq	112(%rax), %rdx
 843              		.loc 1 301 23 discriminator 4
 844 0773 488B45F8 		movq	-8(%rbp), %rax
 845 0777 48895068 		movq	%rdx, 104(%rax)
 302:arg_uint.c    ****         result->count = 0;
 846              		.loc 1 302 23 discriminator 4
 847 077b 488B45F8 		movq	-8(%rbp), %rax
 848 077f C7406000 		movl	$0, 96(%rax)
 848      000000
 849              	.L48:
 303:arg_uint.c    ****         }
 304:arg_uint.c    ****     /*printf("arg_uintn() returns %p\n",result);*/
 305:arg_uint.c    ****     return result;
 850              		.loc 1 305 12
 851 0786 488B45F8 		movq	-8(%rbp), %rax
 306:arg_uint.c    ****     }
 852              		.loc 1 306 5
 853 078a C9       		leave
 854              		.cfi_def_cfa 7, 8
 855 078b C3       		ret
 856              		.cfi_endproc
 857              	.LFE8:
 859              	.Letext0:
 860              		.file 2 "/usr/include/x86_64-linux-gnu/bits/types.h"
 861              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
 862              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
 863              		.file 5 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
 864              		.file 6 "/usr/include/ctype.h"
 865              		.file 7 "argtable2.h"
 866              		.file 8 "/usr/include/stdlib.h"
 867              		.file 9 "/usr/include/stdio.h"
 2846              		.section	.note.gnu.property,"a"
 2847              		.align 8
 2848 0000 04000000 		.long	1f - 0f
 2849 0004 10000000 		.long	4f - 1f
 2850 0008 05000000 		.long	5
 2851              	0:
 2852 000c 474E5500 		.string	"GNU"
 2853              	1:
 2854              		.align 8
 2855 0010 020000C0 		.long	0xc0000002
 2856 0014 04000000 		.long	3f - 2f
 2857              	2:
 2858 0018 03000000 		.long	0x3
 2859              	3:
 2860 001c 00000000 		.align 8
 2861              	4:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 arg_uint.c
     /tmp/ccdMexFx.s:6      .text:0000000000000000 resetfn
     /tmp/ccdMexFx.s:30     .text:000000000000001a strtol0X
     /tmp/ccdMexFx.s:147    .text:0000000000000112 detectsuffix
     /tmp/ccdMexFx.s:251    .text:00000000000001c4 scanfn
     /tmp/ccdMexFx.s:462    .text:00000000000003dc checkfn
     /tmp/ccdMexFx.s:514    .text:0000000000000406 errorfn
     /tmp/ccdMexFx.s:674    .text:00000000000005e3 arg_uint0
     /tmp/ccdMexFx.s:746    .text:000000000000066b arg_uintn
     /tmp/ccdMexFx.s:708    .text:0000000000000627 arg_uint1

UNDEFINED SYMBOLS
__ctype_b_loc
toupper
strtoul
__stack_chk_fail
fprintf
fwrite
arg_print_option
malloc
